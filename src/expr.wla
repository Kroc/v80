; v80, (C) Kroc Camen 2023-2024, MIT License
; expression parsing / evaulation
;
; TODO: support combined unary operators (e.g. `!<`)
;       will work in eval but needs parser support
; TODO: parentheses
;
.BLOCK  "code-expr"

; expression bytecode:
;-------------------------------------------------------------------------------
; calculations are compiled into bytecode to allow for later evaluation,
; i.e. for deferred calculations where a symbol is not yet known
; (note that the actual address is filled in at runtime)
;
expr:   .ADDR   $fc7f                   ; expr token space (builds downwards)
defer:  .ADDR   $0000                   ; addr of last deferred expr
param:  .BYTE   $00                     ; parameter type / relative-flag


parseParam:
;===============================================================================
; read an expression and write it to the code-segment:
;
; in:   A               parameter size & relative-jump flag:
;                       set to the number of bytes the parameter must occupy
;                       in the code-segment. bit 7 set indicates relative jump
;       *               see nextParam below for remaining parameters / returns
;-------------------------------------------------------------------------------
        ld      [param],        A

        ; fallthrough
        ; ...

nextParam:
;===============================================================================
; evaluate an expression and write it to the code-segment:
;
; in:   HL              current heap position -- if the expression is deferred
;                       it will be copied to the heap
;       [param]         the param size & rel-flag byte must be set
;                       (see parseParam above)
;
; out:  BC              expr value. if deferred, BC is length of expr bytecode
;       HL              heap addr will be modified if expr is deferred
;       A, DE           (clobbered)
;-------------------------------------------------------------------------------
        ; parse the next expression and evaluate it. if it contains a
        ; forward-reference, the parameter cannot be validated (yet)
        ; and it'll be pushed to the heap for later
        ;
        call    nextExpr                ; parse and evaluate expression
        jp      c,      deferExpr       ; defer to heap? note early exit

        ; validate size / value:
        ;-----------------------------------------------------------------------
        ld      A,      [param]         ; retrieve the parameter type
        rla                             ; pop hi-bit (relative-flag) into carry
        jr      c,      @rel            ; handle relative jump parameter
        rra                             ; correct param byte from above shift

        ; write the result to the code-segment
        ;
        ld      [IY+$00],       C       ; write value lo-byte
        inc     IY                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ; TODO: error for 16-bit value in 8-bit parameter
        dec     A
        ret     z

        ld      [IY+$00],       B       ; write value hi-byte
        inc     IY                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ret

        ;=======================================================================
        ; (for now, we assume a relative parameter is the only parameter and is
        ;  1-byte wide as that's the case with most 8-bit CPUs I'm aware of)
        ;
@rel:   ex      DE,     HL              ; preserve heap-addr in DE

        ; BC is the value of the expr -- the address to jump to. we calculate
        ; the relative offset with 'value - PC' so that positive is forward and
        ; negative is backward. we can only do 16-bit subtractions in HL so we
        ; swap BC & HL and then load BC with the virtual program-counter
        ;
        ld      H,      B               ; copy BC (destination)
        ld      L,      C               ;  into HL (for SBC HL, BC)

        ; the relative offset byte has to account for two automatic increments
        ; of the program-counter, the first by the parameter byte itself
        inc     IX
        ld      B,      IXH             ; load BC with current
        ld      C,      IXL             ;  virtual program-counter (IX)

        ; and the second is the automatic incrementing of the program-counter
        ; after every instruction, here compensated by carry already being set!
        ; (this was done by the rel-flag check at the start of this routine)
        ;
        sbc     HL,     BC              ; do 'destination - PC'

        ; check for 8-bit signed bounds:
        ;-----------------------------------------------------------------------
        ; the carry-flag indicates if the jump is forward (clear) or backward
        ; (set). we set A to 0 or -1 ($FF) depending on carry-flag: (any value
        ; minus itself is 0, but the carry-flag is an additional -1)
        sbc     A,      A

        ; detect 8-bit overflow in either direction: if the distance is > 255
        ; then the hi-byte will not be all 1s (negative) or all 0s (positive)
        ; therefore we expect A = H. compare sets flags without changing A,
        ; allowing us to do two tests using the same A value!
        cp      H
        jp      nz,     errRelJump              ; err if hi-byte is not 'empty'

        ; because the relative-distance byte is signed, we expect its sign
        ; to match that of the result -- a forward jump can only produce
        ; a positive distance; if the lo-byte is negative it's a positive
        ; distance that's too large (>127, i.e. hi-bit set)
        xor     L
        jp      m,      errRelJump              ; if sign bits differ, error

        ; output relative-distance byte:
        ;-----------------------------------------------------------------------
        ; (note the virtual program-counter, IX, has already been incremented)
        ;
        ld      [IY+$00],       L       ; write relative distance byte
        inc     IY                      ; move to next byte in code-segment
        ex      DE,     HL              ; restore heap-addr to HL
        ret


deferExpr:
;===============================================================================
; defer expression:
;
; in:   HL              heap position to push expr bytecode on to
;       BC              length of expr bytecode (provided by `parseExpr`)
;
; out:  HL              updated heap position
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ; we need to push a bunch of values to the heap and the fastest way
        ; to write 16-bit values easily is... the stack! simply make the heap
        ; into the stack and we can PUSH our stuff on to it!
        ;
        ; WE DO NOT NEED TO DISABLE INTERRUPTS!!! any interrupt is going to
        ; push to our heap and then pop the address off when it returns,
        ; which has no effect on the values we're pushing
        ;
        ld      [sp],   SP              ; backup stack pointer
        ld      SP,     HL              ; move stack to heap!
        ;-----------------------------------------------------------------------

        ; link this expression to the previous one:
        ; (since the heap address is in SP, we can reuse HL)
        ;
        ld      HL,     [defer]         ; get previous deferred expr address
        push    HL                      ; write to heap
        ld      [defer],SP              ; write heap addr to the entry point!

        ; push the current code-segment position; this is where
        ; the expression result will be filled in after evaluation
        push    IY

        ; push the current virtual program-counter
        ; (for calculating relative jumps)
        push    IX                      ; PC is always stored in IX, not RAM

        ld      HL,     [row]           ; push the source file
        push    HL                      ;  line-number (16-bits)
        ld      HL,     [filenum_col]   ; push file-number & column-number
        push    HL                      ; (combined because they're 1-byte ea.)

        ;-----------------------------------------------------------------------
        ld      HL,     0               ; there is no `LD HL, SP` (!?), so
        add     HL,     SP              ;  it's quicker to just add SP to 0!
        ld      SP,     [sp]            ; restore stack pointer!

        ; since the expression result is not known we can't validate it and
        ; we need to skip over the parameter bytes for now. the parameter
        ; size & rel-flag byte needs to be kept for when the deferred expr
        ; is reevaluated so it's written to the first reserved byte
        ;
        ld      A,      [param]         ; read param size + rel-flag byte
        ld      [IY+$00],       A       ; store it in the reserved byte
        and     %01111111               ; strip rel-flag in hi-bit
        inc     IY                      ; step over first byte
        inc     IX                      ; advance program-counter to match
        dec     A                       ; is there another byte?
        jr      z,      +               ; if not, skip ahead
        inc     IY                      ; step over 2nd byte
        inc     IX                      ; advance program-counter to match

+       ; copy expression bytecode to the heap:
        ;
        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ;
        ; TODO: create a shared routine for doing LDDR?
        ;
        dec     HL                      ; fix heap addr for copy-then-DEC
        ld      DE,     [expr]
        ex      DE,     HL
        lddr                            ; copy BC bytes *from* [HL] *to* [DE]!
        ex      DE,     HL
        inc     HL                      ; fix heap addr after copy

        ret


nextExpr:
;===============================================================================
; skip spaces before parsing an expression:
; (see parseExpr below for parameters)
;
;-------------------------------------------------------------------------------
        ld      A,      [char]          ; last character read
        cp      ASCII_SPC               ; space is the only valid whitespace
        call    z,      nextWord        ; if space, skip spaces
        cp      ASCII_SPC+1             ; non-visible character?
        jp      c,      errExpectExpr   ; error if end-of-line / end-of-file

        ; fallthrough
        ; ...

parseExpr:
;===============================================================================
; parse an expression from the input file, tokenise and evaluate it,
; returning the result:
;
; in:   HL              current heap addr
;       [char]          the first character of the expression is assumed to be
;                       read. do not call this routine with whitespace as the
;                       last character read!
;
; out:  BC              the result of the expression evaluation. if the expr
;                       cannot be evaluated and has to be deferred, BC is the
;                       length of the expression bytecode
;       cf              carry-clear indicates success
;                       carry-set indicates the expression includes
;                       forward-references and couldn't be evaluated
;       [char]          depending where an expression ends, the last character
;                       read can be either whitespace/EOL/EOF *OR* the first-
;                       character of the following word
;       A, DE           (clobbered)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ; expressions are tokenised into a space below the stack. this is
        ; because any forward-references to labels will need to be pushed to
        ; the heap so we can't write the expr on the heap at the same time!
        ;
        push    HL                      ; preserve heap addr
        ld      HL,     [expr]          ; addr of expr bytecode space
        xor     A                       ; set A to zero
        ld      [@flag],A               ; clear 'defer' flag
        ld      A,      [char]          ; get current unused input char
        jr      @unary                  ; jump into the parsing loop

        ;-----------------------------------------------------------------------
@flag   .BYTE   $00                     ; defer flag

        ;=======================================================================
        ; label?
        ;-----------------------------------------------------------------------
@label: call    getLabel                ; try get the label's value

        ; if the expression contains a forward-reference to a label we won't
        ; be able to evaluate the expression now and it needs to be deferred
        ;
        ; NOTE: it is very imporant to be aware that in the case of carry-set,
        ;       `getLabel` has returned the addr of the label's flag byte in DE
        ;
        jr      c,      +

        ; if the label is known, push a number literal token of its address
        ; and fall through to looking for a following operator token
        jr      nz,     @num

        ; this label has not been seen before but because it's in an expression
        ; this is a forward-reference -- we need to add a placeholder for the
        ; label on the heap before we can defer the whole expression
        ;
        ; swap our current position within the token space with the
        ; heap position preserved at the beginning of the routine!
        ex      [SP],   HL

        ; WARN: `pushLabel` requires the name length in BC which is returned
        ;       by `getLabel` when a label is a forward-reference / not-found
        ;
        scf                             ; set flag indicating forward-reference
        call    pushLabel               ; define the label name on the heap
        ld      D,      H               ; HL = last byte of label record
        ld      E,      L               ; copy HL to DE
        inc     DE                      ; step back to value hi-byte addr
        inc     DE                      ; step back to flag-byte addr

        ; save updated heap position for return and
        ; swap back to our position in token space
        ex      [SP],   HL

        ; any expression that contains a forward-reference to a label causes
        ; the whole expression to be deferred. instead of the label value,
        ; the address of the label's flag-byte in the dictionary is tokenised
        ;
+       ld      [HL],   CHAR_LABEL      ; push the label token
        dec     HL                      ; move to next token space
        ld      [HL],   D               ; push the label value addr hi-byte
        dec     HL                      ; move to next token space
        ld      [HL],   E               ; push the label value addr lo-byte
        dec     HL                      ; move to next token space

        ld      A,      %10000000       ; set the deferred flag -- this will be
        ld      [@flag],A               ;  checked at the end of the expression

        jr      @op                     ; an operator can follow a label

        ;=======================================================================
        ; (exit-route for forward-references:)
        ;
        ; calculate length of expression; this is needed to defer the expr
        ; to the heap. the bytecode is ordered *downwards* in memory, so the
        ; difference from the end address to the starting adress is the length
        ;
        ; the expr buffer runs from $xx7F downwards to $xx20
        ; so an 8-bit subtraction is sufficient
        ;
@defer: ld      B,      A               ; B must be 0 (LDDR uses BC)
        ld      A,      [expr]          ; start with highest addr (expr-start)
        sub     A,      L               ; subtract lowest addr (expr-end)
        ld      C,      A               ; this is the expr length (1-based)
        pop     HL                      ; restore heap addr to HL

        ; because the expression could not be evaluated
        ; we must return carry-flag set to indicate no-value
        scf
        ret

        ;=======================================================================
        ; add an operator and fall-through to the next operand:
        ;
@next:  ld      [HL],   A               ; push token in A to expr
        dec     HL                      ; move to next token space

        call    nextWord                ; read first character of the next word
        jp      z,      errExpr         ; newline/EOF = unexpected expr end!

        ;-----------------------------------------------------------------------
        ; unary operators:
        ;=======================================================================
        ; an expression must begin with either a value,
        ; or a unary operator and a value
        ;
        ; unary operators can always precede values,
        ; even after an operator, e.g. `$10 + <:label`
        ;
@unary: cp      CHAR_OP_LO              ; lo-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      CHAR_OP_HI              ; hi-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      CHAR_OP_NOT             ; not operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      CHAR_OP_NEG             ; negate operator?
        jr      nz,     @value          ; no unary operators, check for values

        ; a unary operator has been added,
        ; read the next character:
+       ld      [HL],   A               ; push a unary operator token
        dec     HL                      ; move to next token space

        ; TODO: support multiple unary operators without separating space
        ;
        call    nextWord                ; read first character of the next word
        jp      z,      errExpr         ; newline/EOF = unexpected expr end!

        ; after a unary operator, a value must follow
        ;
@value: cp      CHAR_HEX                ; hexadecimal sigil?
        jr      z,      @hex            ;
        cp      CHAR_LABEL              ; a label?
        jr      z,      @label          ;
        cp      CHAR_CONST              ; a constant?
        jp      nz,     errExpr         ; no? expression has no value!!

        ; fallthrough to const-handling
        ; ...

        ;-----------------------------------------------------------------------
        ; constant?
        ;-----------------------------------------------------------------------
@const: call    getConst                ; try get the constant's value
        jp      z,      errConstUndef   ; exprssion contains undefined const!
        ;-----------------------------------------------------------------------
        ; hexadecimal literal?
        ;-----------------------------------------------------------------------
        ; (micro-optimisation: the zero-flag conditional here is to allow
        ;  the fall-through from above to skip this one instruction)
        ;
@hex:   call    z,      parseHexNumber  ; parse the hex number into BC

        ; push a literal number token:
        ;-----------------------------------------------------------------------
@num:   ld      [HL],   CHAR_HEX        ; push a number token
        dec     HL                      ; move to next token space
        ld      [HL],   B               ; push the number hi-byte
        dec     HL                      ; move to next token space
        ld      [HL],   C               ; push the number lo-byte
        dec     HL                      ; move to next token space

        ; an operator can follow a value
        ; ...

        ;-----------------------------------------------------------------------
        ; operators:
        ;=======================================================================
        ; check for end-of-line / end-of-file after the value!
        ;
@op:    ld      A,      [char]          ; last read character
        cp      ASCII_SPC               ; ASCII<32 = newline (or end-of-file)?
        jr      c,      @end

        ; a value has been added, check for the presence of an operator:
        ; if there's no operator, the expression ends here
        ;
        call    nextWord                ; read first character of the next word
        jr      z,      @end            ; end expr at newline / end-of-file

        cp      CHAR_OP_ADD             ; add operator?
        jr      z,      @next           ; push token to heap, find next operand
        cp      CHAR_OP_SUB             ; subtract operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_MUL             ; multiply operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_AND             ; and operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_OR              ; or operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_XOR             ; xor operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_MOD             ; modulo operator?
        jr      z,      @next           ; ...
        cp      CHAR_OP_DIV             ; divide operator?
        jr      z,      @next           ; ...

        ; whatever it is, it isn't an operator;
        ; fall through and terminate the expression
        ; ...

        ; end of expr:
        ;=======================================================================
        ; TODO: check for heap spill here?
        ;
@end:   ld      A,      [@flag]         ; get the defer flag
        sla     A                       ; pop the hi-bit off into carry
        ld      [HL],   A               ; end expr with null terminator
        jr      c,      @defer          ; do not evaluate forward-refs!

        pop     HL                      ; restore heap addr to HL
        ld      DE,     [expr]          ; eval expr from temp bytecode space

        ; fallthrough to evaluate the expr
        ; ...

evalExpr:
;===============================================================================
; evaluates an expr:
;
; WARN: this routine DOES NOT CHECK if the expression is deferred!
;       expressions are deferred when parsed from source code; it is assumed
;       once all code is parsed that all labels will have been defined and
;       evaluation will now succeed -- any label that is still undefined
;       at evaluation time is a hard error!
;
; TODO: with some rearranging, we might be able to keep the running-total
;       in HL and use DE for the value (better for EX DE, HL + ADD|SBC HL, DE)
;
; in:   DE              addr of expr (could be [`expr`] or on the heap!)
; out:  BC              result value
;       HL              (preserved)
;       A, DE           (clobbered)
;-------------------------------------------------------------------------------
        ; we won't need to push anything new to the heap during evaluation
        ; so we preserve the current heap position
        push    HL
@expr:  ex      DE,     HL              ; use HL for reading tokens for now

        ; evaluation consists of a running total (in DE), an operator,
        ; and the next value (in BC). we need to start the expression
        ; with the first value, before any [non-unary] operator
        ;
        call    evalValue               ; read first value
        ld      E,      C               ; initialise running
        ld      D,      B               ;  total in DE

        call    @eval

        ld      C,      E               ; copy the final
        ld      B,      D               ;  total to BC
        xor     A                       ; return carry-clear for success
        pop     HL                      ; restore heap position

        ret

        ;=======================================================================
@eval:  ld      A,      [HL]            ; read token type
        and     A                       ; (set CPU flags!)
        ret     z                       ; end on expr terminator
        push    AF                      ; keep operator until after value

        dec     HL                      ; move to next token space
        call    evalValue               ; get value before applying operator

        pop     AF                      ; restore operator before the value
        cp      CHAR_OP_ADD             ; add operator?
        jr      z,      @add            ; ...
        cp      CHAR_OP_SUB             ; subtract operator?
        jr      z,      @sub            ; ...
        cp      CHAR_OP_MUL             ; multiply operator?
        jr      z,      @mul            ; ...
        cp      CHAR_OP_AND             ; bitwise AND operator?
        jr      z,      @and            ; ...
        cp      CHAR_OP_OR              ; bitiwse OR operator?
        jr      z,      @or             ; ...
        cp      CHAR_OP_XOR             ; bitwise XOR operator?
        jr      z,      @xor            ; ...
        cp      CHAR_OP_MOD             ; modulo operator?
        jr      z,      @mod            ; ...

        ; only remaining operator is DIV!
        ; ...

        ; operators:
        ;=======================================================================
        ; divide operator:
        ;-----------------------------------------------------------------------
@div:   push    HL                      ; preserve expr position
        call    @dodiv                  ; returns DE divided by BC
        pop     HL                      ; restore expr position
        ret

        ; divide routine used from here:
        ; <http://z80-heaven.wikidot.com/math#toc15>
        ;
@dodiv: ld      A,      16              ; number of bit-shifts to do
        ld      HL,     0               ; initialise remainder
        jr      +                       ; jump into divide loop

--      add     HL,     BC
-       dec     A
        ret     z

+       sla     E
        rl      D
        adc     HL,     HL
        sbc     HL,     BC
        jr      nc,     --
        inc     E
        jr      -
        ;-----------------------------------------------------------------------
        ; modulo operator:
        ;-----------------------------------------------------------------------
@mod:   push    HL                      ; preserve expr position
        call    @dodiv                  ; returns DE divided by BC
        ex      DE,     HL              ; swap remainder to DE
        pop     HL                      ; restore expr position
        ret                             ; continue evaluating
        ;-----------------------------------------------------------------------
        ; add operator:
        ;-----------------------------------------------------------------------
        ; TODO: err on overflow?
@add:   ex      DE,     HL              ; switch running total to HL
        add     HL,     BC              ; add value to total
        ex      DE,     HL              ; swap expr addr back to HL
        ret                             ; continue evaluating
        ;-----------------------------------------------------------------------
        ; subtract operator:
        ;-----------------------------------------------------------------------
        ; TODO: err on underflow?
@sub:   ex      DE,     HL              ; switch running total to HL
        sbc     HL,     BC              ; subtract value from total
        ex      DE,     HL              ; swap expr addr back to HL
        ret                             ; continue evaluating
        ;-----------------------------------------------------------------------
        ; multiply operator:
        ;-----------------------------------------------------------------------
        ; TODO: err on overflow?
@mul:   push    HL                      ; preserve expr position

        ; multiply routine used from here:
        ; <http://z80-heaven.wikidot.com/math#toc4>
        ;
        ; TODO: we don't need the upper 16-bits of a 32-bit result so this
        ;       might be able to be simplified further; we could add the
        ;       multiplier in A as we shift bits off DE and after 8-bits,
        ;       swap A to H and loop again, i.e. do two 8*8-bit multiplies
        ;
        ld      HL,     0               ; HL is lower 16-bits of 32-bit result
        ld      A,      16              ; number of bit shifts to do
-       add     HL,     HL
        rl      E                       ; shift DE up by 1 bit
        rl      D                       ; 
        jr      nc,     +               ; if the popped bit is 1
        add     HL,     BC              ;  then add the multipler
        jr      nc,     +
        inc     DE
+       dec     A
        jr      nz,     -

        ex      DE,     HL              ; result goes in DE
        pop     HL                      ; restore expr position
        ret
        ;-----------------------------------------------------------------------
        ; bitwise AND operator:
        ;-----------------------------------------------------------------------
@and:   ld      A,      D               ; bitwise AND hi-bytes together
        and     A,      B               ; ..
        ld      D,      A               ; .
        ld      A,      E               ; bitwise AND lo-bytes together
        and     A,      C               ; ..
        ld      E,      A               ; .
        ret                             ; continue evaluating
        ;-----------------------------------------------------------------------
        ; bitwise OR operator:
        ;-----------------------------------------------------------------------
@or:    ld      A,      D               ; bitwise OR hi-bytes together
        or      A,      B               ; ..
        ld      D,      A               ; .
        ld      A,      E               ; bitwise OR lo-bytes together
        or      A,      C               ; ..
        ld      E,      A               ; .
        ret                             ; continue evaluating
        ;-----------------------------------------------------------------------
        ; bitwise XOR operator:
        ;-----------------------------------------------------------------------
@xor:   ld      A,      D               ; bitwise XOR hi-bytes together
        xor     A,      B               ; ..
        ld      D,      A               ; .
        ld      A,      E               ; bitwise XOR lo-bytes together
        xor     A,      C               ; ..
        ld      E,      A               ; .
        ret                             ; continue evaluating


evalValue:
;===============================================================================
; evaluate a value from expr bytecode:
;
; read the next value from expr bytecode and returns it in BC:
; - if present, unary operator(s) are applied before return
; - TODO: parentheses are evaluated recursively
;-------------------------------------------------------------------------------
        ld      A,      [HL]            ; read token type
        dec     HL                      ; move to next token space

        ; take fast-path for values without a unary operator
        ;
        cp      CHAR_HEX                ; number literal?
        jr      z,      @hex            ;
        cp      CHAR_LABEL              ; a label? (that was deferred)
        jr      z,      @label          ;

        ; we don't care what unary operator is present, we'll need
        ; the value first, so store the unary operator until later
        push    AF

        ; recurse, fetching the value that follows --
        ; this allows for multiple unary operators per value
        call    evalValue

        pop     AF                      ; restore the unary operator
        cp      CHAR_OP_LO              ; lo-byte unary operator?
        jr      z,      @lo             ; ...
        cp      CHAR_OP_HI              ; hi-byte unary operator?
        jr      z,      @hi             ; ...
        cp      CHAR_OP_NEG             ; negate unary operator?
        jr      z,      @neg

        ; ...

        ; NOT unary operator:
        ;-----------------------------------------------------------------------
@not:   ld      A,      B               ; invert bits in B
        cpl                             ; ..
        ld      B,      A               ; .
        ld      A,      C               ; invert bits in C
        cpl                             ; ..
        ld      C,      A               ; .
        ret
        ;-----------------------------------------------------------------------
        ; LO-byte unary operator:
        ;-----------------------------------------------------------------------
@lo:    ld      B,      0               ; clear the hi-byte
        ret
        ;-----------------------------------------------------------------------
        ; HI-byte unary operator:
        ;-----------------------------------------------------------------------
@hi:    ld      C,      B               ; swap the hi-byte into the lo-byte
        ld      B,      0               ;  and clear the hi-byte
        ret
        ;-----------------------------------------------------------------------
        ; NEGate unary operator:
        ;-----------------------------------------------------------------------
        ; 16-bit negate taken from:
        ; <www.smspower.org/Development/Z80ProgrammingTechniques#x16bitNeg>
        ;
@neg:   xor     A                       ; set A to zero and clear flags
        sub     C                       ; do 0-C
        ld      C,      A               ; .
        sbc     A,      A               ; set A to 0 or -1 based on carry
        sub     B                       ; do 0-B (+carry)
        ld      B,      A               ; .
        ret                             ; WARN: carry may be set!

        ;=======================================================================
        ; read a number literal:
        ;-----------------------------------------------------------------------
@hex:   ld      B,      [HL]
        dec     HL
        ld      C,      [HL]
        dec     HL

        ret

        ;-----------------------------------------------------------------------
        ; read a label addr:
        ;-----------------------------------------------------------------------
        ; known labels are always resolved to number literals during parsing,
        ; so the only labels that remain at evaluation are forward-references:
        ; the token value contains the address of the label's flag-byte
        ;
@label: push    DE                      ; preserve running total

        xor     A                       ; (set A to zero, clear carry-flag)
        ld      E,      [HL]            ; read label flag-byte addr into DE
        dec     HL                      ; ...
        ld      D,      [HL]            ; ..
        dec     HL                      ; .
        ex      DE,     HL              ; switch flag-byte addr to HL
        or      A,      [HL]            ; is the flag byte 0? (=fwd-ref!)
        jp      z,      errLabelUndef   ; label was never defined!
        dec     HL                      ; skip over flag byte
        ld      C,      [HL]            ; read label value into BC
        dec     HL                      ; ..
        ld      B,      [HL]            ; .

        ex      DE,     HL              ; switch back to expr addr in HL
        pop     DE                      ; restore running total
        ret


parseHexNumber:
;===============================================================================
; parses an ASCII hexadecimal number and returns the value:
;
; a hexadecimal sigil without a number (`$`) is a special case
; that always returns the current virtual program-counter
;
; out:  BC              the value, 0 padded for numbers < 256
;       cf              carry-flag is set for virtual program-counter return
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;       A, DE           (clobbered)
;-------------------------------------------------------------------------------
        ; try to read up to 4 digits; the 5th character
        ; must be whitespace or newline / end-of-file!
        ;
        ; the bottom of the word-buffer is used for temporary bytes
        ; (e.g. $FC00..) as we know this is page-aligned and can use
        ; INC E instead of INC DE
        ;
        ld      BC,     5<<8            ; B=5, C=0
        ld      DE,     [temp]          ; where to write the bytes
        ;-----------------------------------------------------------------------
-       call    readChar                ; read a char from file
        cp      ASCII_SPC+1             ; ASCII space or below?
        jr      c,      +               ; stop when reaching whitespace
        ld      [DE],   A               ; append byte
        inc     E                       ; space for next digit
        djnz    -                       ; decrement B, loop until 0
        ;-----------------------------------------------------------------------
        ; if a 5th byte was read that wasn't whitespace,
        ; it's an error -- the number is too long!
        jp      errHex

        ;-----------------------------------------------------------------------
+       ld      DE,     [temp]          ; go back to the start of the number

        ; number of digits in hex number is reversed;
        ; B=1 for 4 digits, B=2 for 3 digits, B=3 for 2 digits and B=4 for 1,
        ; and lastly B=5 for 0 digits, i.e. `$`, the program-counter
        ;
        dec     B                       ; 4 digits?
        jr      z,      @four           ; ...
        dec     B                       ; 3 digits?
        jr      z,      @three          ; ...
        dec     B                       ; 2 digits?
        jr      z,      @two            ; ...
        dec     B                       ; 1 digit?
        jr      z,      @one            ; ...

        ; return virtual program counter:
        ;-----------------------------------------------------------------------
        ; a hex sigil without a number (i.e. `$`) is a special symbol
        ; that always returns the current virtual program-counter
        ;
        scf                             ; carry-flag indicates substitution
        ld      B,      IXH             ; transfer virtual program-counter
        ld      C,      IXL             ;  to return value

        ret

        ; four-digit hex number:
        ;=======================================================================
        ; a 4th digit must go in the upper nybble of B:
        ;
@four:  call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      B,      A               ; answer goes in B
        inc     E                       ; move to 3rd digit
        ;-----------------------------------------------------------------------
        ; a 3rd digit goes in the lower nybble of B:
        ;
@three: call    @digit                  ; convert digit to number
        or      B                       ; combine with hi-nybble (if present)
        ld      B,      A               ; answer goes in B
        inc     E                       ; move to 2nd digit
        ;-----------------------------------------------------------------------
        ; a 2nd digit goes in the upper nybble of C:
        ;
@two:   call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      C,      A               ; answer goes in C
        inc     E                       ; move to 1st digit
        ;-----------------------------------------------------------------------
        ; 1st digit goes in the lower nybble of C:
        ;
@one:   call    @digit                  ; convert digit to number
        or      C                       ; combine with hi-nybble (if present)
        ld      C,      A               ; answer goes in C

        ret                             ; ship it!

        ; convert a digit to a number:
        ;=======================================================================
        ; whitespace must already be precluded. err if not hex-digit
        ;
        ; if we unset bit 5 then ASCII "a"-"f" ($61-) becomes "A"-"F" ($41-)
        ; without also altering existing uppercase letters. This also has the
        ; side-effect of changing ASCII "0"-"9" ($30-$39) to codes $10-$19!
        ; (this is why ASCII codes 0-32 must be precluded beforehand)
        ;
@digit: ld      A,      [DE]            ; get digit
        res     5,      A               ; force upper-case for "a"-"f"

        ; TODO: check for >"F" and reject early, allowing us to avoid
        ;       the `add 10` at the end with some rework?

        ; by subtracting $41 ("A"), "A" = 0 & "F" = 5 with everything else,
        ; including "0"-"9", being 'above' this (negative is >=128)
        ;
        sub     $41                     ; rebase to "A"
        cp      6                       ; check for "A"-"F"
        jr      c,      +               ; if "A"-"F", exit

        ; having eliminated characters above "F", shift the axis right
        ; so that "0" is at 0. any character below "0" will be negative
        add     $31
        cp      10                      ; check for 0-9
        ret     c                       ; (conditional RET first is slightly
        jp      errHex                  ;  faster than conditional JP first)

+       add     10                      ; change "A"-"F" to 10-15
        ret

.ENDB