; v80, (C) Kroc Camen 2023-2024, MIT License
; error stuff
;
.BLOCK  "code-err"

_errmsg:
;===============================================================================
; this is a lookup table from error code (ERR_*) to string address to print
;-------------------------------------------------------------------------------
.DEF    ERR_INVAL_EXPR          0       ; invalid expression
        .ADDR   @inval_expr
.DEF    ERR_INVAL_FILE          1       ; invalid file-name
        .ADDR   @inval_file
.DEF    ERR_INVAL_INS           2       ; invalid CPU instruction
        .ADDR   @inval_ins
.DEF    ERR_INVAL_KEY           3       ; invalid keyword
        .ADDR   @inval_key
.DEF    ERR_INVAL_NUM           4       ; invalid number
        .ADDR   @inval_num
.DEF    ERR_INVAL_STR           5       ; invalid string
        .ADDR   @inval_str
.DEF    ERR_INVAL_SYM           6       ; invalid symbol
        .ADDR   @inval_sym
.DEF    ERR_RANGE_INS           7       ; out-of-range instruction parameter
        .ADDR   @range_ins
.DEF    ERR_RANGE_STR           8       ; `.w` does not support strings
        .ADDR   @range_ins
.DEF    ERR_REDEF_LABEL         9       ; label redefined
        .ADDR   @redef_label
.DEF    ERR_UNDEF_CONST         10      ; const undefined
        .ADDR   @undef_const
.DEF    ERR_UNDEF_FILE          11      ; file not found
        .ADDR   @undef_file
.DEF    ERR_UNDEF_LABEL         12      ; label undefined
        .ADDR   @undef_label
.DEF    ERR_UNEXP_DEFER         13      ; label cannot be deferred here
        .ADDR   @unexp_defer
.DEF    ERR_UNEXP_EOL           14      ; unexpected end-of-line / file
        .ADDR   @unexp_eol
;-------------------------------------------------------------------------------
; TODO: provide extended error message descriptions in an external file,
;       loading and printing them rather than storing them here
;
@err            .BYTE "\r\n\r\nERROR: ",0
@inval_expr     .BYTE "Invalid expression!", 0
@inval_file     .BYTE "Invalid file-name!", 0
@inval_ins      .BYTE "Invalid instruction!", 0
@inval_key      .BYTE "Invalid keyword!", 0
@inval_num      .BYTE "Invalid number!", 0
@inval_str      .BYTE "Invalid string!", 0
@inval_sym      .BYTE "Invalid symbol name!", 0
@range_ins      .BYTE "Expression too large for 8-bit instruction parameter!", 0
@range_str      .BYTE ".w cannot take strings!", 0
@redef_label    .BYTE "Labels cannot be redefined!", 0
@undef_const    .BYTE "Undefined constant!", 0
@undef_file     .BYTE "File not found!", 0
@undef_label    .BYTE "Label is undefined!", 0
@unexp_defer    .BYTE "Forward-references to labels not allowed here!", 0
@unexp_eol      .BYTE "Expected expression!", 0


; print error message and quit:
;===============================================================================
; this is a fall through 'ladder' that sets A to the value based on entrypoint.
; opcode $21 is manually inserted to skip the next LD A instruction and so on.
; 
errInvalExpr:
        ;-----------------------------------------------------------------------
        xor     A                       ; = ERR_INVAL_EXPR
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalFile:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_FILE  ; err code for invalid file-name
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalIns:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_INS   ; err code for invalid CPU instruction
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalKey:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_KEY   ; err code for invalid keyword
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalNum:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_NUM   ; err code for invalid number
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalStr:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_STR   ; err code for invalid string
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalSym:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_SYM   ; err code for invalid symbol
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeIns:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_INS   ; err code for out-of-range parameter
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeStr:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_STR   ; err code for string with .w
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRedefLabel:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_REDEF_LABEL ; err code for label redefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefConst:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_CONST ; err code for const undefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefFile:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_FILE  ; err code for file not found
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefLabel:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_LABEL ; err code for label undefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUnexpDefer:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNEXP_DEFER ; err code for disallowed fwd-reference
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUnexpEOL:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNEXP_EOL   ; err code for unexpected end-of-line

        ; fall through
        ; ...

err:
;===============================================================================
; print an error message and quit:
;
; in:   A               error number (an index to the errmsg table)
; out:  -               program terminates!
;===============================================================================
        add     A,      A               ; double index number for table lookup
        ld      C,      A               ; load into BC
        ld      B,      0               ;  for 16-bit add

        ld      DE,     _errmsg@err     ; print two newlines and a leading
        call    osPrintStrZ             ;  "ERROR:" string (preserves BC)

        ld      HL,     _errmsg         ; err msg lookup table
        add     HL,     BC              ; offset into table
        ld      E,      [HL]            ; get string addr lo-byte
        inc     HL                      ; ...
        ld      D,      [HL]            ; get string addr hi-byte

        ; fall through
        ; ...

errPrintQuit:
;===============================================================================
; (print error string and quit to OS)
;
; in:   DE              address of error string, zero-terminated, to print
; out:  -               program terminates!
;-------------------------------------------------------------------------------
        call    osPrintLn               ; print passed error-string

        ; if the file-name addr is $0000 this is not a parsing error,
        ; such as the command line parameter file-name not being found
        ;
        ld      A,      [file+1]        ; file-names are pushed to the heap
        and     A                       ;  so it is sufficient to check only
        jp      z,      osQuit          ;  if the hi-byte is $00

        ; print file-name, line number and column:
        ; TODO: decimal output for line/col numbers
        ;
        ld      DE,     @file
        call    osPrintStrZ

        ; print file-name:
        ld      DE,     [file]          ; addr of current file-name
        call    printHeapStr            ; print the backwards string

        ; print start-of-word line number and column:
        ; (this is not the same as the line/col of last char read
        ;  which could be the end-of-line after an expression)
        ;
        ld      DE,     @row
        call    osPrintStrZ
        ld      BC,     [wrow]
        call    printHexWord
        ld      DE,     @col
        call    osPrintStrZ
        ld      A,      [wcol]
        call    printHexByte

        jp      osQuit

@file   .BYTE   " FILE: ", 0
@row    .BYTE   "\r\n LINE: $", 0
@col    .BYTE   " COL: $", 0

.ENDB