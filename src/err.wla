; v80, (C) Kroc Camen 2023-2024, MIT License
; error stuff
;
.BLOCK  "code-err"

_errmsg:
;===============================================================================
; this is a lookup table from error code (ERR_*) to string address to print
;-------------------------------------------------------------------------------
.DEF    ERR_INVAL_EXPR          0       ; invalid expression
        .ADDR   @inval_expr
.DEF    ERR_INVAL_FILE          1       ; invalid file-name
        .ADDR   @inval_file
.DEF    ERR_INVAL_INS           2       ; invalid instruction
        .ADDR   @inval_ins
.DEF    ERR_INVAL_KEY           3       ; invalid keyword
        .ADDR   @inval_key
.DEF    ERR_INVAL_NUM           4       ; invalid number
        .ADDR   @inval_num
.DEF    ERR_INVAL_STR           5       ; invalid string
        .ADDR   @inval_str
.DEF    ERR_INVAL_SYM           6       ; invalid symbol
        .ADDR   @inval_sym
.DEF    ERR_RANGE_HEAP          7       ; heap overflow!
        .ADDR   @range_heap
.DEF    ERR_RANGE_INS           8       ; out-of-range instruction parameter
        .ADDR   @range_ins
.DEF    ERR_RANGE_LINE          9       ; line too long
        .ADDR   @range_line
.DEF    ERR_RANGE_OVER          10      ; expression overflow
        .ADDR   @range_over
.DEF    ERR_RANGE_STACK         11      ; stack overflow!
        .ADDR   @range_stack
.DEF    ERR_RANGE_STR           12      ; `.w` does not support strings
        .ADDR   @range_str
.DEF    ERR_REDEF_LABEL         13      ; label redefined
        .ADDR   @redef_label
.DEF    ERR_UNDEF_CONST         14      ; const undefined
        .ADDR   @undef_const
.DEF    ERR_UNDEF_FILE          15      ; file not found
        .ADDR   @undef_file
.DEF    ERR_UNDEF_LABEL         16      ; label undefined
        .ADDR   @undef_label
.DEF    ERR_UNEXP_DEFER         17      ; label cannot be deferred here
        .ADDR   @unexp_defer
.DEF    ERR_UNEXP_EOL           18      ; unexpected end-of-line / file
        .ADDR   @unexp_eol
;-------------------------------------------------------------------------------
; TODO: provide extended error message descriptions in an external file,
;       loading and printing them rather than storing them here
;
@inval_expr     .BYTE "Invalid expression", 0
@inval_file     .BYTE "Invalid file-name", 0
@inval_ins      .BYTE "Invalid instruction", 0
@inval_key      .BYTE "Invalid keyword", 0
@inval_num      .BYTE "Invalid number", 0
@inval_str      .BYTE "Invalid string", 0
@inval_sym      .BYTE "Invalid symbol name", 0
@range_heap     .BYTE "Heap overflow", 0
@range_ins      .BYTE "Expression exceeds 8-bit parameter", 0
@range_line     .BYTE "Line too long, 127 cols max.", 0
@range_over     .BYTE "Expression overflow", 0
@range_stack    .BYTE "Stack overflow", 0
@range_str      .BYTE ".w cannot take strings", 0
@redef_label    .BYTE "Labels cannot be redefined", 0
@undef_const    .BYTE "Undefined constant", 0
@undef_file     .BYTE "File not found", 0
@undef_label    .BYTE "Label was not defined", 0
@unexp_defer    .BYTE "Forward-references to labels not allowed here", 0
@unexp_eol      .BYTE "Expected expression", 0


; print error message and quit:
;===============================================================================
; this is a fall through 'ladder' that sets A to the value based on entrypoint.
; opcode $21 is manually inserted to skip the next LD A instruction and so on.
; 
errInvalExpr:
        ;-----------------------------------------------------------------------
        xor     A                       ; = ERR_INVAL_EXPR
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalFile:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_FILE  ; err code for invalid file-name
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalIns:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_INS   ; err code for invalid instruction
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalKey:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_KEY   ; err code for invalid keyword
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalNum:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_NUM   ; err code for invalid number
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalStr:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_STR   ; err code for invalid string
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errInvalSym:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_INVAL_SYM   ; err code for invalid symbol
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeHeap:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_HEAP  ; err code for heap overflow!
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeIns:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_INS   ; err code for out-of-range parameter
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeLine:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_LINE  ; err code for line too long
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeOver:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_OVER  ; err code for expression overflow
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeStack:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_STACK ; err code for stack overflow!
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRangeStr:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_RANGE_STR   ; err code for string with .w
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errRedefLabel:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_REDEF_LABEL ; err code for label redefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefConst:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_CONST ; err code for const undefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefFile:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_FILE  ; err code for file not found
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUndefLabel:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNDEF_LABEL ; err code for label undefined
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUnexpDefer:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNEXP_DEFER ; err code for disallowed fwd-reference
        .BYTE   $21                     ; 'ld HL, $nnnn' (skip next 2 bytes!)
errUnexpEOL:
        ;-----------------------------------------------------------------------
        ld      A,      ERR_UNEXP_EOL   ; err code for unexpected end-of-line

        ; fall through
        ; ...

err:
;===============================================================================
; print an error message and quit:
;
; in:   A               error number (an index to the errmsg table)
; out:  -               program terminates!
;===============================================================================
        add     A,      A               ; double index number for table lookup
        ld      C,      A               ; load into BC
        ld      B,      0               ;  for 16-bit add

        call    osPrintNewline
        call    osPrintNewline
        ld      DE,     @err            ; print two newlines and a leading
        call    osPrintStrZ             ;  "ERROR:" string (preserves BC)

        ld      HL,     _errmsg         ; err msg lookup table
        add     HL,     BC              ; offset into table
        ld      E,      [HL]            ; get string addr lo-byte
        inc     HL                      ; ...
        ld      D,      [HL]            ; get string addr hi-byte

        call    osPrintStrZ             ; print passed error-string
        ld      A,      '!'             ; ("!" is shared between all error 
        call    osPrintChar             ;  messages. this saves 1 byte each
        call    osPrintNewline          ;  error message, after the 8th)
        ld      DE,     @txt            ; print following line
        call    osPrintLn               ;  with note on "error.txt"

        ; if the file-name addr is $0000 this is not a parsing error,
        ; such as the command line parameter file-name not being found
        ;
        ld      A,      [file+1]        ; file-names are pushed to the heap
        and     A                       ;  so it is sufficient to check only
        jp      z,      osQuit          ;  if the hi-byte is $00

        ; print file-name, line number and column:
        ;-----------------------------------------------------------------------
        ld      DE,     @file
        call    osPrintStrZ

        ; print file-name:
        ld      DE,     [file]          ; addr of current file-name
        call    printSymbolName         ; print the backwards string
        call    osPrintNewline          ;  + newline

        ; print start-of-word line number and column:
        ; (this is not the same as the line/col of last char read
        ;  which could be the end-of-line after an expression)
        ;
        ld      DE,     @row
        call    osPrintStrZ
        ld      BC,     [wrow]
        call    printDecNumber
        call    osPrintNewline
        ld      DE,     @col
        call    osPrintStrZ
        ld      A,      [wcol]
        ld      C,      A
        ld      B,      0
        call    printDecNumber

        jp      osQuit

@err    .BYTE   "! ERROR: ", 0
@txt    .BYTE   "!        See error.txt for detailed causes", 0
@file   .BYTE   "!  FILE: ", 0
@row    .BYTE   "!  LINE: ", 0
@col    .BYTE   "!   COL: ", 0

.ENDB