; v80, (C) Kroc Camen 2023-2024, MIT License
; error stuff
;
; TODO: use an error number to deduplicate these calls
; TODO: with any error, print out file name, line & col number
;
.BLOCK  "code-err"

_strFile        .BYTE "File not found!$"
_strWord        .BYTE "Word too long! (max 32 chars)$"
_strOpcode      .BYTE "Invalid Z80 instruction!$"
_strExpectParam .BYTE "Expected instruction parameter!$"
_strExpectExpr  .BYTE "Expected expression!$"
_strExpr        .BYTE "Invalid expression!$"
_strKeyword     .BYTE "Invalid keyword!$"
_strHex         .BYTE "Invalid hexadecimal number!$"
_strLabelRedef  .BYTE "Labels cannot be redefined!$"
_strLabelUndef  .BYTE "Label is undefined!$"
_strExprConst   .BYTE "Forward-references to labels not allowed here!$"
_strConstUndef  .BYTE "Undefined constant!$"

_printQuit:
;===============================================================================
; (print string and quit to OS)
;-------------------------------------------------------------------------------
        call    osPrintStr
        jp      osQuit

errFile:
;===============================================================================
; file not found!
;-------------------------------------------------------------------------------
        ld      DE,     _strFile
        jr      _printQuit

errWord:
;===============================================================================
; word is too long!
;-------------------------------------------------------------------------------
        ld      DE,     _strWord
        jr      _printQuit

errOpcode:
;===============================================================================
; not a recognised opcode!
;-------------------------------------------------------------------------------
        ld      DE,     _strOpcode
        jr      _printQuit

errExpectParam:
;===============================================================================
; instruction parameter expected!
;-------------------------------------------------------------------------------
        ld      DE,     _strExpectParam
        jr      _printQuit

errExpectExpr:
;===============================================================================
; expression expected!
;-------------------------------------------------------------------------------
        ld      DE,     _strExpectExpr
        jr      _printQuit

errExpr:
;===============================================================================
; not a valid expression!
;-------------------------------------------------------------------------------
        ld      DE,     _strExpr
        jr      _printQuit

errKeyword:
;===============================================================================
; not a valid keyword!
;-------------------------------------------------------------------------------
        ld      DE,     _strKeyword
        jr      _printQuit

errHex:
;===============================================================================
; not a valid hexadecimal number!
;-------------------------------------------------------------------------------
        ld      DE,     _strHex
        jr      _printQuit

errLabelRedef:
;===============================================================================
; labels cannot be redefined!
;-------------------------------------------------------------------------------
        ld      DE,     _strLabelRedef
        jr      _printQuit

errLabelUndef:
;===============================================================================
; label is undefined! (forward-reference remains)
;-------------------------------------------------------------------------------
        ld      DE,     _strLabelUndef
        jr      _printQuit

errExprConst:
;===============================================================================
; forward-references to labels not allowed in constant /
; program-counter defines!
;-------------------------------------------------------------------------------
        ld      DE,     _strExprConst
        jr      _printQuit

errConstUndef:
;===============================================================================
; use of undefined constant in expr!
;-------------------------------------------------------------------------------
        ld      DE,     _strConstUndef
        jr      _printQuit

.ENDB

.MACRO .printFlags
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printFlags
        ;///////////////////////////////////////////////////////////////////////
.ENDIF
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO .printCharA
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printChar
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      \1
        call    osPrintChar
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register A as a hexadecimal number:
;
.MACRO  .printA
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printA
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register BC as a hexadecimal number:
;
.MACRO  .printBC
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printBC
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print the value stored at an absolute address:
;
.MACRO  .printAddr
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [\1]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print the character stored at an absolute address:
;
.MACRO  .printAddrChar
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      [\1]
        call    osPrintChar
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register HL as a hexadecimal word:
;
.MACRO  .printHL
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      H
        call    printHexByte
        ld      A,      L
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printAddrHL
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [HL]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printDE
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      D
        call    printHexByte
        ld      A,      E
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printAddrDE
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [DE]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printLabel
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printLabel
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.IFDEF  DEBUG
;///////////////////////////////////////////////////////////////////////////////

.memStat:
;===============================================================================
; prints memory status:
;-------------------------------------------------------------------------------
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ex      DE,     HL              ; swap SP into DE
        ld      HL,     @stack          ; stack addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [heap]
        ld      HL,     @heap           ; heap addr position in string
        call    @hex                    ; convert and insert

        ld      D,      IYH
        ld      E,      IYL
        ld      HL,     @code           ; code addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     @mem
        jp      osPrintStr

        ;-----------------------------------------------------------------------
        ; convert DE to ASCII hexadecimal digits and insert in the string
        ;
@hex:   ld      A,      D
        call    @byte
        ld      A,      E
@byte:  call    getHexByte
        ld      [HL],   B
        inc     HL
        ld      [HL],   C
        inc     HL
        ret

        ;-----------------------------------------------------------------------
@mem    .BYTE   "[stack: "
@stack  .BYTE   "0000"
        .BYTE   " | heap: "
@heap   .BYTE   "0000"
        .BYTE   " | code: "
@code   .BYTE   "0000"
        .BYTE   "]\n$"


_printA:
;===============================================================================
        push    AF
        ld      A,      '$'
        call    osPrintChar             ; (does currently preserve A)
        pop     AF
        push    AF
        call    printHexByte            ; (does not preseve A)
        pop     AF
        ret

_printBC:
;===============================================================================
        push    AF
        ld      A,      '$'
        call    osPrintChar             ; (does currently preserve A)
        ld      A,      B
        call    printHexByte
        ld      A,      C
        call    printHexByte
        pop     AF
        ret

_printFlags:
;===============================================================================
        push    AF
        ld      A,      '['
        call    osPrintChar
        pop     AF

        jr      nz,     +

        push    AF
        ld      A,      'z'
        call    osPrintChar
        pop     AF

+       jr      nc,     +

        push    AF
        ld      A,      'c'
        call    osPrintChar
        pop     AF

+       push    AF
        ld      A,      ']'
        call    osPrintChar
        pop     AF

        ret


_printLabel:
;===============================================================================
        push    AF
        push    BC
        push    DE
        push    HL

        ex      DE,     HL              ; use DE for label record addr

        ; label addr:
        ;-----------------------------------------------------------------------
        ld      HL,     @line+1         ; position in prepared string
        ld      A,      D               ; label record addr, hi-byte
        call    @hex                    ; insert hex digits in prepared string
        ld      A,      E               ; label record addr, lo-byte
        call    @hex                    ; insert hex digits in prepared string

        ; link-addr:
        ;-----------------------------------------------------------------------
        ; the label record addr is positioned on the lo-byte of the link-addr
        ;
        ld      HL,     @line+8         ; link-addr in prepared string
        inc     DE                      ; record will be read decrement first,
        inc     DE                      ;  then read, so move upwards to begin
        call    @word                   ; insert hex digits in prepared string

        ; label-name length:
        ;-----------------------------------------------------------------------
        ld      HL,     @line+22        ; name length in prepared string
        call    @byte                   ; insert hex digits in prepared string

        ; label-name:
        ;-----------------------------------------------------------------------
        ld      HL,     @line+25
        ld      A,      [DE]            ; get name length again
        ld      B,      A               ; use as char counter
        ld      C,      B               ; and keep a copy for trailing spaces
        ;-----------------------------------------------------------------------
-       dec     DE                      ; (move to next char in label name)
        ld      A,      [DE]            ; read a character
        ld      [HL],   A               ; write to prepared string 
        inc     HL                      ; (move to next char in string)
        djnz    -

        ; fill the rest of the string with trailing spaces to avoid
        ; trailing garbage from previous longer label names:
        ;
        ld      A,      WORD_LEN        ; maximum number of chars
        sub     C                       ;  minus name length
        jr      z,      +               ; (skip if label name length = 31)
        ld      B,      A               ; = number of trailing spaces to fill
        ld      A,      ' '             ; fill with spaces
        ;-----------------------------------------------------------------------
-       ld      [HL],   A
        inc     HL
        djnz    -

        ; deferred-flag:
        ;-----------------------------------------------------------------------
        ; deferred = '!', normal = '$' (+3)
        ;
+       ld      HL,     @line+14        ; position in prepared string
        dec     DE                      ; (move to deferred flag field)
        ld      A,      [DE]            ; read deferred flag: 0 = deferred
        rrca                            ; pop flag off into carry
        ld      A,      '$'             ; addr uses "$" prefix for real addr
        jr      c,      +               ; and if flag is 1 (real), skip over
        sub     3                       ; change "$" to "!" for deferred value
+       ld      [HL],   A               ; insert this char into prepared string

        ; label value: (virtual address)
        ;-----------------------------------------------------------------------
        ld      HL,     @line+15        ; value in prepared string
        call    @word                   ; insert hex digits in prepared string

        ; output prepared string:
        ;-----------------------------------------------------------------------
        ld      HL,     @line           ; start addr of prepared string
        ld      B,      57              ; length of prepared string
-       ld      A,      [HL]            ; read a character
        call    osPrintChar             ; print it
        inc     HL                      ; move to next character
        djnz    -                       ; loop until all chars printed

        pop     HL
        pop     DE
        pop     BC
        pop     AF
        ret

        ;=======================================================================
@word:  dec     DE
        ld      A,      [DE]
        call    @hex
@byte:  dec     DE
        ld      A,      [DE]
@hex:   call    getHexByte              ; convert to hex-digits in BC
        ld      [HL],   B               ; write hi-nybble into output string
        inc     HL                      ; (move to next char)
        ld      [HL],   C               ; write lo-nybble into output string
        inc     HL                      ; (move to next char)

        ret

        ;-----------------------------------------------------------------------
@line:  .BYTE   "$0000: $0000 [$0000] $00 :                              "
        .BYTE   ASCII_LF, 0

;///////////////////////////////////////////////////////////////////////////////
.ENDIF
