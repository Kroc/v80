; v80, (C) Kroc Camen 2023-2024, MIT License
; CP/M-2.2 interface
;
; memory layout:
;-------------------------------------------------------------------------------
.MEMORYMAP
    DEFAULTSLOT 1
    ; RUNCPM 60K, BDOS @ $FD00, BIOS @ $FE00
    SLOT 0 START $0000 SIZE $0100       NAME "ZP"
    SLOT 1 START $0100 SIZE $FD00-$0100 NAME "TPA"
.ENDME

.ROMBANKSIZE $FD00-$0100
.ROMBANKS 1

; system constants:
;-------------------------------------------------------------------------------
CPM_VER                 = $22           ; CP/M version as BCD
CPM_VER_STR             = "2.2"         ; CP/M version as string

BOOT                    = $0000
TBASE                   = $0100         ; start of transient program area

; BDOS calls:
BDOS                    = $0005         ; call address to access BDOS

; function:             ; C = ?         ; notes:
BDOS_RESET              = 0             ; system reset
BDOS_CONIN              = 1             ; console input
BDOS_CONOUT             = 2             ; console output
BDOS_RDRIN              = 3             ; reader input
BDOS_PUNOUT             = 4             ; punch output
BDOS_LISTOUT            = 5             ; list output
BDOS_CONIO              = 6             ; direct console control
BDOS_GETIO              = 7             ; get I/O byte
BDOS_SETIO              = 8             ; set I/O byte
BDOS_PRNSTR             = 9             ; print string
BDOS_CONBUF             = 10            ; buffered console input (line input)
BDOS_CONSTAT            = 11            ; get console status
BDOS_VER                = 12            ; get version number
BDOS_RSTDSK             = 13            ; reset disk system
BDOS_SELDSK             = 14            ; select disk
BDOS_OPEN               = 15            ; open file
BDOS_CLOSE              = 16            ; close file
BDOS_FIND1ST            = 17            ; search for first file
BDOS_FINDNEXT           = 18            ; search for next file
BDOS_DEL                = 19            ; delete file
BDOS_READSEQ            = 20            ; read sequential
BDOS_WRITESEQ           = 21            ; write sequential
BDOS_MAKEFILE           = 22            ; create new file
BDOS_RENFILE            = 23            ; rename file
BDOS_LOGIN              = 24            ; return bitmap of present drives A-P
BDOS_CURDSK             = 25            ; get current disk
BDOS_SETDMA             = 26            ; set DMA address at $0008
BDOS_GETADDR            = 27            ; get addr of disk allocation
BDOS_WRTPTRCT           = 28            ; write protect disk
BDOS_GETRO              = 29            ; get read-only bitmap for drives A-P
BDOS_SETATTR            = 30            ; set file attributes
BDOS_DSKPARMS           = 31            ; get file parameters addr
BDOS_USER               = 32            ; set/return user number
BDOS_READRND            = 33            ; read random-access
BDOS_WRITERND           = 34            ; write random-access
BDOS_FILESIZE           = 35            ; get file size
BDOS_RECORD             = 36            ; get random-access record
BDOS_RSTDRV             = 37            ; reset drive
BDOS_FILLZERO           = 40            ; random-access zero-out

.STRUCT FileControlBlock
        drive           BYTE            ; 0 = default, 1 = A: ... 16 = P:
        name            DSB 8           ; file-name, first 8-letters
        type            DSB 3           ; file-name, extension. NB: no dot!
        extent          BYTE            ; extent, for files > 128 records
        rsvrd           WORD            ; reserved
        rec_count       BYTE            ; number of records in extent, 0-127
        data            DSB 16          ; internal use -- directory record?
        cur_rec         BYTE            ; current record number
        rnd_rec         FARADDR         ; optional random record number
.ENDST

.RAMSECTION "CPM_FCB"                   SLOT "ZP" ORGA $5C FORCE RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
cpm_fcb                 INSTANCEOF FileControlBlock
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS
.RAMSECTION "CPM_DMA"                   SLOT "ZP" ORGA $80 FORCE RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
cpm_dma                 DSB 128
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS


; bootstrap:
;===============================================================================
.BLOCK  "os-cpm"

.BANK 0 SLOT "TPA"
.ORGA TBASE

boot:
;===============================================================================
        ; check CP/M version -- it's not likely we're going to be running
        ; on CP/M-1 but this same check will be required for a CP/M-3 version
        ;
        ld      C,      BDOS_VER
        call    BDOS
        ld      A,      L               ; compare returned version
        cp      CPM_VER                 ;  with required CP/M version
        jr      c,      @err            ; ver < CPM_VER, quit with error

        ;-----------------------------------------------------------------------
        ; when a program is loaded in CP/M a small stack is created, enough
        ; to call the BDOS/BIOS. we want to set the stack to the top of
        ; memory although that depends were the TPA ends and the BDOS begins
        ;
        ; the address at $06/07 points to the beginning of BDOS,
        ; so if we set the stack there the first push will go to BDOS-1.
        ; on RunCPM this is $FD00
        ;
        ld      HL,     [BDOS+1]        ; get BDOS address from `JP $xxxx`
        ld      L,      0               ; normalise to beginning of page
        ld      SP,     HL              ; set stack pointer

        ; always print the banner first,
        ; it differs for each OS/platform
        ;
        ld      DE,     @banner         ; print the program banner
        call    osPrintLn

        ; run the program:
        jp      init                    ; we will not return from here!

        ;-----------------------------------------------------------------------
@banner .BYTE   "v80 CP/M v0.0 - github.com/kroc/v80\r\n"
        .BYTE   "(C) Kroc Camen 2023-2024, MIT License", 0

        ;=======================================================================
        ; CP/M version less than 2.2 -- call BDOS manually for safety
        ;
@err:   ld      DE,     @@str           ; version error string
        ld      C,      BDOS_PRNSTR     ; print using BDOS directly
        jp      BDOS                    ; call BDOS but also return to CCP

        ; string is "$" terminated for compatibility with CP/M < v2.2?
@@str   .BYTE "ERROR: CP/M ", CPM_VER_STR, " or higher required!$"


osQuit:
;===============================================================================
; quit the application and return to the OS: (if present)
;-------------------------------------------------------------------------------
        ld      C,      BDOS_RESET      ; CP/M doesn't require us to unwind
        jp      BDOS                    ;  the stack, we can just reset


osParseParameters:
;===============================================================================
; parse the command-line parameters:
;
; return an address to a forwards, null-terminated string of the input
; file-name and also read or generate the output file-name and store
; it privately (the OS does the binary write-out by itself)
;
; out:  DE              addr of input file-name, forwards, null-terminated
;-------------------------------------------------------------------------------
        ; search for a first parameter: (input file-name)
        ;
        ; in CP/M the "command tail", the portion of the command line following
        ; the executable name is in the DMA buffer ($80) by default. the first
        ; byte is the length, but the string is also null-terminated
        ;
        ; WARN: the command-tail in the DMA buffer is overwritten by the first
        ;       sector read of a file so we must copy the parameters out!
        ;
        ld      HL,     cpm_dma+1       ; begin search from 1st char
        ld      DE,     _infile         ; copy to here
        call    _getParam               ; look for / copy 1st parameter
        jr      z,      @help           ; if none, show help text

        ; the optional 2nd param sets the output file-name:
        ;
        ld      DE,     _outfile        ; this time, copy here
        call    _getParam               ; look for a 2nd parameter
        jr      nz,     +               ; if output file-name given, skip

        ; TODO: create the output file-name from the input

+       ld      DE,     _infile         ; return input param str addr
        ret

        ;=======================================================================
@help:  ld      DE,     @@str
        call    osPrintStrZ
        jp      osQuit

@@str   .BYTE   "    V80 FILE.V80 [FILE.COM]", 0

_infile:                                ; command-line input file-name param
        .BYTE   "            ", 0       ;
_outfile:                               ; command-line output file-name param
        .BYTE   "            ", 0       ;

_getParam:
;===============================================================================
; finds and copies a command-line parameter:
;
; this routine walks along the command tail and finds the start of a parameter
; word (any non-space chars) which will be copied to the destination addr (DE)
;
; for CP/M a limit of 12 characters is imposed as CP/M files must be in 8.3
; format, even though CP/M doesn't store the "." internally meaning that the
; file-name could still be invalid if the dot is missing or in the wrong place
; -- these checks are done when opening the file
;
; in:   HL              addr of command-line string, null-terminated
;       DE              addr of space to copy parameter to, up to 12 characters
;                       will be copied and a null-terminator appended
; out:  HL              the string addr is advanced according to the param
;       zf              zero-flag is set if null-terminator occurs before any
;                       characters are captured! if this happens, the value
;                       of DE & HL are *invalid*
;       DE              (preserved) -- rewound to the start of the param str
;       A, BC           (clobbered)
;-------------------------------------------------------------------------------
        ld      BC,     13              ; reset char limit
        .BYTE   $e6                     ; skip next instructionl $E6 = AND $..
        ;-----------------------------------------------------------------------
-       inc     L                       ; move to next char in command tail
        ld      A,      [HL]            ; read char from command tail
        and     A                       ; is it a null-terminator?
        ret     z                       ; null-terminator before any parameter!
        cp      ASCII_SPC+1             ; is it <=ASCII space (tab)
        jr      c,      -               ; skip any spaces/tabs
        ;-----------------------------------------------------------------------
        push    DE                      ; start of param str will be returned
        ld      A,      ASCII_SPC+1     ; pre-load comparison (spc, tab, null)
        ;-----------------------------------------------------------------------
-       ldi                             ; = LD [DE], HL; INC DE; INC HL; DEC BC
        jp      po,     errUndefFile    ; error if copied 13th char w/o NULL
        cp      [HL]                    ; is char <=ASCII space (inc. tab, null)
        jr      c,      -               ; if not keep going
        ;-----------------------------------------------------------------------
        ld      A,      0               ; patch in null terminator
        ld      [DE],   A               ; (mustn't set zero-flag!)
        pop     DE                      ; return start of param str
        ret


osFileOpen:
;===============================================================================
; open a file:
;
; for reasons of code density and simplicity, file reading *must* be nested,
; that is, files must be opened and closed in LIFO order so that reads are not
; interleved; if a file is opened it must be closed before you can return to
; the previously open file. this works fine for source file includes that only
; read files start to finish, nesting inwards
;
; this state can occupy a lot of stack space (34 bytes on CP/M!) which will
; limit the maximum nesting depth -- v80 recommends no more than 3 levels
;
; TODO: CP/M-3 has a "parse file-name" BDOS function, no.152
; TODO: support files on other drives? ("A:" prefix)
;       and user-numbers?? ("0A:" prefix)
;
; in:   DE              addr of the file-name to use, forwards, null-terminated
; out:  A, BC, DE       (clobbered)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ; allocate a new FileControlBlock on the stack:
        ;
        pop     BC                      ; steal the return address!
        exx                             ; put aside input parameters for now

        ; preserve the current FileControlBlock address under
        ; the new one to return to it once the file closes
        ;
        ; also write the current record byte index into the FCB
        ; (in the random record field that isn't used by us)
        ;
        ld      HL',    [_readSector@fcb+1]
        push    HL'                     ; backup previous FCB addr
        ld      A,      L'              ; FCB+33 is random-record byte
        add     33                      ;  we use to backup the read index
        ld      L',     A               ;  (random records are not used)
        ld      A,      [osGetChar@index+1]
        ld      [HL'],  A

        ; CP/M automatically increments the record number after each sector
        ; read. pre-decrement the current record so that the same record is
        ; re-read when restored from the stack
        ;
        ; TODO: does the rec_count need zeroing?
        dec     HL'                     ; current record byte is no.32
        dec     [HL']                   ; if underflow, we need to also
        jp      po,     +               ;  move to the previous extent

        ; TODO: extent underflow? there are 32 extents (0-31)
        ;       (CPM/3 uses FCB's SR2 byte for larger files,
        ;        this would be needed for files > 2MB)
        ;
        ld      A,      L               ; extent field is byte 12
        sub     20                      ; (subtract 20 from addr)
        ld      L,      A               ; ...
        dec     [HL']                   ;  and decrement by 1

        ; construct an empty FileControlBlock on the stack,
        ; working backwards (we don't use random records so
        ; the last 2 bytes are excluded to save stack space)
        ;
        ; TODO: we should check a stack overflow
        ;       won't occur here beforehand
        ;
+       ld      DE',    0               ; fill the last 22 bytes with zeroes
        ld      B',     22/2            ; (half because pushing 2 bytes)
-       push    DE'                     ; push 2 zeroes to the stack
        djnz    -                       ; ...

        ; prefill the FCB file-name/ext with spaces since CP/M file-names have
        ; the extension separate from the file-name which is padded by spaces
        ;
        ld      B',     10/2            ; fill next 10 chars with spaces
        ld      DE,     $2020           ; (two spaces)
-       push    DE'                     ; file-name is space-padded
        djnz    -                       ; ...
        ld      E',     0               ; 1st byte = 0 (D) & 2nd = SPC (E)
        push    DE'                     ;  as file-name begins on 2nd FCB byte

        ; (the current stack-position is now the start of a new, empty, FCB)

        exx                             ; return to input parameters
        ld      [@fcb], SP              ; backup current stack-position (FCB)
        push    BC                      ; restore the return address!
        push    HL                      ; (preserve caller's HL)

        ; copy new file-name (DE) to the new FCB (HL):
        ;-----------------------------------------------------------------------
        ; copy & validate file-name according to CP/M rules:
        ; (the parser takes any string)
        ;
        ld      HL,     [@fcb]          ; retrieve new FCB addr
        inc     HL                      ; skip FCB drive byte
        ld      B,      8               ; max file-name chars (sans extension)
        call    @copy                   ; test/fix and copy up to 8 chars
        jr      z,      +               ; if null encountered, no extension

        ; copy file extension:
        ; (the dot has already been skipped by `@copy`)
        ;
        ld      HL,     [@fcb]          ; skip ahead to file-extension field
        ld      BC,     9               ;  (byte no.9 in the FCB)
        add     HL,     BC              ;  ...
        ld      B,      3               ; max extension chars (sans dot)
        call    @copy                   ; copy up to 3 chars for extension
        jr      nz,     @err            ; dot not allowed in extensions!

        ; now attempt to open the file:
        ; (CP/M will check if the file exists)
        ;-----------------------------------------------------------------------
+       ld      C,     BDOS_OPEN        ; BDOS function number
        ld      DE,    [@fcb]           ; address of the FileControlBlock
        call    BDOS                    ; call BDOS -> BIOS etc.
        and     A                       ; OK = 0, file not found = $FF
        jr      nz,     @err            ; error if not zero

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      DE,     [str]
        call    osPrintStrZ
        ld      A,      ':'
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ld      HL,     [@fcb]          ; update FCB addr for reading sectors
        ld      [_readSector@fcb+1],    HL
        pop     HL                      ; (restore caller's HL)
        jp      _readSector             ; read the first record from the file

@fcb    .ADDR   $0000

        ; test, fix & copy chars to FCB:
        ;=======================================================================
        ; in:   B                       max. number of chars to copy
        ; out:  A                       last character read
        ;       zf                      zf-set   = reached a null
        ;                               zf-clear = reached a dot
        ;-----------------------------------------------------------------------
@copy:  ld      A,      [DE]            ; read a source character
        inc     DE                      ; move to next source character
        and     A                       ; (set zero-flag)
        ret     z                       ; return zf-set on null-terminator
        cp      '.'                     ; is it a dot? (file/ext separator)
        jr      z,      +               ; if yes, return zf-clear instead
        call    @valid                  ; test/fix char (will err on invalid)
        ld      [HL],   A               ; write fixed char to FCB
        inc     HL                      ;  and move to next char
        djnz    @copy                   ; loop until all chars copied
        ;-----------------------------------------------------------------------
        ; if all chars are copied, the next char *must* be a dot (file-name)
        ; or the null-terminator (file-name or extension)
        ;
        ld      A,      [DE]            ; read ahead next character
        and     A                       ; set flags -- check for 0
        ret     z                       ; if null return zf-set
        cp      '.'                     ; check for dot
        inc     DE                      ; (skip over the dot for extension)
        jr      nz,     @err            ; not null or dot -- too many chars!
        ;-----------------------------------------------------------------------
+       and     A                       ; clear zero-flag for dot
        ret                             ; (A is last char code)

        ; test / fix char for CP/M file-names:
        ;=======================================================================
        ; the CP/M manual says that the following characters are not
        ; allowed in file-names: < > = , ! | * ? & / $ [ ] ( ) . : ; \ + -
        ;
        ; (note that whilst the dot is used as the separator for the
        ;  file extension, multiple dots cannot occur in a file-name!)
        ;
        ; with such a long list it is perhaps clearer to state the
        ; non-alphanum characters that _are_ valid: " # % ' @ ^ _ ` { } ~
        ; the chart below shows valid chars by "<" & ranges between "|"
        ;
        ;   $20        $30  0  <  $40  @  <  $50  P  |  $60  `  |  $70  p  |
        ;   $21  !     $31  1  |  $41  A  |  $51  Q  |  $61  a  |  $71  q  |
        ;   $22  "  <  $32  2  |  $42  B  |  $52  R  |  $62  b  |  $72  r  |
        ;   $23  #  <  $33  3  |  $43  C  |  $53  S  |  $63  c  |  $73  s  |
        ;   $24  $     $34  4  |  $44  D  |  $54  T  |  $64  d  |  $74  t  |
        ;   $25  %  <  $35  5  |  $45  E  |  $55  U  |  $65  e  |  $75  u  |
        ;   $26  &     $36  6  |  $46  F  |  $56  V  |  $66  f  |  $76  v  |
        ;   $27  '  <  $37  7  |  $47  G  |  $57  W  |  $67  g  |  $77  w  |
        ;   $28  (     $38  8  |  $48  H  |  $58  X  |  $68  h  |  $78  x  |
        ;   $29  )     $39  9  <  $49  I  |  $59  Y  |  $69  i  |  $79  y  |
        ;   $2A  *     $3A  :     $4A  J  |  $5A  Z  <  $6A  j  |  $7A  z  |
        ;   $2B  +     $3B  ;     $4B  K  |  $5B  [     $6B  k  |  $7B  {  <
        ;   $2C  ,     $3C  <     $4C  L  |  $5C  \     $6C  l  |  $7C  |   
        ;   $2D  -     $3D  =     $4D  M  |  $5D  ]     $6D  m  |  $7D  }  <
        ;   $2E  .     $3E  >     $4E  N  |  $5E  ^  <  $6E  n  |  $7E  ~  <
        ;   $2F  /     $3F  ?     $4F  O  |  $5F  _  |  $6F  o  |  $7F  âŒ‚   
        ;
        ; the CP/M file-system is upper-case only so we must fix file-names
        ; coming from source code. we expect v80 source files to use lower-
        ; case names so we optimise for that case, handling them first
        ;
@valid: cp      'a'                     ; ASCII code after lower-case A?
        jr      c,      @lt_a           ; branch to handle code below 'a'

        cp      'z'+1                   ; ASCII code above lower-case Z?
        jr      nc,     @gt_z           ; check only codes >'z'

        res     5,      A               ; unset bit 5 to switch a-z to A-Z
        ret                             ; return with case-fixed char

        ;-----------------------------------------------------------------------
        ; codes above lower-case Z: ($7B+)
        ;
@gt_z:  cp      $7F                     ; any char >= 127 (DEL) is invalid
        jr      nc,     @err            ; this leaves only "{", "|", "}" & "~"
        cp      '|'                     ;  of which only "|" is invalid
        ret     nz                      ; return if not "|", i.e. "{", "}" & "~"
        jr      @err                    ; error for "|"

        ;-----------------------------------------------------------------------
        ; codes below lower-case A ($61) make up the majority.
        ; the largest contiguous block is @ followed by upper-case A-Z
        ;
@lt_a:  cp      '@'                     ; ASCII code @ or above?
        jr      c,      @lt_at          ; no, handle codes below @ (numbers)
        cp      'Z'+1                   ; ASCII code below upper-case Z?
        ret     c                       ; upper-case A-Z is valid as-is
        cp      '^'                     ;  but above upper-case Z, only
        ret     nc                      ;  "^", "_" and "`" are valid, and
        jr      @err                    ;  "[", "|" and "]" are invalid

        ;-----------------------------------------------------------------------
        ; note that due to the branches already taken,
        ; any greater-than check assumes a ceiling below "@"
        ;
@lt_at: cp      '0'                     ; >= "0"?
        jr      c,      @lt_0           ; if no, handle codes below "0"
        cp      '9'+1                   ; <= "9"?
        ret     c                       ; "0"-"9" are valid as-is

        ; there are no valid chars after "9" and before "@"!
        ;
        jr      @err                    ; ":", ";", "<", "=", ">" & "?" invalid

        ;-----------------------------------------------------------------------
        ; there are only 4 valid characters below "0":
        ;
@lt_0:  cp      '"'
        ret     z
        cp      '#'
        ret     z
        cp      '%'
        ret     z
        cp      '''
        ret     z

        ; if none of the above,
        ; fallthrough to error
        ; ...

        ;=======================================================================
        ; hard error for file-names containing invalid characters
        ;
@err:   jp      errUndefFile


osFileClose:
;===============================================================================
; closes the currently open file:
; (and return to the previously open file)
;
; this routine must be called at the same stack level as the last osFileOpen
; call because the previous FileControlBlock is restored from the stack
;
; out:  HL              (preserved)
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        pop     BC                      ; steal our return address!

        ; discard the current FileControlBlock on the stack:
        ;
        ex      DE,     HL              ; (put aside current caller's HL)
        ld      HL,     34              ; move the stack pointer up 34 bytes
        add     HL,     SP              ;  throwing away the FileControlBlock
        ld      SP,     HL              ;  from the currently open file
        ex      DE,     HL              ; (restore caller's HL)

        ; re-read last file's current sector:
        ;-----------------------------------------------------------------------
        pop     DE                      ; restore previous FCB
        ld      [_readSector@fcb+1],    DE
        call    _readSector             ; re-read the previous file's sector
        ld      A,      E               ; restore the read index
        add     A,      33              ;  that was written to byte 33
        ld      E,      A               ;  of the FCB
        ld      A,      [DE]            ;  ...
        ld      [osGetChar@index+1],    A

        push    BC                      ; (restore our return address)
        ret


osGetChar:
;===============================================================================
; read an ASCII character from the currently open file:
;
; out:  A               character read
;       zf              zero-flag is set for end-of-file. NOTE: the character
;                       returned for end-of-file might not be NULL! CP/M uses
;                       ASCII_SUB for file termination
;       BC, DE, HL      (preserved)
;
; NOTE: this assumes no other file activity or user-input between reads!
;-------------------------------------------------------------------------------
        ; get byte:
        ;
        ; the sector is read to the "DMA" address, which is $80 by default.
        ; the address "$0080" is assembled into the instruction and the code
        ; increments this addr after each character read! when it overflows
        ; a new sector is read from disk and the index is reset to $80 again
        ;
@index  ld      A,      [cpm_dma]       ; get byte at current index

        ; in CP/M the ASCII SUB control code ($1A) terminates the file
        ; because all CP/M files are padded to 128 bytes sectors!
        ; <https://en.wikipedia.org/wiki/Substitute_character>
        ;
        cp      ASCII_SUB               ; is this a CP/M sector padding byte?
        ret     z                       ; return zero-flag set for EOF

        ; increment index:
        ;-----------------------------------------------------------------------
        ex      AF,     AF'             ; preserve read character
        ld      A',     [@index+1]      ; get current read index
        inc     A'                      ; move to next byte in sector
        jr      z,     +                ; if overflow, fetch next sector
        ld      [@index+1],     A'      ; update index
        ex      AF',    AF              ; restore read character
        ret

        ;-----------------------------------------------------------------------
+       call    _readSector             ; read next sector from disk
        ex      AF',    AF              ; return read character
        ret

_readSector:
        ;=======================================================================
        exx                             ; preserve BC/DE/HL

        ; if debugging is off, print a dot for each sector read;
        ; this will suffice for a rough progress indicator
.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      E',     '.'             ; = character to print
        ld      C',     BDOS_CONOUT     ; = BDOS function to call
        call    BDOS                    ; print a dot to screen
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ld      A,      <cpm_dma        ; reset read index
        ld      [osGetChar@index+1],    A

        ; read 1 sector from disk:
        ;
        ld      C',     BDOS_READSEQ    ; select BDOS function number
@fcb    ld      DE',    cpm_fcb         ; select FileControlBlock
        call    BDOS                    ; do the disk read
        exx                             ; (restore BC/DE/HL before return)
        dec     A                       ; check for A=1, EOF
        ret     nz                      ; return if no-error

        ; if an end-of-file occurs at a sector boundary then we need to return
        ; EOF on the *NEXT* call as the last character has already been read:
        ;
        ld      A,      ASCII_SUB       ; write the CP/M EOF marker
        ld      [cpm_dma],      A       ;  to the first byte for next read

        ret


osPrintLn:
;===============================================================================
; prints a null-terminated string and appends a newline: (CRLF)
;
; in:   DE              string-addr, must be 0-terminated
; out:  DE              DE is advanced according to the length of the string
;       HL, BC          (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        call    osPrintStrZ

        ; fallthrough
        ; ...

osPrintCRLF:
;===============================================================================
; print a newline!
;
; out:  BC, DE, HL      (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      A,      ASCII_CR
        call    osPrintChar
        ld      A,      ASCII_LF

        ; fallthrough
        ; ...

osPrintChar:
;===============================================================================
; prints a single ASCII character:
;
; in:   A               input character
; out:  A, BC, DE, HL   (preserved)
;-------------------------------------------------------------------------------
        exx                             ; swap to shadow registers

        ld      C',     BDOS_CONOUT     ; = BDOS function to call
        ld      E',     A               ; = character to print
        ld      L',     A               ; CP/M convention means that
        call    BDOS                    ;  on BDOS return, A = L

        exx                             ; restore register set
        ret


osPrintStrZ:
;===============================================================================
; print a null-terminated string:
;
; in:   DE              string-addr, must be 0-terminated
; out:  DE              DE is advanced according to the length of the string
;       A               zero, by nature of the null-terminator
;       HL, BC          (preserved)
;-------------------------------------------------------------------------------
-       ld      A,      [DE]            ; read a character
        and     A                       ; (set CPU flags!)
        inc     DE                      ; (go to next char, does not set zf!)
        ret     z                       ; return after null-terminator
        exx                             ; swap to shadow registers

        ld      E',     A               ; BDOS param for character
        ld      C',     BDOS_CONIO      ; BDOS function to use
        call    BDOS                    ; print character!

        exx                             ; return to normal registers
        jr      -                       ; keep looping until null-terminator


;osPrintBStr:
;===============================================================================
; print a length-prefixed string:
;
; in:   DE              string-addr, first byte is length in bytes, 1-based
; out:  DE              DE is advanced according to the length of the string
;       HL              (preserved)
;       A, BC           (clobbered)
;-------------------------------------------------------------------------------
;        push    HL                      ; preserve HL coming in
;        ld      A,      [DE]            ; read string-length
;        ld      B,      A               ; use as counter
;        ;----------------------------------------------------------------------
;-       inc     DE                      ; (move to next byte)
;        ld      A,      [DE]            ; read a character
;        exx                             ; swap to shadow registers
;
;        ld      E',     A               ; BDOS param for character
;        ld      C',     BDOS_CONIO      ; BDOS function to use
;        call    BDOS                    ; print character!
;
;        exx                             ; return to normal registers
;        djnz    -                       ; loop string length
;        ;----------------------------------------------------------------------
;        inc     DE                      ; (step over last byte)
;        pop     HL                      ; restore original HL
;        ret
;
.ENDB