; v80, (C) Kroc Camen 2023-2024, MIT License
; CP/M-2.2 interface
;
; memory layout:
;-------------------------------------------------------------------------------
.MEMORYMAP
    DEFAULTSLOT 1
    ; RUNCPM 60K, BDOS @ $FD00, BIOS @ $FE00
    SLOT 0 START $0000 SIZE $0100       NAME "ZP"
    SLOT 1 START $0100 SIZE $FD00-$0100 NAME "TPA"
.ENDME

.ROMBANKSIZE $FD00-$0100
.ROMBANKS 1

; system constants:
;-------------------------------------------------------------------------------
CPM_VER                 = $22           ; CP/M version as BCD
CPM_VER_STR             = "2.2"         ; CP/M version as string

BOOT                    = $0000
TBASE                   = $0100         ; start of transient program area

; BDOS calls:
BDOS                    = $0005         ; call address to access BDOS

; function:             ; C = ?         ; notes:
BDOS_RESET              = 0             ; system reset
BDOS_CONIN              = 1             ; console input
BDOS_CONOUT             = 2             ; console output
BDOS_RDRIN              = 3             ; reader input
BDOS_PUNOUT             = 4             ; punch output
BDOS_LISTOUT            = 5             ; list output
BDOS_CONIO              = 6             ; direct console control
BDOS_GETIO              = 7             ; get I/O byte
BDOS_SETIO              = 8             ; set I/O byte
BDOS_PRNSTR             = 9             ; print string
BDOS_CONBUF             = 10            ; buffered console input (line input)
BDOS_CONSTAT            = 11            ; get console status
BDOS_VER                = 12            ; get version number
BDOS_RSTDSK             = 13            ; reset disk system
BDOS_SELDSK             = 14            ; select disk
BDOS_OPEN               = 15            ; open file
BDOS_CLOSE              = 16            ; close file
BDOS_FIND1ST            = 17            ; search for first file
BDOS_FINDNEXT           = 18            ; search for next file
BDOS_DEL                = 19            ; delete file
BDOS_READSEQ            = 20            ; read sequential
BDOS_WRITESEQ           = 21            ; write sequential
BDOS_MAKEFILE           = 22            ; create new file
BDOS_RENFILE            = 23            ; rename file
BDOS_LOGIN              = 24            ; return bitmap of present drives A-P
BDOS_CURDSK             = 25            ; get current disk
BDOS_SETDMA             = 26            ; set DMA address at $0008
BDOS_GETADDR            = 27            ; get addr of disk allocation
BDOS_WRTPTRCT           = 28            ; write protect disk
BDOS_GETRO              = 29            ; get read-only bitmap for drives A-P
BDOS_SETATTR            = 30            ; set file attributes
BDOS_DSKPARMS           = 31            ; get file parameters addr
BDOS_USER               = 32            ; set/return user number
BDOS_READRND            = 33            ; read random-access
BDOS_WRITERND           = 34            ; write random-access
BDOS_FILESIZE           = 35            ; get file size
BDOS_RECORD             = 36            ; get random-access record
BDOS_RSTDRV             = 37            ; reset drive
BDOS_FILLZERO           = 40            ; random-access zero-out

.STRUCT FileControlBlock
        drive           BYTE            ; 0 = default, 1 = A: ... 16 = P:
        name            DSB 8           ; file-name, first 8-letters
        type            DSB 3           ; file-name, extension. NB: no dot!
        extent          BYTE            ; extent, for files > 127 records
        rsvrd           WORD            ; reserved
        rec_count       BYTE            ; number of records in extent, 0-127
        data            DSB 16          ; depends on usage
        cur_rec         BYTE            ; current record number
        rnd_rec         FARADDR         ; optional random record number
.ENDST

.RAMSECTION "CPM_FCB"                   SLOT "ZP" ORGA $5C FORCE RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
cpm_fcb                 INSTANCEOF FileControlBlock
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS
.RAMSECTION "CPM_DMA"                   SLOT "ZP" ORGA $80 FORCE RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
cpm_dma                 DSB 128
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS


; bootstrap:
;===============================================================================
.BLOCK  "os-cpm"

.BANK 0 SLOT "TPA"
.ORGA TBASE

boot:
;===============================================================================
        ; check CP/M version -- it's not likely we're going to be running
        ; on CP/M-1 but this same check will be required for a CP/M-3 version
        ;
        ld      C,      BDOS_VER
        call    BDOS
        ld      A,      L               ; compare returned version
        cp      CPM_VER                 ;  with required CP/M version
        jr      c,      @err            ; ver < CPM_VER, quit with error

        ;-----------------------------------------------------------------------
        ; when a program is loaded in CP/M a small stack is created, enough
        ; to call the BDOS/BIOS. we want to set the stack to the top of
        ; memory although that depends were the TPA ends and the BDOS begins
        ;
        ; the address at $06/07 points to the beginning of BDOS,
        ; so if we set the stack there the first push will go to BDOS-1.
        ; on RunCPM this is $FD00
        ;
        ld      HL,     [BDOS+1]        ; get BDOS address from `JP $xxxx`
        ld      L,      0               ; normalise to beginning of page
        ld      SP,     HL              ; set stack pointer

        ; always print the banner first,
        ; it differs for each OS/platform
        ;
        ld      DE,     @banner         ; print the program banner
        call    osPrintLn

        ; run the program:
        jp      init                    ; we will not return from here!

        ;-----------------------------------------------------------------------
@banner .BYTE   "v80 CP/M v0, Kroc Camen 2023-2024", 0

        ;=======================================================================
        ; CP/M version less than 2.2 -- call BDOS manually for safety
        ;
@err:   ld      DE,     @@str           ; version error string
        ld      C,      BDOS_PRNSTR     ; print using BDOS directly
        jp      BDOS                    ; call BDOS but also return to CCP

        ; string is "$" terminated for compatibility with CP/M < v2.2?
@@str   .BYTE "ERROR: CP/M ", CPM_VER_STR, " or higher required!$"


osQuit:
;===============================================================================
; quit the application and return to the OS: (if present)
;-------------------------------------------------------------------------------
        ld      C,      BDOS_RESET      ; CP/M doesn't require us to unwind
        jp      BDOS                    ;  the stack, we can just reset


osGetParams:
;===============================================================================
; return a null-terminated, forwards string of the command-line parameters:
;
; in CP/M the "command tail", the portion of the command line following the
; executable name is in the DMA buffer ($0080) by default. it is prefixed by
; its length, but also null-terminated for us!
;
; out:  DE              addr of parameter string
;-------------------------------------------------------------------------------
        ld      DE,     cpm_dma+1       ; return first char of command tail
        ret


osFilePush
;===============================================================================
; preserve the current open file state on the stack:
;
; for reasons of code density and simplicity, file reading *must* be nested,
; that is, files must be opened and closed in LIFO order so that reads are not
; interleved; if a file is opened it must be closed before you can return to
; the previously open file. this works fine for source file includes that only
; read files start to finish, nesting inwards.
;
; this routines pushes the current file state to the stack, and `osFilePop`
; restores the previous file state. therefore, `osFilePop` *must* be called
; at the same stack level as `osFilePush`
;
; this state can occupy a lot of stack space (34 bytes on CP/M!) which will
; limit the maximum nesting depth -- v80 recommends no more than 3 levels
;
; out:  HL, DE          (preserved)
;       A, BC           (clobbered)
;-------------------------------------------------------------------------------
        pop     BC                      ; steal the return address!
        exx                             ; put aside input parameters for now

        ; push the current FileControlBlock on the stack:
        ;
        ; write the current record byte index into the FCB
        ; (in the random record field that isn't used by us)
        ;
        ld      A,      [osGetChar@index+1]
        ld      [cpm_fcb.rnd_rec],      A

        ; CP/M automatically increments the record number after each sector
        ; read. pre-decrement the current record so that the same record is
        ; re-read when popped from the stack
        ;
        ld      HL',    cpm_fcb.cur_rec ; decrement current record
        dec     [HL']                   ; if underflow, we need to also
        jp      po,     +               ;  move to the previous extent

        ; TODO: extent underflow?
        ;       (CPM/3 uses FCB's SR2 byte for larger files)
        ;
        ld      L',     <cpm_fcb.extent ; switch to extent field
        dec     [HL']                   ;  and decrement by 1

        ; push the FCB to the stack! we don't use random records,
        ; so the last 2 bytes are excluded to save stack space
        ;
        ; TODO: we should check a stack overflow won't occur here beforehand
        ;
+       ld      HL',    cpm_fcb         ; start addr
        ld      B',     34/2            ; pushing 34 bytes, 2 at a time
-       ld      E',     [HL']           ; read a first byte
        inc     L'                      ;  and combine with
        ld      D',     [HL']           ;  a second byte
        inc     L'                      ;  before pushing
        push    DE'                     ;  to the stack
        djnz    -                       ; do all bytes

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      C',     BDOS_CONOUT     ;
        ld      E',     '['             ;
        call    BDOS                    ;
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        exx                             ; return to input parameters
        push    BC                      ; put return address *after* FCB
        ret


osFileOpen:
;===============================================================================
; open a file:
;
; TODO: CP/M-3 has a "parse file-name" BDOS function, no.152
; TODO: support files on other drives? ("A:" prefix)
;       and user-numbers?? ("0A:" prefix)
;
; in:   DE              addr of the file-name to use, forwards, null-terminated
; out:  A, BC, DE       (clobbered)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ; copy new file-name to the FCB:
        ;
        push    HL                      ; preserve caller's HL
        ex      DE,     HL              ; swap source file-name to HL

        ; prefill the FCB file-name/ext with spaces since CP/M file-names have
        ; the extension separate from the file-name which is padded by spaces.
        ; this is done backwards so DE ends at the beginning of the file-name
        ;
        ld      DE,     cpm_fcb.name+11 ; file-name chars 0-10
        ld      B,      11              ; 8.3 but CP/M doesn't store the dot
        ld      A,      ' '             ; spaces (called "blanks" in CP/M?)
-       dec     E                       ; (the system FCB is in zero-page)
        ld      [DE],   A               ; write a space in the FCB
        djnz    -                       ; blank 11 chars and end at the start

        ; copy & validate file-name according to CP/M rules:
        ; (the parser takes any string)
        ld      B,      8               ; max file-name chars (sans extension)
        call    @copy                   ; test/fix and copy up to 8 chars
        jr      z,      +               ; if null encountered, no extension

        ; copy file extension:
        ; (the dot has already been skipped by `@copy`)
        ;
        ld      E,      <cpm_fcb.type   ; skip ahead to file-extension field
        ld      B,      3               ; max extension chars (sans dot)
        call    @copy                   ; copy up to 3 chars for extension
        jr      nz,     @err            ; dot not allowed in extensions!

        ; clear the remaining fields in the FCB:
        ;
+       xor     A                       ; (set A to zero)
        ld      [cpm_fcb.drive],        A
        ld      [cpm_fcb.extent],       A
        ld      [cpm_fcb.cur_rec],      A
        ld      [cpm_fcb.rec_count],    A

        ; now attempt to open the file:
        ; (CP/M will check if the file exists)
        ;-----------------------------------------------------------------------
        ld      C,     BDOS_OPEN        ; BDOS function number
        ld      DE,    cpm_fcb          ; address of the FileControlBlock
        call    BDOS                    ; call BDOS -> BIOS etc.
        and     A                       ; OK = 0, file not found = $FF
        jr      nz,     @err            ; error if not zero

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      DE,     [str]
        call    osPrintStrZ
        ld      A,      ':'
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        pop     HL                      ; (restore caller's HL)
        jp      _readSector             ; read the first record from the file

        ; test, fix & copy chars to FCB:
        ;=======================================================================
        ; in:   B                       max. number of chars to copy
        ; out:  A                       last character read
        ;       zf                      zf-set   = reached a null
        ;                               zf-clear = reached a dot
        ;-----------------------------------------------------------------------
@copy:  ld      A,      [HL]            ; read a source character
        inc     HL                      ; move to next source character
        and     A                       ; (set zero-flag)
        ret     z                       ; return zf-set on null-terminator
        cp      '.'                     ; is it a dot? (file/ext separator)
        jr      z,      +               ; if yes, return zf-clear instead
        call    @valid                  ; test/fix char (will err on invalid)
        ld      [DE],   A               ; write fixed char to FCB
        inc     E                       ;  and move to next char
        djnz    @copy                   ; loop until all chars copied
        ;-----------------------------------------------------------------------
        ; if all chars are copied, the next char *must* be a dot (file-name)
        ; or the null-terminator (file-name or extension)
        ;
        ld      A,      [HL]            ; read ahead next character
        and     A                       ; set flags -- check for 0
        ret     z                       ; if null return zf-set
        cp      '.'                     ; check for dot
        inc     HL                      ; (skip over the dot for extension)
        jr      nz,     @err            ; not null or dot -- too many chars!
        ;-----------------------------------------------------------------------
+       and     A                       ; clear zero-flag for dot
        ret                             ; (A is last char code)

        ; test / fix char for CP/M file-names:
        ;=======================================================================
        ; the CP/M manual says that the following characters are not
        ; allowed in file-names: < > = , ! | * ? & / $ [ ] ( ) . : ; \ + -
        ;
        ; (note that whilst the dot is used as the separator for the
        ;  file extension, multiple dots cannot occur in a file-name!)
        ;
        ; with such a long list it is perhaps clearer to state the
        ; non-alphanum characters that _are_ valid: " # % ' @ ^ _ ` { } ~
        ; the chart below shows valid chars by "<" & ranges between "|"
        ;
        ;   $20        $30  0  <  $40  @  <  $50  P  |  $60  `  |  $70  p  |
        ;   $21  !     $31  1  |  $41  A  |  $51  Q  |  $61  a  |  $71  q  |
        ;   $22  "  <  $32  2  |  $42  B  |  $52  R  |  $62  b  |  $72  r  |
        ;   $23  #  <  $33  3  |  $43  C  |  $53  S  |  $63  c  |  $73  s  |
        ;   $24  $     $34  4  |  $44  D  |  $54  T  |  $64  d  |  $74  t  |
        ;   $25  %  <  $35  5  |  $45  E  |  $55  U  |  $65  e  |  $75  u  |
        ;   $26  &     $36  6  |  $46  F  |  $56  V  |  $66  f  |  $76  v  |
        ;   $27  '  <  $37  7  |  $47  G  |  $57  W  |  $67  g  |  $77  w  |
        ;   $28  (     $38  8  |  $48  H  |  $58  X  |  $68  h  |  $78  x  |
        ;   $29  )     $39  9  <  $49  I  |  $59  Y  |  $69  i  |  $79  y  |
        ;   $2A  *     $3A  :     $4A  J  |  $5A  Z  <  $6A  j  |  $7A  z  |
        ;   $2B  +     $3B  ;     $4B  K  |  $5B  [     $6B  k  |  $7B  {  <
        ;   $2C  ,     $3C  <     $4C  L  |  $5C  \     $6C  l  |  $7C  |   
        ;   $2D  -     $3D  =     $4D  M  |  $5D  ]     $6D  m  |  $7D  }  <
        ;   $2E  .     $3E  >     $4E  N  |  $5E  ^  <  $6E  n  |  $7E  ~  <
        ;   $2F  /     $3F  ?     $4F  O  |  $5F  _  |  $6F  o  |  $7F  ⌂   
        ;
        ; the CP/M file-system is upper-case only so we must fix file-names
        ; coming from source code. we expect v80 source files to use lower-
        ; case names so we optimise for that case, handling them first
        ;
@valid: cp      'a'                     ; ASCII code after lower-case A?
        jr      c,      @lt_a           ; branch to handle code below 'a'

        cp      'z'+1                   ; ASCII code above lower-case Z?
        jr      nc,     @gt_z           ; check only codes >'z'

        res     5,      A               ; unset bit 5 to switch a-z to A-Z
        ret                             ; return with case-fixed char

        ;-----------------------------------------------------------------------
        ; codes above lower-case Z: ($7B+)
        ;
@gt_z:  cp      $7F                     ; any char >= 127 (DEL) is invalid
        jr      nc,     @err            ; this leaves only "{", "|", "}" & "~"
        cp      '|'                     ;  of which only "|" is invalid
        ret     nz                      ; return if not "|", i.e. "{", "}" & "~"
        jr      @err                    ; error for "|"

        ;-----------------------------------------------------------------------
        ; codes below lower-case A ($61) make up the majority.
        ; the largest contiguous block is @ followed by upper-case A-Z
        ;
@lt_a:  cp      '@'                     ; ASCII code @ or above?
        jr      c,      @lt_at          ; no, handle codes below @ (numbers)
        cp      'Z'+1                   ; ASCII code below upper-case Z?
        ret     c                       ; upper-case A-Z is valid as-is
        cp      '^'                     ;  but above upper-case Z, only
        ret     nc                      ;  "^", "_" and "`" are valid, and
        jr      @err                    ;  "[", "|" and "]" are invalid

        ;-----------------------------------------------------------------------
        ; note that due to the branches already taken,
        ; any greater-than check assumes a ceiling below "@"
        ;
@lt_at: cp      '0'                     ; >= "0"?
        jr      c,      @lt_0           ; if no, handle codes below "0"
        cp      '9'+1                   ; <= "9"?
        ret     c                       ; "0"-"9" are valid as-is

        ; there are no valid chars after "9" and before "@"!
        ;
        jr      @err                    ; ":", ";", "<", "=", ">" & "?" invalid

        ;-----------------------------------------------------------------------
        ; there are only 4 valid characters below "0":
        ;
@lt_0:  cp      '"'
        ret     z
        cp      '#'
        ret     z
        cp      '%'
        ret     z
        cp      '''
        ret     z

        ; if none of the above,
        ; fallthrough to error
        ; ...

        ;=======================================================================
        ; hard error for file-names containing invalid characters
        ;
@err:   jp      errUndefFile


osFileClose:
;===============================================================================
; closes the currently open file:
;
; NOTE: files in CP/M do not need to be closed unless written to
;-------------------------------------------------------------------------------
        ret


osFilePop:
;===============================================================================
; restores the position of the previous file:
;
; this routine must be called at the same stack level as the last osFilePush
; call because the previous file name / position is restored from the stack
;
; out:  HL              (preserved)
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        ; restore the FileControlBlock put on the stack by osFilePush!
        ;
        pop     BC                      ; steal the return address!
        exx                             ; put aside input parameters for now

        ; pull the FCB from the stack: 34 bytes!
        ; (reverse order due to the way the stack works)
        ;
        ld      HL',    cpm_fcb+34      ; destination addr, start at end
        ld      B',     34/2            ; pulling 34 bytes, 2 at a time
-       pop     DE'                     ; pull 2 bytes from stack
        dec     L'                      ; (the reverse order also means
        ld      [HL'],  D'              ;  we write back the hi-byte received
        dec     L'                      ;  first and then the lo-byte)
        ld      [HL'],  E'              ; ...
        djnz    -                       ; loop all 34 bytes

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      C',     BDOS_CONOUT     ;
        ld      E',     ']'             ;
        call    BDOS                    ;
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        exx                             ; return to input parameters
        push    BC                      ; restore the return address

        call    _readSector             ; re-read record and fix for EOF

        ; restore the index used for reading characters:
        ld      A,      [cpm_fcb.rnd_rec]
        ld      [osGetChar@index+1],    A

        ret


osGetChar:
;===============================================================================
; read an ASCII character from the currently open file:
;
; out:  A               character read
;       zf              zero-flag is set for end-of-file. NOTE: the character
;                       returned for end-of-file might not be NULL! CP/M uses
;                       ASCII_SUB for file termination
;       BC, DE, HL      (preserved)
;
; NOTE: this assumes no other file activity or user-input between reads!
;-------------------------------------------------------------------------------
        ; get byte:
        ;
        ; the sector is read to the "DMA" address, which is $80 by default.
        ; the address "$0080" is assembled into the instruction and the code
        ; increments this addr after each character read! when it overflows
        ; a new sector is read from disk and the index is reset to $80 again
        ;
@index  ld      A,      [cpm_dma]       ; get byte at current index

        ; in CP/M the ASCII SUB control code ($1A) terminates the file
        ; because all CP/M files are padded to 128 bytes sectors!
        ; <https://en.wikipedia.org/wiki/Substitute_character>
        ;
        cp      ASCII_SUB               ; is this a CP/M sector padding byte?
        ret     z                       ; return zero-flag set for EOF

        ; increment index:
        ;-----------------------------------------------------------------------
        ex      AF,     AF'             ; preserve read character
        ld      A',     [@index+1]      ; get current read index
        inc     A'                      ; move to next byte in sector
        jr      z,     +                ; if overflow, fetch next sector
        ld      [@index+1],     A'      ; update index
        ex      AF',    AF              ; restore read character
        ret

        ;-----------------------------------------------------------------------
+       call    _readSector             ; read next sector from disk
        ex      AF',    AF              ; return read character
        ret

_readSector:
        ;=======================================================================
        exx                             ; preserve BC/DE/HL

        ; if debugging is off, print a dot for each sector read;
        ; this will suffice for a rough progress indicator
.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      E',     '.'             ; = character to print
        ld      C',     BDOS_CONOUT     ; = BDOS function to call
        call    BDOS                    ; print a dot to screen
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ld      A,      <cpm_dma        ; reset read index
        ld      [osGetChar@index+1],    A

        ; read 1 sector from disk:
        ;
        ld      C',     BDOS_READSEQ    ; select BDOS function number
        ld      DE',    cpm_fcb         ; use default FileControlBlock @ $005C
        call    BDOS                    ; do the disk read
        exx                             ; (restore BC/DE/HL before return)
        dec     A                       ; check for A=1, EOF
        ret     nz                      ; return if no-error

        ; if an end-of-file occurs at a sector boundary then we need to return
        ; EOF on the *NEXT* call as the last character has already been read:
        ;
        ld      A,      ASCII_SUB       ; write the CP/M EOF marker
        ld      [cpm_dma],      A       ;  to the first byte for next read

        ret


osPrintLn:
;===============================================================================
; prints a null-terminated string and appends a newline: (CRLF)
;
; in:   DE              string-addr, must be 0-terminated
; out:  DE              DE is advanced according to the length of the string
;       HL, BC          (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        call    osPrintStrZ

        ; fallthrough
        ; ...

osPrintCRLF:
;===============================================================================
; print a newline!
;
; out:  BC, DE, HL      (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      A,      ASCII_CR
        call    osPrintChar
        ld      A,      ASCII_LF

        ; fallthrough
        ; ...

osPrintChar:
;===============================================================================
; prints a single ASCII character:
;
; in:   A               input character
; out:  A, BC|DE|HL     (preserved)
;-------------------------------------------------------------------------------
        exx                             ; swap to shadow registers

        ld      C',     BDOS_CONOUT     ; = BDOS function to call
        ld      E',     A               ; = character to print
        ld      L',     A               ; CP/M convention means that
        call    BDOS                    ;  on BDOS return, A = L

        exx                             ; restore register set
        ret


osPrintStrZ:
;===============================================================================
; print a null-terminated string:
;
; in:   DE              string-addr, must be 0-terminated
; out:  DE              DE is advanced according to the length of the string
;       A               zero, by nature of the null-terminator
;       HL, BC          (preserved)
;-------------------------------------------------------------------------------
-       ld      A,      [DE]            ; read a character
        and     A                       ; (set CPU flags!)
        inc     DE                      ; (go to next char, does not set zf!)
        ret     z                       ; return after null-terminator
        exx                             ; swap to shadow registers

        ld      E',     A               ; BDOS param for character
        ld      C',     BDOS_CONIO      ; BDOS function to use
        call    BDOS                    ; print character!

        exx                             ; return to normal registers
        jr      -                       ; keep looping until null-terminator


;osPrintBStr:
;===============================================================================
; print a length-prefixed string:
;
; in:   DE              string-addr, first byte is length in bytes, 1-based
; out:  DE              DE is advanced according to the length of the string
;       HL              (preserved)
;       A, BC           (clobbered)
;-------------------------------------------------------------------------------
;        push    HL                      ; preserve HL coming in
;        ld      A,      [DE]            ; read string-length
;        ld      B,      A               ; use as counter
;        ;----------------------------------------------------------------------
;-       inc     DE                      ; (move to next byte)
;        ld      A,      [DE]            ; read a character
;        exx                             ; swap to shadow registers
;
;        ld      E',     A               ; BDOS param for character
;        ld      C',     BDOS_CONIO      ; BDOS function to use
;        call    BDOS                    ; print character!
;
;        exx                             ; return to normal registers
;        djnz    -                       ; loop string length
;        ;----------------------------------------------------------------------
;        inc     DE                      ; (step over last byte)
;        pop     HL                      ; restore original HL
;        ret
;
.ENDB