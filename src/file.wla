; v80, (C) Kroc Camen 2023-2024, MIT License
; file input / ouput routines
;
.block  "code-file"

; the name of each file needs to be kept in case of error. a deferred
; expression could error long after a file has been closed and another opened.
; each file name is stored as a symbol on the heap and its addr is used as a
; reference. this avoids duplicating names for files included multiple times
;
file:   .ADDR $0000                     ; addr of current file-name
files:  .ADDR $0000                     ; dictionary entry point for file-names
filename:
        .BYTE "            ", 0         ; current file-name (8.3)


parseFile:
;===============================================================================
; opens a file and assembles it:
;
; in:   [word]          file-name must be present in the word-buffer
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ; check if this file name is already known:
        ;
        ; if an include file is used many times (like a macro), we don't
        ; want the heap bloated with repeated instances of the same filename
        ;
        ld      DE,     files           ; use the files dictionary
        call    findSymbol              ; search for file-name in word-buffer
        jr      nz,     +               ; if found, don't need to add

        ; add the file-name to the heap:
        ;-----------------------------------------------------------------------
        ; link this file-name to the previous one:
        ;
        ld      DE,     [files]         ; read prev addr in files dictionary
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev file-name addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev file-name addr lo-byte
        ld      [files],HL              ; update entry point with heap addr

        ; this address is what will be used to uniquely identify the file,
        ; it has to be returned below in BC to match `findSymbol`
        push    HL

        ; copy the file-name to the heap:
        ; note that BC is set to the file-name length by `findSymbol`
        ;
        ld      DE,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex      DE,     HL              ; swap back to heap in HL
        inc     HL                      ; fix heap addr after LDDR copy

        pop     BC                      ; retrieve the file-name record addr

        ; open the file:
        ;-----------------------------------------------------------------------
+       ld      [file], BC              ; set the current file-name addr

        ; copy the backwards string file-name from the parser,
        ; into the file-name field (forwards)
        ;
        ; TODO: if osFileOpen supported backwards heap strings
        ;       we could do without this, but is that wise to do?
        ;
        ld      DE,     [word]          ; copy from the word-buffer
        push    HL                      ; preserve heap-addr
        ex      DE,     HL              ; swap DE parameter to HL
        ld      B,      [HL]            ; first byte is word-length
        ld      DE,     filename        ; where to copy the file-name
        ;-----------------------------------------------------------------------
-       dec     L                       ; move to next char in word-buffer
        ld      A,      [HL]            ; read char from word-buffer
        ld      [DE],   A               ; write to forward file-name
        inc     DE                      ; move to next char in file-name
        djnz    -                       ; copy all chars this way
        ;-----------------------------------------------------------------------
        xor     A                       ; set A to zero
        ld      [DE],   A               ; add null terminator
        pop     HL                      ; restore heap-addr

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ;ld      A,      [filenum]
        ;call    printHexByte
        ;ld      A,      ':'
        ;call    osPrintChar
        ld      DE,     filename
        call    osPrintStrZ
        ld      A,      ':'
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ld      DE,     filename        ; return to start of string
        call    osFileOpen              ; switch to new file
        call    assemble                ; assemble its contents
        jp      osFileClose             ; close the file


readChar:
;===============================================================================
; reads the next character in the file:
; current row and column are maintained
;
; out:  A               ASCII code. 0 = end-of-file
;       zf              zero-flag is set *both* for end-of-file and newline!
;       [char]          the character is also written to RAM
;       BC, DE, HL      (preserved)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ;push    AF
        ;call    osPrintChar             ; print each character as we receive it
        ;pop     AF                      ; (zero-flag must be preserved)
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        ret     z                       ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      z,      @row            ; handle newline
        cp      ASCII_TAB               ; /t is tab
        jr      z,      @tab            ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; WARN: we do not cap the column number -- keep lines to 80 cols!
        ;       when a line exceeds 255 chars, the 256th character will
        ;       be treated as end-of-file!
        ;
@col:   inc     [HL']
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
@row:   ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
@tab:   dec     A                       ; \t = 9, so change to 8 (width of tab)
        add     [HL']                   ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        ld      [HL'],  A               ; update column number
        ld      A,      ASCII_SPC       ; return a single space instead
        ld      [char], A               ; update retained value to match

        exx                             ; restore HL/DE
        ret

.endb