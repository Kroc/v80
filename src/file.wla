; v80, (C) Kroc Camen 2023-2024, MIT License
; file input / output
;
; NOTE: these two bytes are specifically grouped together because they
;       are required by deferred expressions written to the heap,
;       and are pushed together as a single word
filenum_col:
filenum:.BYTE $00                       ; current file number
col:    .BYTE $00                       ; current column-number in file
row:    .WORD $0000                     ; current line-number in file

readChar:
;===============================================================================
; reads the next character in the file:
; current row and column are maintained
;
; out:  A               ASCII code. 0 = end-of-file
;       zf              zero-flag is set *both* for end-of-file and newline!
;       [char]          the character is also written to RAM
;       DE, HL          (preserved)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ;push    AF
        ;call    osPrintChar             ; print each character as we receive it
        ;pop     AF                      ; (zero-flag must be preserved)
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        ret     z                       ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      z,      @row            ; handle newline
        cp      ASCII_TAB               ; /t is tab
        jr      z,      @tab            ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; WARN: we do not cap the column number -- keep lines to 80 cols!
        ;       when a line exceeds 255 chars, the 256th character will
        ;       be treated as end-of-file!
        ;
@col:   inc     [HL']
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
@row:   ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
@tab:   dec     A                       ; \t = 9, so change to 8 (width of tab)
        add     [HL']                   ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        ld      [HL'],  A               ; update column number
        ld      A,      ASCII_SPC       ; return a single space instead
        ld      [char], A               ; update retained value to match

        exx                             ; restore HL/DE
        ret