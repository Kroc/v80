; v80, (C) Kroc Camen 2023-2024, MIT License
; z80 parsing / opcode tree

.BLOCK  "code-parser"

parseInstruction:
;===============================================================================
; parse a Z80 instruction into opcodes:
;
; in:   A               first character of word to parse
;       HL              heap addr
; out:  HL              heap addr is advanced for any expressions deferred
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ex      DE,     HL              ; swap heap to DE for now
        ld      HL,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch:
        ;-----------------------------------------------------------------------
        ; once a character matches, the next two bytes are either
        ; an offset to the next branch to follow, or an opcode pair
        ;
@match: inc     HL                      ; step over the matched character
        ld      C,      [HL]            ; read the offset lo-byte / opcode-byte
        inc     HL                      ; move to next byte in tree
        ld      B,      [HL]            ; read the offset hi-byte / opcode-flags

        bit     7,      B               ; is hi-bit of hi-byte set?
        jr      nz,     @opcode         ; if so, this is an opcode

        ; add the offset to the current position to jump to the new branch:
        ; NOTE: the offset in the binary tree is reduced by 1 to compensate
        ; for adding from the hi-byte addr, rather than the lo-byte addr
        ;
        add     HL,     BC

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    readChar                ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting
        ; numbers / [most] punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}"",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
       
+       ; compare with opcode tree:
        ;-----------------------------------------------------------------------
-       
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
;;        push    AF
;;        ld      A,      [HL]
;;        and     %01111111
;;        call    osPrintChar
;;        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        cp      [HL]                    ; compare input char with tree char
        jr      z,      @match          ; characters match?

        ; if the hi-bit of the character from the opcode tree is set, it's
        ; either a continuation character (>128) or the end of a branch (=128).
        ; in these cases, the result of the compare will always be negative!
        ;
        bit     7,      [HL]            ; check bit 7 of character
        jr      nz,     @cont           ; handle continuation char / end

        ; no match; try the next character:
        ;-----------------------------------------------------------------------
        inc     HL
        inc     HL
        inc     HL
        jr      -

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch -- one character has to
        ; immediately follow another -- any mismatch is an unknown opcode
        ;
@cont:  or      %10000000               ; *add* top bit to input char
        cp      [HL]                    ; redo comparison with tree
        jp      nz,     errOpcode       ; any mismatch is an error!
        inc     HL                      ; match -- move to next char in tree
        jr      @char

        ;=======================================================================
        ; emit opcode(s):
        ;=======================================================================
        ; if a branch ends in an opcode, then no more characters must follow!
        ;
@opcode and     A                       ; if the last char is already 0,
        jr      z,     +                ; then no further check is needed

        call    readChar
        cp      ASCII_SPC+1             ; is it whitespace (or eof)?
        jp      nc,     errOpcode       ; if not, invalid instruction!

+       ld      HL,     [code]          ; retrieve code-segment address

        ; the flags byte is a set of flags for Z80-specifics
        ; and what, if any, kind of parameter is required
        ;-----------------------------------------------------------------------
        ld      A,      B               ; opcode flags byte
        and     %01111111               ; remove the top bit
        jr      nz,     +               ; if 0, no extension or params

        ld      [HL],   C               ; emit opcode byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        ex      DE,     HL              ; swap heap to HL, code to DE

        ret

        ;-----------------------------------------------------------------------
        ; opcode with extensions or parameters:
        ;
+       bit     6,      B               ; bit 6 indicates IX or IY
        jr      nz,     @ixy            ; go handle IX|IY madness...

        ; is it a $CB or $ED extended opcode?
        ;
        bit     4,      B               ; bit 4 indicates an extended opcode
        jr      z,      +               ; not extended? skip over $CB/$ED

        ; output $CB or $ED opcode extension byte:
        ;
        and     %00100010               ; bit 5&1 = $22 ($ED) or $00 ($CB)
        add     $cb                     ; $CB+$00 = $CB or $CB+$22 = $ED
        ld      [HL],   A               ; emit $CB|$ED prefix byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ; at this point, all parameters (if any) follow the opcode,
        ; so we can output the opcode now and forget it
        ;-----------------------------------------------------------------------
+       ld      [HL],   C               ; emit opcode byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        ex      DE,     HL              ; swap heap to HL, code to DE
        ;-----------------------------------------------------------------------

        ; any parameters?
        ;
        ; bit 2 indicates any kind of parameter for non IX|IY opcodes,
        ; i.e. 8 / 16 bit immediate, or relative (bit 3). there are no
        ; 2-parameter Z80 opcodes without IX|IY so 1 param can be assumed
        ;
        ; TODO: is this true for relative jumps?
        ;
        bit     2,      B               ; if no parameters, extensions
        ret     z                       ;  have been done, finish now!

        ; a single, 1 or 2 byte parameter:
        ; TODO: where to handle relative jump?
        ;
@stride xor     A                       ; set A to zero
        rrc     B                       ; pop bit 0 off of opcode-flags
        adc     1                       ; add that bit, if present
        ld      [stride],       A       ; set width of parameter

        ; consume whitespace before parsing expression, since the parameter
        ; is required, this will error on newline or end-of-file before expr
        jp      skipToParseExpr

        ;=======================================================================
        ; handle IX|IY opcodes: (bit 5 chooses between IX & IY)
        ;
@ixy:   and     %00100000               ; isolate bit 5
        or      %11011101               ; map to $DD (IX) or $FD (IY)
        ld      [HL],   A               ; emit IX|IY prefix byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ; on the Z80, a combination of $DD|$FB (IX|IY) + $CB opcodes place
        ; the opcode after the offset parameter! if this is the case, we
        ; have to insert the parameter first, then return for the opcode
        ;
        bit     4,      B               ; bit 4 on indicates $CB-extended
        jr      nz,     @cb             ; go handle reverse parameter order

        ; at this point, all parameters (if any) follow the opcode,
        ; so we can output the opcode now and forget it
        ;-----------------------------------------------------------------------
        ld      [HL],   C               ; emit opcode byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        ex      DE,     HL              ; swap heap to HL, code to DE
        ;-----------------------------------------------------------------------

        ; bit 3 (offset), bit 2 (8-bit immediate), and
        ; bit 0 (16-bit immediate) indicate parameters
        ;
        ld      A,      B               ; opcode flags byte
        and     %00001101               ; filter out parameter flags
        ret     z                       ; if none, we are finished

        ; there are only two Z80 instructions that use 2 parameters
        ; -- LD [IX+$aa], $bb and the matching IY-variant
        ;
        xor     %00001100               ; flip just the bits for 2 params
        jr      z,      @two            ; divert for 2 params!

        ; only one parameter
        ; -- determine parameter width (byte or word)
        ;
        xor     A                       ; set A to zero
        rrc     B                       ; pop off bit 0 of opcode-flags
        adc     1                       ; add that bit, if present
        ld      [stride],       A       ; set width of parameter

        ; consume whitespace before parsing expression, since the parameter
        ; is required, this will error on newline or end-of-file before expr
        jp      skipToParseExpr

        ;-----------------------------------------------------------------------
        ; handle two-parameter instruction special case:
        ;
@two:   inc     A
        ld      [stride],       A       ; (set the parameter width to 1 byte)

        ; TODO: must indicate offset vs. immediate parameter type somehow

        ; consume whitespace before parsing expression, since the parameter
        ; is required, this will error on newline or end-of-file before expr
        call    skipToParseExpr

        ; the first expression will read to the first character of the next
        ; word following the expression, or a newline / end-of-file. since
        ; a 2nd parameter is expected, newline or end-of-file is an error!
        ;
        ld      A,      [char]          ; last read character
        and     A                       ; (set CPU flags!)
        jp      z,      errParam        ; hard error if end-of-file!
        cp      ASCII_LF                ; newline?
        jp      z,      errParam        ; hard error if newline!

        ; (the first character of the next expression
        ;  has been read so no need to skip whitespace)
        jp      parseExpr

        ;-----------------------------------------------------------------------
        ; IX|IY + $CB is the edge-case that keeps on giving: at all other
        ; times the IX|IY offset byte follows the opcode, but not here!
        ;
@cb:    ld      [HL],   $cb             ; emit $CB prefix byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        ex      DE,     HL              ; swap heap back to HL

        ; TODO: i hate everything about this
        push    BC                      ; keep opcode until emit time

        ; consume whitespace before parsing expression, since the parameter
        ; is required, this will error on newline or end-of-file before expr
        call    skipToParseExpr

        pop     BC
        ld      A,      C
        ld      [DE],   A
        ret

.ENDB

; Z80 opcode table:
;===============================================================================
; types of opcodes:
;
;             op                ; implied
;    ED       op                ; implied, ED-extended
;       CB    op                ; implied, CB-extended
;             op nn             ; immediate, 8-bit
;             op nn nn          ; immediate, 16-bit
;    ED       op nn nn          ; immedaite, 16-bit, ED-extended
;             op rr             ; immediate, relative
; DD|FD       op                ; IXY implied
; DD|FD       op oo             ; IXY offset
; DD|FD CB oo op                ; IXY offset, CB-extended
; DD|FD       op oo nn          ; IXY offset, immediate -- 2 parameters!
; DD|FD       op nn nn          ; IXY implied, immedaite, 16-bit
;
; opcode flags byte:
;-------------------------------------------------------------------------------
; the opcode tree indicates the end of a branch with an opcode-flags byte
; that describes the opcode prefixes and parameters used:
;
; bit 7 is always set as that indicates an opcode, rather than a branch
;
; bit 6 on indicates that the opcode is IX ($DD) or IY ($FD) extended
;
; bit 5 is used to select between extensions; if bit 6 is on,
;       then bit 5 off chooses IX, and bit 5 on chooses IY
;
; bit 4 on indicates a $CB (or $ED) extension. if bit 6 is off (no IX|Y),
;       then bits 5 & 1 on ($22) indicates an $ED extensions, otherwise
;       bits 5 & 1 are off ($22). bits 5 & 1 are combined this way because
;       $CB + $22 = $ED
;
; bit 3 on indicates an offset is present. if bit 6 is on, then this is the
;       IX|IY offset byte. if bit 6 is off, then this indicates a relative
;       jump offset (e.g. JR / DJNZ)
;
; bit 2 on indicates an immediate parameter. this is separate from
;       the offset parameter above as there can be two parameters!
;
; bit 1 is on for $ED extended opcodes
;
; bit 0 on indicates an immediate parameter is 16-bits instead of 8,
;       this is always paired with bit 2, both must be on to be valid
;
OP      = %10000000     ; indicates an opcode
OP_I    = %11000000     ; bit 6=1: IX or IY extended
OP_X    = %11000000     ; bit 6=1, bit 5=0: IX
OP_Y    = %11100000     ; bit 6=1, bit 5=1: IY
OP_IX   = OP_I|OP_X
OP_IY   = OP_I|OP_Y
OP_CB   = %10010000     ; bit 6=?, bit 4=1, bit 5&1=0: CB-extended (+/-IX|IY)
OP_ED   = %10110010     ; bit 6=0, bit 4=1, bit 5&1=1: ED-extended
OP_O    = %11001000     ; bit 6=1, bit 3=1, bit 2=?: IX|IY includes offset
OP_IXO  = OP_IX|OP_O
OP_IYO  = OP_IY|OP_O
OP_R    = %10001100     ; bit 6=0, bit 3=1, bit 2=1: relative jump offset
OP_B    = %10000100     ; bit 2=1: immediate parameter, 8-bits (byte)
OP_W    = %10000101     ; bit 2=1, bit 0=1: immediate parameter, 16-bits (word)

OP_IMP  = OP            ; implied -- no parameter
OP_IMPC = OP_CB         ; implied, extended ($CB)
OP_IMPE = OP_ED         ; implied, extended ($ED)
OP_IMPX = OP_IX         ; implied, IX ($DD)
OP_IMPY = OP_IY         ; implied, IY ($FD)
OP_IMMX = OP_IXO        ; implied, IX ($DD) + offset
OP_IMMY = OP_IYO        ; implied, IY ($FD) + offset
OP_IMMB = OP_B          ; immediate, 8-bit
OP_IMMR = OP_B|OP_R     ; relative, 8-bit
OP_IMCX = OP_IX|OP_CB   ; extended ($CB), IX ($DD) + offset
OP_IMCY = OP_IY|OP_CB   ; extended ($CB), IY ($FD) + offset
OP_IMXB = OP_B|OP_IXO   ; IX ($DD) + offset + immediate (2 parameters!)
OP_IMYB = OP_B|OP_IYO   ; IY ($FD) + offset + immediate (2 parameters!)
OP_IMMW = OP_W          ; immediate, 16-bit
OP_IMEW = OP_W|OP_ED    ; immediate, extended ($ED), 16-bit!
OP_IMXW = OP_W|OP_IX    ; immediate, IX ($DD), 16-bit
OP_IMYW = OP_W|OP_IY    ; immediate, IY ($FD), 16-bit

opcodes:
;===============================================================================
.BLOCK  "opcodes"
        AND     = 128
        END     = 0
        ERR     = $ff

        REG_A   = 7
        REG_B   = 0
        REG_C   = 1
        REG_D   = 2
        REG_E   = 3
        REG_H   = 4
        REG_L   = 5

        REG_IH  = 4
        REG_IL  = 5

        .TABLE  BYTE,WORD
        ;-----------------------------------------------------------------------
        .DATA   'a', (@a-CADDR)-1               ; = A...?
        .DATA   'b', (@b-CADDR)-1               ; = B...?
        .DATA   'c', (@c-CADDR)-1               ; = C...?
        .DATA   'd', (@d-CADDR)-1               ; = D...?
        .DATA   'e', (@e-CADDR)-1               ; = E...?
        .DATA   'h', (@h-CADDR)-1               ; = H...?
        .DATA   'i', (@i-CADDR)-1               ; = I...?
        .DATA   'j', (@j-CADDR)-1               ; = J...?
        .DATA   'l', (@l-CADDR)-1               ; = L...?
        ; ...
        .BYTE   ERR
        ;=======================================================================
@a      .DATA   'd', (@ad-CADDR)-1
        .BYTE   'n'|AND
        .DATA   'd', (@and-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ad     .DATA   'c', (@adc-CADDR)-1
        .DATA   'd', (@add-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc    .BYTE   END, $ce,               OP_IMMB ; ADC $nn       |       CE nn
        .DATA   '.', (@adc_r-CADDR)-1
        .DATA   '*', (@adc_m-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_r  .BYTE   'a', $88+REG_A,         OP_IMP  ; ADC.A         |       8F
        .BYTE   'b', $88+REG_B,         OP_IMP  ; ADC.B         |       88
        .BYTE   'c', $88+REG_C,         OP_IMP  ; ADC.C         |       89
        .BYTE   'd', $88+REG_D,         OP_IMP  ; ADC.D         |       8A
        .BYTE   'e', $88+REG_E,         OP_IMP  ; ADC.E         |       8B
        .DATA   'h', (@adc_h-CADDR)-1
        .BYTE   'l', $88+REG_L,         OP_IMP  ; ADC.L         |       8D
        .BYTE   'i'|AND
        .DATA   'x', (@adc_x-CADDR)-1
        .BYTE   'y'|AND
        .BYTE   'h', $88+REG_IH,        OP_IMPY ; ADC.IYH       |    FD 8C
        .BYTE   'l', $88+REG_IL,        OP_IMPY ; ADC.IYL       |    FD 8D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_x  .BYTE   'h', $88+REG_IH,        OP_IMPX ; ADC.IXH       |    DD 8C
        .BYTE   'l', $88+REG_IL,        OP_IMPX ; ADC.IXL       |    DD 8D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_h  .BYTE   END, $88+REG_H,         OP_IMP  ; ADC.H         |       8C
        .BYTE   'l'|AND,
        .BYTE   '+'|AND
        .DATA   'b', (@adc_bc-CADDR)-1
        .DATA   'd', (@adc_de-CADDR)-1
        .DATA   'h', (@adc_hl-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $7a,               OP_IMPE ; ADC.HL+SP     |    ED 7A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_bc .BYTE   'c', $4a,               OP_IMPE ; ADC.HL+BC     |    ED 4A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_de .BYTE   'e', $5a,               OP_IMPE ; ADC.HL+DE     |    ED 5A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_hl .BYTE   'l', $6a,               OP_IMPE ; ADC.HL+HL     |    ED 6A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_m  .DATA   'h', (@adc_mh-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $8e,               OP_IMMX ; ADC*IX $nn    |    DD 8E nn
        .BYTE   'y', $8e,               OP_IMMY ; ADC*IY $nn    |    FD 8E nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@adc_mh .BYTE   'l', $8e,               OP_IMP  ; ADC*HL        |       8E
        .BYTE   ERR
        ;=======================================================================
@add    .BYTE   END, $c6,               OP_IMMB ; ADD $nn       |       C6 nn
        .DATA   '*', (@add_m-CADDR)-1
        .DATA   '.', (@add_r-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_m  .DATA   'h', (@add_mh-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $86,               OP_IMMX ; ADD*IX $nn    |    DD 86 nn
        .BYTE   'y', $86,               OP_IMMY ; ADD*IY $nn    |    FD 86 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_mh .BYTE   'l', $86,               OP_IMP  ; ADD*HL        |       86
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_r  .BYTE   'a', $80+REG_A,         OP_IMP  ; ADD.A         |       87
        .BYTE   'b', $80+REG_B,         OP_IMP  ; ADD.B         |       80
        .BYTE   'c', $80+REG_C,         OP_IMP  ; ADD.C         |       81
        .BYTE   'd', $80+REG_D,         OP_IMP  ; ADD.D         |       82
        .BYTE   'e', $80+REG_E,         OP_IMP  ; ADD.E         |       83
        .DATA   'h', (@add_h-CADDR)-1
        .BYTE   'l', $80+REG_L,         OP_IMP  ; ADD.L         |       85
        .BYTE   'i'|AND
        .DATA   'x', (@add_x-CADDR)-1
        .BYTE   'y'|AND
        .BYTE   'h', $80+REG_IH,        OP_IMPY ; ADD.IYH       |    FD 84
        .BYTE   'l', $80+REG_IL,        OP_IMPY ; ADD.IYL       |    FD 84
        .BYTE   '+'|AND
        .DATA   'b', (@add_yb-CADDR)-1
        .DATA   'd', (@add_yd-CADDR)-1
        .DATA   'i', (@add_yi-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $39,               OP_IMPY ; ADD.IY+SP     |    FD 39
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_yb .BYTE   'c', $09,               OP_IMPY ; ADD.IY+BC     |    FD 09
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_yd .BYTE   'e', $19,               OP_IMPY ; ADD.IY+DE     |    FD 19
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_yi .BYTE   'y', $29,               OP_IMPY ; ADD.IY+IY     |    FD 29
        .BYTE   ERR
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_x  .BYTE   'h', $80+REG_IH,        OP_IMPX ; ADD.IXH       |    DD 84
        .BYTE   'l', $80+REG_IL,        OP_IMPX ; ADD.IXL       |    DD 84
        .BYTE   '+'|AND
        .DATA   'b', (@add_xb-CADDR)-1
        .DATA   'd', (@add_xd-CADDR)-1
        .DATA   'i', (@add_xi-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $39,               OP_IMPX ; ADD.IX+SP     |    DD 39
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_xb .BYTE   'c', $09,               OP_IMPX ; ADD.IX+BC     |    DD 09
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_xd .BYTE   'e', $19,               OP_IMPX ; ADD.IX+DE     |    DD 19
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_xi .BYTE   'x', $29,               OP_IMPX ; ADD.IX+IX     |    DD 29
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_h  .BYTE   END, $80+REG_H,         OP_IMP  ; ADD.H         |       84
        .BYTE   'l'|AND
        .BYTE   '+'|AND
        .DATA   'b', (@add_bc-CADDR)-1
        .DATA   'd', (@add_de-CADDR)-1
        .DATA   'h', (@add_hl-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $39,               OP_IMP  ; ADD.HL+SP     |       39
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_bc .BYTE   'c', $09,               OP_IMP  ; ADD.HL+BC     |       09
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_de .BYTE   'e', $19,               OP_IMP  ; ADD.HL+DE     |       19
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@add_hl .BYTE   'l', $29,               OP_IMP  ; ADD.HL+HL     |       29
        .BYTE   ERR
        ;=======================================================================
@and    .BYTE   END, $e6,               OP_IMMB ; AND $nn       |       E6 nn
        .DATA   '*', (@and_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $a0+REG_A,         OP_IMP  ; AND.A         |       A7
        .BYTE   'b', $a0+REG_B,         OP_IMP  ; AND.B         |       A0
        .BYTE   'c', $a0+REG_C,         OP_IMP  ; AND.C         |       A1
        .BYTE   'd', $a0+REG_D,         OP_IMP  ; AND.D         |       A2
        .BYTE   'e', $a0+REG_E,         OP_IMP  ; AND.E         |       A3
        .BYTE   'h', $a0+REG_E,         OP_IMP  ; AND.H         |       A4
        .BYTE   'l', $88+REG_L,         OP_IMP  ; AND.L         |       A5
        .DATA   'i', (@and_i-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@and_i  .DATA   'x', (@and_x-CADDR)-1
        .DATA   'y', (@and_y-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@and_x  .BYTE   'h', $a0+REG_IH,        OP_IMPX ; AND.IXH       |    DD A4
        .BYTE   'l', $a0+REG_IL,        OP_IMPX ; AND.IXL       |    DD A5
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@and_y  .BYTE   'h', $a0+REG_IH,        OP_IMPY ; AND.IXH       |    FD A4
        .BYTE   'l', $a0+REG_IL,        OP_IMPY ; AND.IXL       |    FD A5
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@and_m  .DATA   'h', (@and_mh-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $a6,               OP_IMMX ; AND*IX $nn    |    DD A6 nn
        .BYTE   'y', $a6,               OP_IMMY ; AND*IY $nn    |    FD A6 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@and_mh .BYTE   'l', $a6,               OP_IMP  ; AND*HL        |       A6
        .BYTE   ERR
        ;=======================================================================
@b      .BYTE   'i'|AND
        .BYTE   't'|AND
        .DATA   '7', (@bit7-CADDR)-1
        .DATA   '6', (@bit6-CADDR)-1
        .DATA   '5', (@bit5-CADDR)-1
        .DATA   '4', (@bit4-CADDR)-1
        .DATA   '3', (@bit3-CADDR)-1
        .DATA   '2', (@bit2-CADDR)-1
        .DATA   '1', (@bit1-CADDR)-1
        .BYTE   '0'|AND
        .DATA   '*', (@bit0m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*0)+REG_A,   OP_IMPC ; BIT0.A        |    CB 47
        .BYTE   'b', $40+(8*0)+REG_B,   OP_IMPC ; BIT0.B        |    CB 40
        .BYTE   'c', $40+(8*0)+REG_C,   OP_IMPC ; BIT0.C        |    CB 41
        .BYTE   'd', $40+(8*0)+REG_D,   OP_IMPC ; BIT0.D        |    CB 42
        .BYTE   'e', $40+(8*0)+REG_E,   OP_IMPC ; BIT0.E        |    CB 43
        .BYTE   'h', $40+(8*0)+REG_H,   OP_IMPC ; BIT0.H        |    CB 44
        .BYTE   'l', $40+(8*0)+REG_L,   OP_IMPC ; BIT0.L        |    CB 45
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit0m  .DATA   'h', (@bit0hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*0),         OP_IMCX ; BIT0*IX $nn   | DD CB nn 46
        .BYTE   'y', $46+(8*0),         OP_IMCY ; BIT0*IY $nn   | FD CB nn 46
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit0hl .BYTE   'l', $46+(8*0),         OP_IMPC ; BIT0*HL       |    CB 46
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit1   .DATA   '*', (@bit1m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*1)+REG_A    OP_IMPC ; BIT1.A        |    CB 4F
        .BYTE   'b', $40+(8*1)+REG_B    OP_IMPC ; BIT1.B        |    CB 48
        .BYTE   'c', $40+(8*1)+REG_C    OP_IMPC ; BIT1.C        |    CB 49
        .BYTE   'd', $40+(8*1)+REG_D    OP_IMPC ; BIT1.D        |    CB 4A
        .BYTE   'e', $40+(8*1)+REG_E    OP_IMPC ; BIT1.E        |    CB 4B
        .BYTE   'h', $40+(8*1)+REG_H    OP_IMPC ; BIT1.H        |    CB 4C
        .BYTE   'l', $40+(8*1)+REG_L    OP_IMPC ; BIT1.L        |    CB 4D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit1m  .DATA   'h', (@bit1hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*1),         OP_IMCX ; BIT1*IX $nn   | DD CB nn 4E
        .BYTE   'y', $46+(8*1),         OP_IMCY ; BIT1*IY $nn   | FD CB nn 4E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit1hl .BYTE   'l', $46+(8*1),         OP_IMPC ; BIT1*HL       |    CB 4E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit2   .DATA   '*', (@bit2m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*2)+REG_A,   OP_IMPC ; BIT2.A        |    CB 57
        .BYTE   'b', $40+(8*2)+REG_B,   OP_IMPC ; BIT2.B        |    CB 50
        .BYTE   'c', $40+(8*2)+REG_C,   OP_IMPC ; BIT2.C        |    CB 51
        .BYTE   'd', $40+(8*2)+REG_D,   OP_IMPC ; BIT2.D        |    CB 52
        .BYTE   'e', $40+(8*2)+REG_E,   OP_IMPC ; BIT2.E        |    CB 53
        .BYTE   'h', $40+(8*2)+REG_H,   OP_IMPC ; BIT2.H        |    CB 54
        .BYTE   'l', $40+(8*2)+REG_L,   OP_IMPC ; BIT2.L        |    CB 55
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit2m  .DATA   'h', (@bit2hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*2),         OP_IMCX ; BIT2*IX $nn   | DD CB nn 56
        .BYTE   'y', $46+(8*2),         OP_IMCY ; BIT2*IY $nn   | FD CB nn 56
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit2hl .BYTE   'l', $46+(8*2),         OP_IMPC ; BIT2*HL       |    CB 56
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit3   .DATA   '*', (@bit3m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*3)+REG_A,   OP_IMPC ; BIT3.A        |    CB 5F
        .BYTE   'b', $40+(8*3)+REG_B,   OP_IMPC ; BIT3.B        |    CB 58
        .BYTE   'c', $40+(8*3)+REG_C,   OP_IMPC ; BIT3.C        |    CB 59
        .BYTE   'd', $40+(8*3)+REG_D,   OP_IMPC ; BIT3.D        |    CB 5A
        .BYTE   'e', $40+(8*3)+REG_E,   OP_IMPC ; BIT3.E        |    CB 5B
        .BYTE   'h', $40+(8*3)+REG_H,   OP_IMPC ; BIT3.H        |    CB 5C
        .BYTE   'l', $40+(8*3)+REG_L,   OP_IMPC ; BIT3.L        |    CB 5D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit3m  .DATA   'h', (@bit3hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*3),         OP_IMCX ; BIT3*IX $nn   | DD CB nn 5E
        .BYTE   'y', $46+(8*3),         OP_IMCY ; BIT3*IY $nn   | FD CB nn 5E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit3hl .BYTE   'l', $46+(8*3),         OP_IMPC ; BIT3*HL       |    CB 5E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit4   .DATA   '*', (@bit4m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*4)+REG_A,   OP_IMPC ; BIT4.A        |    CB 67
        .BYTE   'b', $40+(8*4)+REG_B,   OP_IMPC ; BIT4.B        |    CB 60
        .BYTE   'c', $40+(8*4)+REG_C,   OP_IMPC ; BIT4.C        |    CB 61
        .BYTE   'd', $40+(8*4)+REG_D,   OP_IMPC ; BIT4.D        |    CB 62
        .BYTE   'e', $40+(8*4)+REG_E,   OP_IMPC ; BIT4.E        |    CB 63
        .BYTE   'h', $40+(8*4)+REG_H,   OP_IMPC ; BIT4.H        |    CB 64
        .BYTE   'l', $40+(8*4)+REG_L,   OP_IMPC ; BIT4.L        |    CB 65
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit4m  .DATA   'h', (@bit4hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*4),         OP_IMCX ; BIT4*IX $nn   | DD CB nn 66
        .BYTE   'y', $46+(8*4),         OP_IMCY ; BIT4*IY $nn   | FD CB nn 66
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit4hl .BYTE   'l', $46+(8*4),         OP_IMPC ; BIT4*HL       |    CB 66
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit5   .DATA   '*', (@bit5m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*5)+REG_A,   OP_IMPC ; BIT5.A        |    CB 6F
        .BYTE   'b', $40+(8*5)+REG_B,   OP_IMPC ; BIT5.B        |    CB 68
        .BYTE   'c', $40+(8*5)+REG_C,   OP_IMPC ; BIT5.C        |    CB 69
        .BYTE   'd', $40+(8*5)+REG_D,   OP_IMPC ; BIT5.D        |    CB 6A
        .BYTE   'e', $40+(8*5)+REG_E,   OP_IMPC ; BIT5.E        |    CB 6B
        .BYTE   'h', $40+(8*5)+REG_H,   OP_IMPC ; BIT5.H        |    CB 6C
        .BYTE   'l', $40+(8*5)+REG_L,   OP_IMPC ; BIT5.L        |    CB 6D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit5m  .DATA   'h', (@bit5hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*5),         OP_IMCX ; BIT5*IX $nn   | DD CB nn 6E
        .BYTE   'y', $46+(8*5),         OP_IMCY ; BIT5*IY $nn   | FD CB nn 6E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit5hl .BYTE   'l', $46+(8*5),         OP_IMPC ; BIT5*HL       |    CB 6E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit6   .DATA   '*', (@bit6m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*6)+REG_A,   OP_IMPC ; BIT6.A        |    CB 77
        .BYTE   'b', $40+(8*6)+REG_B,   OP_IMPC ; BIT6.B        |    CB 70
        .BYTE   'c', $40+(8*6)+REG_C,   OP_IMPC ; BIT6.C        |    CB 71
        .BYTE   'd', $40+(8*6)+REG_D,   OP_IMPC ; BIT6.D        |    CB 72
        .BYTE   'e', $40+(8*6)+REG_E,   OP_IMPC ; BIT6.E        |    CB 73
        .BYTE   'h', $40+(8*6)+REG_H,   OP_IMPC ; BIT6.H        |    CB 74
        .BYTE   'l', $40+(8*6)+REG_L,   OP_IMPC ; BIT6.L        |    CB 75
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit6m  .DATA   'h', (@bit6hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*6),         OP_IMCX ; BIT6*IX $nn   | DD CB nn 76
        .BYTE   'y', $46+(8*6),         OP_IMCY ; BIT6*IY $nn   | FD CB nn 76
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit6hl .BYTE   'l', $46+(8*6),         OP_IMPC ; BIT6*HL       |    CB 76
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit7   .DATA   '*', (@bit7m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+(8*7)+REG_A,   OP_IMPC ; BIT7.A        |    CB 7F
        .BYTE   'b', $40+(8*7)+REG_B,   OP_IMPC ; BIT7.B        |    CB 78
        .BYTE   'c', $40+(8*7)+REG_C,   OP_IMPC ; BIT7.C        |    CB 79
        .BYTE   'd', $40+(8*7)+REG_D,   OP_IMPC ; BIT7.D        |    CB 7A
        .BYTE   'e', $40+(8*7)+REG_E,   OP_IMPC ; BIT7.E        |    CB 7B
        .BYTE   'h', $40+(8*7)+REG_H,   OP_IMPC ; BIT7.H        |    CB 7C
        .BYTE   'l', $40+(8*7)+REG_L,   OP_IMPC ; BIT7.L        |    CB 7D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit7m  .DATA   'h', (@bit7hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46+(8*7),         OP_IMCX ; BIT7*IX $nn   | DD CB nn 7E
        .BYTE   'y', $46+(8*7),         OP_IMCY ; BIT7*IY $nn   | FD CB nn 7E
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@bit7hl .BYTE   'l', $46+(8*7),         OP_IMPC ; BIT7*HL       |    CB 7E
        .BYTE   ERR
        ;=======================================================================
@c      .DATA   'a', (@call-CADDR)-1
        .DATA   'c', (@ccf-CADDR)-1
        .DATA   'p', (@cp-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@call   .BYTE   'l'|AND
        .BYTE   'l'|AND
        .BYTE   END, $cd,               OP_IMMW ; CALL $nnnn    |    CD nn nn
        .BYTE   '?'|AND
        .BYTE   'z', $cc,               OP_IMMW ; CALL?z $nnnn  |    CC nn nn
        .BYTE   'c', $dc,               OP_IMMW ; CALL?c $nnnn  |    DC nn nn
        .BYTE   'm', $fc,               OP_IMMW ; CALL?m $nnnn  |    FC nn nn
        .DATA   'p', (@callp-CADDR)-1
        .BYTE   'n'|AND
        .BYTE   'z', $c4,               OP_IMMW ; CALL?nz $nnnn |    C4 nn nn
        .BYTE   'c', $d4,               OP_IMMW ; CALL?nc $nnnn |    D4 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@callp  .BYTE   END, $f4,               OP_IMMW ; CALL?p $nnnn  |    F4 nn nn
        .BYTE   'o', $e4,               OP_IMMW ; CALL?po $nnnn |    E4 nn nn
        .BYTE   'e', $ec,               OP_IMMW ; CALL?pe $nnnn |    EC nn nn
        .BYTE   ERR
        ;=======================================================================
@ccf    .BYTE   'f', $3f,               OP_IMP  ; CCF           |    3F
        .BYTE   ERR
        ;=======================================================================
@cp     .BYTE   END, $fe,               OP_IMMB ; CP nn         |    FE nn
        .DATA   '*', (@cp_m-CADDR)-1
        .DATA   '.', (@cp_r-CADDR)-1
        .DATA   'd', (@cpd-CADDR)-1
        .DATA   'i', (@cpi-CADDR)-1
        .BYTE   'l', $2f,               OP_IMP  ; CPL           |    2F
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@cp_m   .DATA   'h', (@cp_mh-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $be,               OP_IMMX ; CP*IX $nn     | DD BE nn
        .BYTE   'y', $be,               OP_IMMY ; CP*IY $nn     | FD BE nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@cp_mh  .BYTE   'l', $be,               OP_IMP  ; CP*HL         |    BE
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@cp_r   .BYTE   'a', $b8+REG_A,         OP_IMP  ; CP.A          |    BF
        .BYTE   'b', $b8+REG_B,         OP_IMP  ; CP.B          |    B8
        .BYTE   'c', $b8+REG_C,         OP_IMP  ; CP.C          |    B9
        .BYTE   'd', $b8+REG_D,         OP_IMP  ; CP.D          |    BA
        .BYTE   'e', $b8+REG_E,         OP_IMP  ; CP.E          |    BB
        .BYTE   'h', $b8+REG_H,         OP_IMP  ; CP.H          |    BC
        .BYTE   'l', $b8+REG_L,         OP_IMP  ; CP.L          |    BD
        .BYTE   'i'|AND
        .DATA   'x', (@cp_ix-CADDR)-1
        .BYTE   'y'|AND
        .BYTE   'h', $b8+REG_IH,        OP_IMPY ; CP.IYH        | FD BC
        .BYTE   'l', $b8+REG_IL,        OP_IMPY ; CP.IYL        | FD BD
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@cp_ix  .BYTE   'h', $b8+REG_IH,        OP_IMPX ; CP.IXH        | DD BC
        .BYTE   'l', $b8+REG_IL,        OP_IMPX ; CP.IXL        | DD BD
        .BYTE   ERR
        ;=======================================================================
@cpd    .BYTE   END, $a9,               OP_IMPE ; CPD           | ED A9
        .BYTE   'r', $b9,               OP_IMPE ; CPDR          | ED B9
        .BYTE   ERR
        ;=======================================================================
@cpi    .BYTE   END, $a1,               OP_IMPE ; CPI           | ED A1
        .BYTE   'r', $b1,               OP_IMPE ; CPIR          | ED B1
        .BYTE   ERR
        ;=======================================================================
@d      .DATA   'a', (@da-CADDR)-1
        .DATA   'e', (@de-CADDR)-1
        .BYTE   'i', $f3,               OP_IMP  ; DI            |    F3
        .BYTE   'j'|AND
        .BYTE   'n'|AND
        .BYTE   'z', $10,               OP_IMMR ; DJNZ $nn      |    10 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@da     .BYTE   'a', $27,               OP_IMP  ; DAA           |    27
        .BYTE   ERR
        ;=======================================================================
@de     .BYTE   'c'|AND
        .DATA   '*', (@dec_m-CADDR)-1
        .DATA   '.', (@dec_r-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_m  .DATA   'h', (@dec_mh-CADDR)-1
        .DATA   'i', (@dec_mi-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_mh .BYTE   'l', $35,               OP_IMP  ; DEC*HL        |    35
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_mi .BYTE   'x', $35,               OP_IMMX ; DEC*IX $nn    | DD 35 nn
        .BYTE   'y', $35,               OP_IMMY ; DEC*IY $nn    | FD 35 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
        ; note how these opcodes don't follow the usual pattern!
@dec_r  .BYTE   'a', $3d,               OP_IMP  ; DEC.A         |    3D
        .DATA   'b', (@dec_b-CADDR)-1
        .BYTE   'c', $0d,               OP_IMP  ; DEC.C         |    0D
        .DATA   'd', (@dec_d-CADDR)-1
        .BYTE   'e', $1d,               OP_IMP  ; DEC.E         |    1D
        .DATA   'h', (@dec_h-CADDR)-1
        .BYTE   'l', $2d,               OP_IMP  ; DEC.L         |    2D
        .DATA   'i', (@dec_i-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $3b,               OP_IMP  ; DEC.SP        |    3B
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_b  .BYTE   END, $05,               OP_IMP  ; DEC.B         |    05
        .BYTE   'c', $0b,               OP_IMP  ; DEC.BC        |    0B
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_d  .BYTE   END, $15,               OP_IMP  ; DEC.D         |    15
        .BYTE   'e', $1b,               OP_IMP  ; DEC.DE        |    1B
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_h  .BYTE   END, $25,               OP_IMP  ; DEC.H         |    25
        .BYTE   'l', $2b,               OP_IMP  ; DEC.HL        |    2B
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_i  .DATA   'x', (@dec_ix-CADDR)-1
        .DATA   'y', (@dec_ix-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_ix .BYTE   END, $2b,               OP_IMPX ; DEC.IX        | DD 2B
        .BYTE   'h', $05+(8*REG_IH),    OP_IMPX ; DEC.IXH       | DD 25
        .BYTE   'l', $05+(8*REG_IL),    OP_IMPX ; DEC.IXL       | DD 2D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@dec_iy .BYTE   END, $2b,               OP_IMPY ; DEC.IX        | FD 2B
        .BYTE   'h', $05+(8*REG_IH),    OP_IMPY ; DEC.IXH       | FD 25
        .BYTE   'l', $05+(8*REG_IL),    OP_IMPY ; DEC.IXL       | FD 2D
        .BYTE   ERR
        ;=======================================================================
@e      .BYTE   'i', $fb,               OP_IMP  ; EI            |    FB
        .BYTE   'x'|AND
        .BYTE   'x', $d9,               OP_IMP  ; EXX           |    D9
        .DATA   '*', (@ex_m-CADDR)-1
        .BYTE   '.'|AND
        .DATA   'a', (@ex_af-CADDR)-1
        .BYTE   'd'|AND
        .BYTE   'e'|AND
        .BYTE   '.'|AND
        .BYTE   'h'|AND
        .BYTE   'l', $eb,               OP_IMP  ; EX.DE.HL      |    EB
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ex_af  .BYTE   'f'|AND                         ; TODO: allow shadow registers
        .BYTE   '.'|AND
        .BYTE   'a'|AND
        .BYTE   'f', $08,               OP_IMP  ; EX.AF.AF      |    08
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ex_m   .BYTE   's'|AND
        .BYTE   'p'|AND
        .BYTE   '.'|AND
        .DATA   'i', (@ex_mi-CADDR)-1
        .BYTE   'h'|AND
        .BYTE   'l', $e3,               OP_IMP  ; EX*SP.HL      |    E3
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ex_mi  .BYTE   'x', $e3,               OP_IMPX ; EX*SP.IX      | DD E3
        .BYTE   'y', $e3,               OP_IMPY ; EX*SP.IY      | FD E3
        .BYTE   ERR
        ;=======================================================================
@h      .BYTE   'a'|AND                         ; TODO: allow `hlt` / `hcf`
        .BYTE   'l'|AND
        .BYTE   't', $76,               OP_IMP  ; HALT          |    76
        .BYTE   ERR
        ;=======================================================================
@i      .DATA   'm', (@im-CADDR)-1
        .BYTE   'n'|AND
        .DATA   '.', (@in_r-CADDR)-1
        .DATA   'c', (@inc-CADDR)-1
        .DATA   'd', (@ind-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   END, $a2,               OP_IMPE ; INI           | ED A2
        .BYTE   'r', $b2,               OP_IMPE ; INIR          | ED B2
        .BYTE   ERR
        ;=======================================================================
@im     .BYTE   '0', $46,               OP_IMPE ; IM0           | ED 46
        .BYTE   '1', $56,               OP_IMPE ; IM1           | ED 56
        .BYTE   '2', $5e,               OP_IMPE ; IM2           | ED 5E
        .BYTE   ERR
        ;=======================================================================
@in_r   .DATA   'a', (@in_a-CADDR)-1
        .DATA   'b', (@in_b-CADDR)-1
        .DATA   'c', (@in_c-CADDR)-1
        .DATA   'd', (@in_d-CADDR)-1
        .DATA   'e', (@in_e-CADDR)-1
        .DATA   'h', (@in_h-CADDR)-1
        .BYTE   'l'|AND
        .BYTE   '*'|AND
        .BYTE   'c', $68,               OP_IMPE ; IN.L*C        | ED 68
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_a   .BYTE   '*'|AND
        .BYTE   END, $db,               OP_IMMB ; IN.A* $nn     |    DB nn
        .BYTE   'c', $78,               OP_IMPE ; IN.A*C        | ED 78
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_b   .BYTE   '*'|AND
        .BYTE   'c', $40,               OP_IMPE ; IN.B*C        | ED 40
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_c   .BYTE   '*'|AND
        .BYTE   'c', $48,               OP_IMPE ; IN.C*C        | ED 48
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_d   .BYTE   '*'|AND
        .BYTE   'c', $50,               OP_IMPE ; IN.D*C        | ED 50
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_e   .BYTE   '*'|AND
        .BYTE   'c', $58,               OP_IMPE ; IN.E*C        | ED 58
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@in_h   .BYTE   '*'|AND
        .BYTE   'c', $60,               OP_IMPE ; IN.H*C        | ED 60
        .BYTE   ERR
        ;=======================================================================
@inc    .DATA   '*', (@inc_m-CADDR)-1
        .DATA   '.', (@inc_r-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_m  .DATA   'h', (@inc_mh-CADDR)-1
        .DATA   'i', (@inc_mi-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_mh .BYTE   'l', $34,               OP_IMP  ; INC*HL        |    34
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_mi .BYTE   'x', $34,               OP_IMMX ; INC*IX $nn    | DD 34 nn
        .BYTE   'y', $34,               OP_IMMY ; INC*IY $nn    | FD 34 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
        ; note how these opcodes don't follow the usual pattern!
@inc_r  .BYTE   'a', $3c,               OP_IMP  ; INC.A         |    3C
        .DATA   'b', (@inc_b-CADDR)-1
        .BYTE   'c', $0c,               OP_IMP  ; INC.C         |    0C
        .DATA   'd', (@inc_d-CADDR)-1
        .BYTE   'e', $1c,               OP_IMP  ; INC.E         |    1C
        .DATA   'h', (@inc_h-CADDR)-1
        .BYTE   'l', $2c,               OP_IMP  ; INC.L         |    2C
        .DATA   'i', (@inc_i-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $33,               OP_IMP  ; INC.SP        |    33
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_b  .BYTE   END, $04,               OP_IMP  ; INC.B         |    04
        .BYTE   'c', $03,               OP_IMP  ; INC.BC        |    03
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_d  .BYTE   END, $14,               OP_IMP  ; INC.D         |    14
        .BYTE   'e', $13,               OP_IMP  ; INC.DE        |    13
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_h  .BYTE   END, $24,               OP_IMP  ; INC.H         |    24
        .BYTE   'l', $23,               OP_IMP  ; INC.HL        |    23
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_i  .DATA   'x', (@inc_ix-CADDR)-1
        .DATA   'y', (@inc_ix-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_ix .BYTE   END, $23,               OP_IMPX ; INC.IX        | DD 23
        .BYTE   'h', $04+(8*REG_IH),    OP_IMPX ; INC.IXH       | DD 24
        .BYTE   'l', $04+(8*REG_IL),    OP_IMPX ; INC.IXL       | DD 2C
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@inc_iy .BYTE   END, $23,               OP_IMPY ; INC.IX        | FD 23
        .BYTE   'h', $04+(8*REG_IH),    OP_IMPY ; INC.IXH       | FD 24
        .BYTE   'l', $04+(8*REG_IL),    OP_IMPY ; INC.IXL       | FD 2C
        .BYTE   ERR
        ;=======================================================================
@ind    .BYTE   END, $aa,               OP_IMPE ; IND           | ED AA
        .BYTE   'r', $ba,               OP_IMPE ; INDR          | ED BA
        .BYTE   ERR
        ;=======================================================================
@j      .DATA   'p', (@jp-CADDR)-1
        .BYTE   'r'|AND
        .BYTE   END, $18,               OP_IMMR ; JR $nnnn      |    18 nn
        .BYTE   '?'|AND
        .BYTE   'z', $28,               OP_IMMR ; JR?z $nnnn    |    28 nn
        .BYTE   'c', $38,               OP_IMMR ; jr?c $nnnn    |    38 nn
        .BYTE   'n'|AND
        .BYTE   'z', $20,               OP_IMMR ; jr?nz $nnnn   |    20 nn
        .BYTE   'c', $30,               OP_IMMR ; jr?nc $nnnn   |    30 nn
        .BYTE   ERR
        ;=======================================================================
@jp     .BYTE   END, $c3,               OP_IMMW ; JP $nnnn      |    C3 nn nn
        .DATA   '*', (@jp_m-CADDR)-1
        .BYTE   '?'|AND
        .BYTE   'z', $ca,               OP_IMMW ; JP?z $nnnn    |    CA nn nn
        .BYTE   'c', $da,               OP_IMMW ; JP?c $nnnn    |    DA nn nn
        .BYTE   'm', $fa,               OP_IMMW ; JP?m $nnnn    |    FA nn nn
        .DATA   'p', (@jp_p-CADDR)-1
        .BYTE   'n'|AND
        .BYTE   'z', $c2,               OP_IMMW ; JP?nz $nnnn   |    C2 nn nn
        .BYTE   'c', $d2,               OP_IMMW ; JP?nc $nnnn   |    D2 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@jp_p   .BYTE   END, $f2,               OP_IMMW ; JP?p $nnnn    |    F2 nn nn
        .BYTE   'o', $e2,               OP_IMMW ; JP?po $nnnn   |    E2 nn nn
        .BYTE   'e', $ea,               OP_IMMW ; JP?pe $nnnn   |    EA nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@jp_m   .DATA   'h', (@jp_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $e9,               OP_IMPX ; JP*IX         | DD E9
        .BYTE   'y', $e9,               OP_IMPY ; JP*IY         | FD E9
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@jp_hl  .BYTE   'l', $e9,               OP_IMP  ; JP*HL         |    E9
        .BYTE   ERR
        ;=======================================================================
@l      .BYTE   'd'|AND
        .DATA   'd', (@ldd-CADDR)-1
        .DATA   'i', (@ldi-CADDR)-1
        .DATA   '.', (@ld_r-CADDR)-1
        ;-----------------------------------------------------------------------
        .BYTE   '*'|AND
        .DATA   'b', (@ld_bc-CADDR)-1
        .DATA   'd', (@ld_de-CADDR)-1
        .DATA   'h', (@ld_hl-CADDR)-1
        .DATA   'i', (@ld_mi-CADDR)-1
        .BYTE   'n'|AND                         ; ld*nn.r
        .BYTE   'n'|AND                         ; (needs better syntax?)
        .BYTE   '.'|AND
        .BYTE   'a', $32,               OP_IMMW ; LD*nn.A $nnnn |   32 nn nn
        .DATA   'b', (@ld_mb-CADDR)-1
        .DATA   'd', (@ld_md-CADDR)-1
        .DATA   'h', (@ld_mh-CADDR)-1
        .DATA   'i', (@ld_xy-CADDR)-1
        .BYTE   's'|AND
        .BYTE   'p', $73,               OP_IMEW ; LD*nn.SP $nnnn| ED 73 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_mb  .BYTE   'c', $43,               OP_IMEW ; LD*nn.BC $nnnn| ED 43 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_md  .BYTE   'e', $53,               OP_IMEW ; LD*nn.DE $nnnn| ED 53 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_mh  .BYTE   'l', $22,               OP_IMMW ; LD*nn.HL $nnnn|    22 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_xy  .BYTE   'x', $22,               OP_IMXW ; LD*nn.IX $nnnn| DD 22 nn nn
        .BYTE   'y', $22,               OP_IMYW ; LD*nn.IY $nnnn| FD 22 nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_bc  .BYTE   'c'|AND
        .BYTE   '.'|AND
        .BYTE   'a', $02,               OP_IMP  ; LD*BC.A       |    02
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_de  .BYTE   'e'|AND
        .BYTE   '.'|AND
        .BYTE   'a', $12,               OP_IMP  ; LD*DE.A       |    12
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_hl  .BYTE   'l'|AND
        .BYTE   END, $36,               OP_IMMB ; LD*HL $nn     |    36 nn
        .BYTE   '.'|AND
        .BYTE   'a', $70+REG_A,         OP_IMP  ; LD*HL.A       |    77
        .BYTE   'b', $70+REG_B,         OP_IMP  ; LD*HL.B       |    70
        .BYTE   'c', $70+REG_C,         OP_IMP  ; LD*HL.C       |    71
        .BYTE   'd', $70+REG_D,         OP_IMP  ; LD*HL.D       |    72
        .BYTE   'e', $70+REG_E,         OP_IMP  ; LD*HL.E       |    73
        .BYTE   'h', $70+REG_H,         OP_IMP  ; LD*HL.H       |    74
        .BYTE   'l', $70+REG_L,         OP_IMP  ; LD*HL.L       |    75
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_mi  .DATA   'x', (@ld_mx-CADDR)-1
        .BYTE   'y'|AND
        .BYTE   END, $36,               OP_IMYB ; LD*IY $oo $nn | FD 36 oo nn
        .BYTE   '.'|AND
        .BYTE   'a', $70+REG_A,         OP_IMMY ; LD*IY.A       | FD 77
        .BYTE   'b', $70+REG_B,         OP_IMMY ; LD*IY.B       | FD 70
        .BYTE   'c', $70+REG_C,         OP_IMMY ; LD*IY.C       | FD 71
        .BYTE   'd', $70+REG_D,         OP_IMMY ; LD*IY.D       | FD 72
        .BYTE   'e', $70+REG_E,         OP_IMMY ; LD*IY.E       | FD 73
        .BYTE   'h', $70+REG_H,         OP_IMMY ; LD*IY.H       | FD 74
        .BYTE   'l', $70+REG_L,         OP_IMMY ; LD*IY.L       | FD 75
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_mx  .BYTE   END, $36,               OP_IMXB ; LD*IX $oo $nn | DD 36 oo nn
        .BYTE   '.'|AND
        .BYTE   'a', $70+REG_A,         OP_IMMX ; LD*IX.A       | DD 77
        .BYTE   'b', $70+REG_B,         OP_IMMX ; LD*IX.B       | DD 70
        .BYTE   'c', $70+REG_C,         OP_IMMX ; LD*IX.C       | DD 71
        .BYTE   'd', $70+REG_D,         OP_IMMX ; LD*IX.D       | DD 72
        .BYTE   'e', $70+REG_E,         OP_IMMX ; LD*IX.E       | DD 73
        .BYTE   'h', $70+REG_H,         OP_IMMX ; LD*IX.H       | DD 74
        .BYTE   'l', $70+REG_L,         OP_IMMX ; LD*IX.L       | DD 75
        .BYTE   ERR
        ;=======================================================================
@ldd    .BYTE   END, $a8,               OP_IMPE ; LDD           | ED A8
        .BYTE   'r', $b8,               OP_IMPE ; LDDR          | ED B8
        .BYTE   ERR
        ;=======================================================================
@ldi    .BYTE   END, $a0,               OP_IMPE ; LDI           | ED A0
        .BYTE   'r', $b0,               OP_IMPE ; LDIR          | ED B0
        .BYTE   ERR
        ;=======================================================================
@ld_r   .DATA   'a', (@ld_a-CADDR)-1
        .DATA   'b', (@ld_b-CADDR)-1
        .DATA   'c', (@ld_c-CADDR)-1
        .DATA   'd', (@ld_d-CADDR)-1
        .DATA   'e', (@ld_e-CADDR)-1
        .DATA   'h', (@ld_h-CADDR)-1
        .DATA   'l', (@ld_l-CADDR)-1
        .DATA   'i', (@ld_i-CADDR)-1
        .DATA   's', (@ld_s-CADDR)-1
        .BYTE   'r'|AND
        .BYTE   '.'|AND
        .BYTE   'a', $4f,               OP_IMPE ; LD.R.A        | ED 4F
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ld_s   .BYTE   'p'|AND
        .BYTE   END, $31,               OP_IMMW ; LD.SP $nnnn   |    31 nn nn
        .BYTE   '*', $7b,               OP_IMEW ; LD.SP* $nnnn  | ED 7B nn nn
        .BYTE   '.'|AND
        .DATA   'h', (@ldsp_h-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $f9,               OP_IMPX ; LD.SP.IX      | DD F9
        .BYTE   'y', $f9,               OP_IMPY ; LD.SP.IY      | FD F9
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldsp_h .BYTE   'l', $f9,               OP_IMP  ; LD.SP.HL      |    F9
        ;=======================================================================
@ld_a   .BYTE   END, $3e,               OP_IMMB ; LD.A $nn      |    3E nn
        .DATA   '*', (@lda_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $78+REG_A,         OP_IMP  ; LD.A.A        |    7F
        .BYTE   'b', $78+REG_B,         OP_IMP  ; LD.A.B        |    78
        .BYTE   'c', $78+REG_C,         OP_IMP  ; LD.A.C        |    79
        .BYTE   'd', $78+REG_D,         OP_IMP  ; LD.A.D        |    7A
        .BYTE   'e', $78+REG_E,         OP_IMP  ; LD.A.E        |    7B
        .BYTE   'h', $78+REG_H,         OP_IMP  ; LD.A.H        |    7C
        .BYTE   'l', $78+REG_L,         OP_IMP  ; LD.A.L        |    7D
        .BYTE   'r', $5f,               OP_IMPE ; LD.A.R        | ED 5F
        .BYTE   'i'|AND
        .BYTE   END, $57                OP_IMPE ; LD.A.I        | ED 57
        .DATA   'x', (@lda_ix-CADDR)-1
        .DATA   'y', (@lda_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_ix .BYTE   'h', $78+REG_IH,        OP_IMPX ; LD.A.IXH      | DD 7C
        .BYTE   'l', $78+REG_IL,        OP_IMPX ; LD.A.IXL      | DD 7D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_iy .BYTE   'h', $78+REG_IH,        OP_IMPY ; LD.A.IYH      | FD 7C
        .BYTE   'l', $78+REG_IL,        OP_IMPY ; LD.A.IYL      | FD 7D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_m  .BYTE   END, $3a,               OP_IMMB ; LD.A* $nnnn   |    3A nn nn
        .DATA   'b', (@lda_bc-CADDR)-1
        .DATA   'd', (@lda_de-CADDR)-1
        .DATA   'h', (@lda_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $7e,               OP_IMMX ; LD.A*IX $nn   | DD 7E nn
        .BYTE   'y', $7e,               OP_IMMY ; LD.A*IY $nn   | FD 7E nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_bc .BYTE   'c', $0a,               OP_IMP  ; LD.A*BC       |    0A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_de .BYTE   'e', $1a,               OP_IMP  ; LD.A*DE       |    1A
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lda_hl .BYTE   'l', $7a,               OP_IMP  ; LD.A*HL       |    7A
        .BYTE   ERR
        ;=======================================================================
@ld_b   .BYTE   END, $06,               OP_IMMB ; LD.B $nn      |    06 nn
        .DATA   'c', (@ldbc-CADDR)-1
        .DATA   '*', (@ldb_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $40+REG_A,         OP_IMP  ; LD.B.A        |    47
        .BYTE   'b', $40+REG_B,         OP_IMP  ; LD.B.B        |    40
        .BYTE   'c', $40+REG_C,         OP_IMP  ; LD.B.C        |    41
        .BYTE   'd', $40+REG_D,         OP_IMP  ; LD.B.D        |    42
        .BYTE   'e', $40+REG_E,         OP_IMP  ; LD.B.E        |    43
        .BYTE   'h', $40+REG_H,         OP_IMP  ; LD.B.H        |    44
        .BYTE   'l', $40+REG_L,         OP_IMP  ; LD.B.L        |    45
        .BYTE   'i'|AND
        .DATA   'x', (@ldb_ix-CADDR)-1
        .DATA   'y', (@ldb_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldb_ix .BYTE   'h', $40+REG_IH,        OP_IMPX ; LD.B.IXH      | DD 44
        .BYTE   'l', $40+REG_IL,        OP_IMPX ; LD.B.IXL      | DD 45
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldb_iy .BYTE   'h', $40+REG_IH,        OP_IMPY ; LD.B.IYH      | FD 44
        .BYTE   'l', $40+REG_IL,        OP_IMPY ; LD.B.IYL      | FD 45
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldbc   .BYTE   END, $01,               OP_IMMW ; LD.BC $nnnn   |    01 nn nn
        .BYTE   '*', $4b,               OP_IMEW ; LD.BC* $nnnn  | ED 4B nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldb_m  .DATA   'h', (@ldb_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $46,               OP_IMMX ; LD.B*IX $nn   | DD 46 nn
        .BYTE   'y', $46,               OP_IMMY ; LD.B*IY $nn   | FD 46 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldb_hl .BYTE   'l', $46,               OP_IMP  ; LD.B*HL       |    46
        .BYTE   ERR
        ;=======================================================================
@ld_c   .BYTE   END, $0e,               OP_IMMB ; LD.C $nn      |    0E nn
        .DATA   '*', (@ldc_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $48+REG_A,         OP_IMP  ; LD.B.A        |    4F
        .BYTE   'b', $48+REG_B,         OP_IMP  ; LD.B.B        |    48
        .BYTE   'c', $48+REG_C,         OP_IMP  ; LD.B.C        |    49
        .BYTE   'd', $48+REG_D,         OP_IMP  ; LD.B.D        |    4A
        .BYTE   'e', $48+REG_E,         OP_IMP  ; LD.B.E        |    4B
        .BYTE   'h', $48+REG_H,         OP_IMP  ; LD.B.H        |    4C
        .BYTE   'l', $48+REG_L,         OP_IMP  ; LD.B.L        |    4D
        .BYTE   'i'|AND
        .DATA   'x', (@ldc_ix-CADDR)-1
        .DATA   'y', (@ldc_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldc_ix .BYTE   'h', $48+REG_IH,        OP_IMPX ; LD.C.IXH      | DD 4C
        .BYTE   'l', $48+REG_IL,        OP_IMPX ; LD.C.IXL      | DD 4D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldc_iy .BYTE   'h', $48+REG_IH,        OP_IMPY ; LD.C.IYH      | FD 4C
        .BYTE   'l', $48+REG_IL,        OP_IMPY ; LD.C.IYL      | FD 4D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldc_m  .DATA   'h', (@ldc_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $4e,               OP_IMMX ; LD.C*IX $nn   | DD 4E nn
        .BYTE   'y', $4e,               OP_IMMY ; LD.C*IY $nn   | FD 4E nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldc_hl .BYTE   'l', $4e,               OP_IMP  ; LD.C*HL       |    4E
        .BYTE   ERR
        ;=======================================================================
@ld_d   .BYTE   END, $16,               OP_IMMB ; LD.D $nn      |    16 nn
        .DATA   'e', (@ldde-CADDR)-1
        .DATA   '*', (@ldd_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $50+REG_A,         OP_IMP  ; LD.D.A        |    57
        .BYTE   'b', $50+REG_B,         OP_IMP  ; LD.D.B        |    50
        .BYTE   'c', $50+REG_C,         OP_IMP  ; LD.D.C        |    51
        .BYTE   'd', $50+REG_D,         OP_IMP  ; LD.D.D        |    52
        .BYTE   'e', $50+REG_E,         OP_IMP  ; LD.B.E        |    53
        .BYTE   'h', $50+REG_H,         OP_IMP  ; LD.B.H        |    54
        .BYTE   'l', $50+REG_L,         OP_IMP  ; LD.B.L        |    55
        .BYTE   'i'|AND
        .DATA   'x', (@ldd_ix-CADDR)-1
        .DATA   'y', (@ldd_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldd_ix .BYTE   'h', $50+REG_IH,        OP_IMPX ; LD.D.IXH      | DD 54
        .BYTE   'l', $50+REG_IL,        OP_IMPX ; LD.D.IXL      | DD 55
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldd_iy .BYTE   'h', $50+REG_IH,        OP_IMPY ; LD.D.IYH      | FD 54
        .BYTE   'l', $50+REG_IL,        OP_IMPY ; LD.D.IYL      | FD 55
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldde   .BYTE   END, $11,               OP_IMMW ; LD.DE $nnnn   |    11 nn nn
        .BYTE   '*', $5b,               OP_IMEW ; LD.DE* $nnnn  | ED 5B nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldd_m  .DATA   'h', (@ldd_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $56,               OP_IMMX ; LD.D*IX $nn   | DD 56 nn
        .BYTE   'y', $56,               OP_IMMY ; LD.D*IY $nn   | FD 56 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldd_hl .BYTE   'l', $56,               OP_IMP  ; LD.D*HL       |    56
        .BYTE   ERR
        ;=======================================================================
@ld_e   .BYTE   END, $1e,               OP_IMMB ; LD.E $nn      |    1E nn
        .DATA   '*', (@lde_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $58+REG_A,         OP_IMP  ; LD.E.A        |    5F
        .BYTE   'b', $58+REG_B,         OP_IMP  ; LD.E.B        |    58
        .BYTE   'c', $58+REG_C,         OP_IMP  ; LD.E.C        |    59
        .BYTE   'd', $58+REG_D,         OP_IMP  ; LD.E.D        |    5A
        .BYTE   'e', $58+REG_E,         OP_IMP  ; LD.E.E        |    5B
        .BYTE   'h', $58+REG_H,         OP_IMP  ; LD.E.H        |    5C
        .BYTE   'l', $58+REG_L,         OP_IMP  ; LD.E.L        |    5D
        .BYTE   'i'|AND
        .DATA   'x', (@lde_ix-CADDR)-1
        .DATA   'y', (@lde_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lde_ix .BYTE   'h', $58+REG_IH,        OP_IMPX ; LD.E.IXH      | DD 5C
        .BYTE   'l', $58+REG_IL,        OP_IMPX ; LD.E.IXL      | DD 5D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lde_iy .BYTE   'h', $58+REG_IH,        OP_IMPY ; LD.E.IYH      | FD 5C
        .BYTE   'l', $58+REG_IL,        OP_IMPY ; LD.E.IYL      | FD 5D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lde_m  .DATA   'h', (@lde_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $5e,               OP_IMMX ; LD.E*IX $nn   | DD 5E nn
        .BYTE   'y', $5e,               OP_IMMY ; LD.E*IY $nn   | FD 5E nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@lde_hl .BYTE   'l', $5e,               OP_IMP  ; LD.E*HL       |    5E
        .BYTE   ERR
        ;=======================================================================
@ld_h   .BYTE   END, $26,               OP_IMMB ; LD.H $nn      |    26 nn
        .DATA   'l', (@ldhl-CADDR)-1
        .DATA   '*', (@ldh_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $60+REG_A,         OP_IMP  ; LD.H.A        |    67
        .BYTE   'b', $60+REG_B,         OP_IMP  ; LD.H.B        |    60
        .BYTE   'c', $60+REG_C,         OP_IMP  ; LD.H.C        |    61
        .BYTE   'd', $60+REG_D,         OP_IMP  ; LD.H.D        |    62
        .BYTE   'e', $60+REG_E,         OP_IMP  ; LD.H.E        |    63
        .BYTE   'h', $60+REG_H,         OP_IMP  ; LD.H.H        |    64
        .BYTE   'l', $60+REG_L,         OP_IMP  ; LD.H.L        |    65
        .BYTE   'i'|AND
        .DATA   'x', (@ldh_ix-CADDR)-1
        .DATA   'y', (@ldh_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldh_ix .BYTE   'h', $60+REG_IH,        OP_IMPX ; LD.H.IXH      | DD 64
        .BYTE   'l', $60+REG_IL,        OP_IMPX ; LD.H.IXL      | DD 65
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldh_iy .BYTE   'h', $60+REG_IH,        OP_IMPY ; LD.H.IYH      | FD 64
        .BYTE   'l', $60+REG_IL,        OP_IMPY ; LD.H.IYL      | FD 65
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldhl   .BYTE   END, $21,               OP_IMMW ; LD.HL $nnnn   |    21 nn nn
        .BYTE   '*', $2a,               OP_IMEW ; LD.HL* $nnnn  | ED 2A nn nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldh_m  .DATA   'h', (@ldh_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $66,               OP_IMMX ; LD.H*IX $nn   | DD 66 nn
        .BYTE   'y', $66,               OP_IMMY ; LD.H*IY $nn   | FD 66 nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldh_hl .BYTE   'l', $66,               OP_IMP  ; LD.H*HL       |    66
        .BYTE   ERR
        ;=======================================================================
@ld_l   .BYTE   END, $2e,               OP_IMMB ; LD.L $nn      |    2E nn
        .DATA   '*', (@ldl_m-CADDR)-1
        .BYTE   '.'|AND
        .BYTE   'a', $68+REG_A,         OP_IMP  ; LD.L.A        |    6F
        .BYTE   'b', $68+REG_B,         OP_IMP  ; LD.L.B        |    68
        .BYTE   'c', $68+REG_C,         OP_IMP  ; LD.L.C        |    69
        .BYTE   'd', $68+REG_D,         OP_IMP  ; LD.L.D        |    6A
        .BYTE   'e', $68+REG_E,         OP_IMP  ; LD.L.E        |    6B
        .BYTE   'h', $68+REG_H,         OP_IMP  ; LD.L.H        |    6C
        .BYTE   'l', $68+REG_L,         OP_IMP  ; LD.L.L        |    6D
        .BYTE   'i'|AND
        .DATA   'x', (@ldl_ix-CADDR)-1
        .DATA   'y', (@ldl_iy-CADDR)-1
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldl_ix .BYTE   'h', $68+REG_IH,        OP_IMPX ; LD.L.IXH      | DD 6C
        .BYTE   'l', $68+REG_IL,        OP_IMPX ; LD.L.IXL      | DD 6D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldl_iy .BYTE   'h', $68+REG_IH,        OP_IMPY ; LD.L.IYH      | FD 6C
        .BYTE   'l', $68+REG_IL,        OP_IMPY ; LD.L.IYL      | FD 6D
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldl_m  .DATA   'h', (@ldl_hl-CADDR)-1
        .BYTE   'i'|AND
        .BYTE   'x', $6e,               OP_IMMX ; LD.L*IX $nn   | DD 6E nn
        .BYTE   'y', $6e,               OP_IMMY ; LD.L*IY $nn   | FD 6E nn
        .BYTE   ERR
        ;-----------------------------------------------------------------------
@ldl_hl .BYTE   'l', $6e,               OP_IMP  ; LD.L*HL       |    6E
        .BYTE   ERR
        ;=======================================================================
@ld_i   .BYTE   ERR
        ;=======================================================================
.ENDB