; v80, (C) Kroc Camen 2023-2024, MIT License
; a z80 assembler for Z80s
;
.DEF    DEBUG

.INC    "cpm.wla"                       ; CP/M interface
.INC    "err.wla"                       ; error message handling
.INC    "z80.wla"                       ; Z80 parser & opcode binary tree

.BLOCK  "code"
;===============================================================================
; memory map:
;
;   +-----+-----------------------------------+--------+--------+---------+
;   | v80 | code->                     <-heap | <-word | <-expr | <-stack |
;   +-----+-----------------------------------+--------+--------+---------+
;                                                 32       128      128
;   code:  source code is assembled here
;   heap:  symbols and other in-flight data goes here (builds downwards)
;   word:  a buffer for capturing words (symbol names)
;   expr:  expressions are tokenised here (builds downwards)
;   stack: usual Z80 stack (builds downwards)
;
.DEF    WORD_LEN        30              ; maximum symbol name length

; the bottom of the word buffer, just above the heap, can be used
; as temporary space for a few bytes (so their use can't overlap)
;
; (these addresses are set during initialisation,
;  the values here are only examples based on RunCPM)
;
temp:   .ADDR $fc00                     ; temp bytes at bottom of stack
word:   .ADDR $fc1f                     ; word-buffer (works backwards)
sp:     .ADDR $fd00                     ; stack pointer backup

char:   .BYTE $00                       ; current input character

; NOTE: these two bytes are specifically grouped together because they
;       are required by deferred expressions written to the heap,
;       and are pushed together as a single word
stride_col:
stride: .BYTE $00                       ; number of bytes to occupy
col:    .BYTE $00                       ; current column-number in file
row:    .WORD $0000                     ; current line-number in file

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred expressions
; will be built up on the heap. it works downwards from the top of memory
; in order to maximise the available space before the assembled binary
; and heap collide. during initialisation the heap will be placed 256 bytes
; below the stack at the top of memory, giving enough room for the stack
;
; like the stack, the heap is pre-decrement meaning that the heap address
; is decremented first before writing a value, ergo the heap addr points
; to a currently occupied byte on the heap
;
heap:   .ADDR $fc00                     ; current position on the heap

; dictionaries:
;-------------------------------------------------------------------------------
; labels and constants are stored as a linked-list of dictionary entries.
; each has its own entry point to avoid wasting time searching for labels
; amongst constants and vice-versa. $0000 terminates the list
;
; although the heap extends downwards, the link address has to point to
; the lo-byte of the entry's link field which is technically the 2nd byte
; of the record
;                     +------+
;          .--------->| addr |  (entry point)
;       2. |          +--|---+
; - - -----+------+      | 1.
;  ...data | addr | <----'      (heap extends downwards)
; - - -----+------+
;
label:  .ADDR $000                      ; addr of last label dictionary-entry
const:  .ADDR $000                      ; addr of last const dictionary-entry

; expression bytecode:
;-------------------------------------------------------------------------------
; calculations are compiled into bytecode to allow for later evaluation,
; i.e. for deferred calculations where a symbol is not yet known
;
.DEF    CHAR_END         0              ; general terminator
.DEF    CHAR_COMMENT    ';'             ; comment
.DEF    CHAR_KEYWORD    '.'             ; keyword
.DEF    CHAR_HEX        '$'             ; hexadecimal literal or PC
.DEF    CHAR_LABEL      ':'             ; a label (16-bit)
.DEF    CHAR_CONST      '#'             ; a constant (flexible size)
.DEF    CHAR_OP_LO      '<'             ; lo-byte unary operator
.DEF    CHAR_OP_HI      '>'             ; hi-byte unary operator
.DEF    CHAR_OP_NOT     '!'             ; not unary operator
.DEF    CHAR_OP_ADD     '+'             ; add operator
.DEF    CHAR_OP_SUB     '-'             ; subtract operator
.DEF    CHAR_OP_MUL     '*'             ; multiply operator
.DEF    CHAR_OP_DIV     '/'             ; divide operator
.DEF    CHAR_OP_AND     '&'             ; and operator
.DEF    CHAR_OP_OR      '|'             ; or operator
.DEF    CHAR_OP_XOR     '^'             ; xor operator
.DEF    CHAR_OP_MOD     '\'             ; modulo operator

expr:   .ADDR $fc7f                     ; expr token space (builds downwards)
defer:  .ADDR $0000                     ; addr of last deferred expr


init:
;===============================================================================
        ; set heap position:
        ;-----------------------------------------------------------------------
        ; this *assumes* we are at least 1 call deep on the stack,
        ; i.e. $FCFE rather than the unused stack top @ $FD00
        ;
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ld      L,      0               ; use 0 for lo-byte, e.g. $FC00
        ld      [temp], HL              ; use bottom of stack for temp bytes
        ld      [heap], HL              ; finally set the heap position
        ld      BC,     WORD_LEN+1      ; max word-length for word buffer,
        add     HL,     BC              ;  plus 1 byte to store word-length
        ld      [word], HL              ;  (word buffer works downwards)
        ld      L,      $7f             ; the expr token space starts in the
        ld      [expr], HL              ;  middle of the page and works down

        ; the virtual program counter is permanently pinned to IX since
        ; it's a value that needs to be incremented often but not read
        ; back too often. this avoids a bunch of HL/DE register swapping
        ;
        ld      IX,     $0100           ; virtual program-counter

        call    memStat                 ; print the memory status

        ; assemble the file
        ;-----------------------------------------------------------------------
        call    assembleFile
        ;-----------------------------------------------------------------------

        ld      [heap], HL
        call    memStat
        ret                             ; return to CP/M to quit the program


memStat:
;===============================================================================
; prints memory status:
;-------------------------------------------------------------------------------
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ex      DE,     HL              ; swap SP into DE
        ld      HL,     @stack          ; stack addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [heap]
        ld      HL,     @heap           ; heap addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [code]
        ld      HL,     @code           ; code addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     @mem
        jp      osPrintStr

        ;-----------------------------------------------------------------------
        ; convert DE to ASCII hexadecimal digits and insert in the string
        ;
@hex:   ld      A,      D
        call    @byte
        ld      A,      E
@byte:  call    getHexByte
        ld      [HL],   B
        inc     HL
        ld      [HL],   C
        inc     HL
        ret

        ;-----------------------------------------------------------------------
@mem    .BYTE   "[stack: "
@stack  .BYTE   "0000"
        .BYTE   " | heap: "
@heap   .BYTE   "0000"
        .BYTE   " | code: "
@code   .BYTE   "0000"
        .BYTE   "]\n$"


assembleFile:
;===============================================================================
; assembles a file:
;
;-------------------------------------------------------------------------------
        ; TODO: do the file opening here so that we can do includes
        call    assemble

        ret

assemble:
;===============================================================================
; NOTE: we avoid using calls here where possible because scopes are linear
;       and we don't want to pressure the stack too much (it's small)
;-------------------------------------------------------------------------------
        ld      HL,     [heap]          ; where symbols / expressions go
        jr      @line                   ; jump into parsing loop

        ; skip comments:
        ;=======================================================================
@skip:  call    readChar                ; read to next character or newline
        jr      nz,     @skip           ; loop until newline / end-of-file

        ; distinguish between newline and end-of-file:
        ;-----------------------------------------------------------------------
        ; readChar returns zero-flag set for both newline and end-of-file,
        ; check the ASCII code to differntiate the two
        ;
@nleof: cp      ASCII_LF                ; check for newline
        ret     nz                      ; no? end-of-file -- end assembling

        ; at newline fallthrough to
        ; the line-staring context
        ; ...

        ; begin at line context:
        ;-----------------------------------------------------------------------
        ; at the beginning of the line labels and the
        ; program-counter can be defined, but nowhere else
        ;
@line:  call    skipSpace               ; find first character
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ; first character determines the word type:
        ;
        cp      CHAR_LABEL              ; is label?
        jr      z,      @label          ; define a label

        ; any expression defines the virtual program-counter
        ; (except labels, you can't set the virtual program-counter
        ;  based on another label, set up a constant for that)
        ;
        cp      CHAR_HEX                ; hexadecimal literal or current PC?
        jr      z,      @pc             ; redefine program-counter
        cp      CHAR_CONST              ; likewise for a constant
        jr      z,      @pc             ; redefine program-counter
        ; (the unary operators can also start an expression)
        cp      CHAR_OP_LO              ; lo operator?
        jr      z,      @pc             ; redefine program-counter 
        cp      CHAR_OP_HI              ; hi operator?
        jr      z,      @pc             ; redefine program-counter 
        cp      CHAR_OP_NOT             ; not operator?
        jr      nz,     @body           ; no expression -- skip to body context

        ; modify the virtual program-counter:
        ;=======================================================================
@pc:    call    tokenExpr               ; capture the complete expression
        halt
        jr      @body

        ; body context:
        ;-----------------------------------------------------------------------
        ; labels and the program-counter must be defined first on the line and
        ; after those, instructions and keywords are allowed. this is known as
        ; the body context and multiple instructions / keywords can occur until
        ; either a comment or the end of the line
        ;
        ; after a keyword or instruction, parsing returns to the body context
        ; unless a newline is encountered. in cases where the last-read char
        ; is whitespace we need to pickup the next character
        ;
@next:  ld      A,      [char]          ; last read character
        and     A                       ; (set CPU flags!)
        ret     z                       ; 0 = end-of-file, end assemby
        cp      ASCII_LF                ; newline?
        jr      z,      @line           ; switch to line context
        cp      ASCII_SPC               ; space?
        call    z,      skipSpace       ; find next character (or newline)
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ;-----------------------------------------------------------------------
@body:  cp      CHAR_COMMENT            ; is comment?
        jr      z,      @skip           ; skip until end of line
        cp      CHAR_KEYWORD            ; is this a keyword?
        jr      z,      @key            ; handle keyword

        ; this routine is in the CPU-specific module, e.g. z80.wla
        call    parseInstruction

        jr      @next

        ; handle keywords:
        ;=======================================================================
@key:   halt

        ; define label:
        ;=======================================================================
        ; check if the label already exists:
        ;
@label: ld      DE,     label           ; label dictionary entry point
        call    getSymbol               ; read label name and search for it
        
        ; if the label has been referenced in an expression, but not yet
        ; defined, carry will be set. in this case we want to 'fill in the
        ; blank' so that deferred expressions using this label can be evaluated
        ;
        jr      c,      +               ; does it exist as a forward-reference?
        
        ; zero-flag will be set if the label either does not exist at all,
        ; or was a forward-reference (we've eliminated forward-references
        ; first), therefore if the label *does* exist we're trying to
        ; define a label twice!
        ;
        jp      nz,     errLabel        ; cannot redefine labels!

        call    pushLabel               ; define new label on the heap
        jr      @next                   ; return to parsing

        ;-----------------------------------------------------------------------
        ; when a label has been referred to in an expression in the past,
        ; a placeholder is added to the dictionary awaiting definition --
        ; now that time has come. `getSymbol` has returned the addr (BC)
        ; in the heap where the label's flag byte and value is
        ;
+       inc     A                       ; set flag byte to indicate valid value
        ld      [BC],   A               ; update symbol record
        dec     BC                      ; move on to symbol value
        ld      A,      IXH             ; virtual program-counter, hi-byte
        ld      [BC],   A
        dec     BC
        ld      A,      IXL             ; virtual program-counter, lo-byte
        ld      [BC],   A
        
        jr      @next                   ; return to parsing


skipSpace:
;===============================================================================
; reads input until a visible character (ASCII >32),
; or a newline / end-of-file is reached:
; 
; be aware that this will return on newline and that there may be more leading
; whitespace on the next line -- if you want to skip to the next non-whitespace
; character, call the routine again after newline
;
; out:  A               ASCII code, 0 = end-of-file
;       zf              zero-flag is set at newline or end-of-file
;-------------------------------------------------------------------------------
-       call    readChar                ; read a character (returns z-flag)
        ret     z                       ; return z-flag set if newline/EOF

        ; we need to be careful not to return z-flag set!
        ;
        ; we cannot check for ASCII_SPC+1 ("!") as if this character appears,
        ; the parser will think the file ended. instead look for space itself
        ; -- for any ASCII code below we continue looping, and space itself
        ; is caught with the zero-flag and re-looped
        ; 
        cp      ASCII_SPC               ; is ASCII code a space?
        jr      c,      -               ; keep reading if codes 1-31
        jr      z,      -               ; also, keep reading if space

        ret

readChar:
;===============================================================================
; reads the next character in the file:
; current row and column are maintained
;
; out:  A               ASCII code. 0 = end-of-file
;       zf              zero-flag is set *both* for end-of-file and newline!
;       [char]          the character is also written to RAM
;       DE, HL          (preserved)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        call    osPrintChar             ; print every character as we receive it
        pop     AF                      ; (zero-flag must be preserved)
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        ret     z                       ; return on end-of-file

        ; check for end of line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      z,      @row            ; handle newline
        cp      ASCII_TAB               ; /t is tab
        jr      z,      @tab            ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; WARN: we do not cap the column number -- keep lines to 80 cols!
        ;       when a line exceeds 255 chars, the 256th character will
        ;       be treated as end-of-file!
        ;
@col:   inc     [HL']
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
        ; TODO: should we pin line-number to IY?
@row:   ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
@tab:   dec     A                       ; \t = 9, so change to 8 (width of tab)
        add     [HL']                   ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        ld      [HL'],  A               ; update column number
        ld      A,      ASCII_SPC       ; return a single space instead

        exx                             ; restore HL/DE
        ret


getSymbol:
;===============================================================================
; reads a symbol name from input and searches for it in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;
; out:  A               non-zero if found. 0 if symbol not found, including
;                       forward-references that don't have a valid value yet
;       zf              zero-flag is set according to the above
;       cf              carry set indciates the symbol is a forward-reference
;       BC              if symbol found, BC holds its value
;                       if symbol doesn't exist, **BC retains the name length**
;                       if symbol is a forward-reference (carry-set), then BC
;                       is the addr of the flag byte of the symbol record --
;                       this is so that the symbol value can be updated
;       DE              $0000 if label doesn't exist. if the label exists,
;                       inlcuding forward-references that would otherwise
;                       behave as "not found", DE contains the addr of the
;                       symbol, pointing to the lo-byte of the link field
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;-------------------------------------------------------------------------------
        push    HL                      ; current heap position won't be used

        ; swap dictionary entry point to HL as we will be replacing DE
        ; with the word-buffer address to read the symbol name in
        ex      DE,     HL

        ; read symbol name:
        ;=======================================================================
        ; note that the word is written *downwards* in RAM, to match how
        ; symbol names are written on the heap, for faster comparison --
        ; we use the bottom of a page to hold the incoming word so that
        ; we can get away with using `DEC E` instead of `DEC DE`
        ;
        ld      DE,     [word]          ; top of word-buffer, e.g $FC1F
        jr      +                       ; (first character already read)
        ;-----------------------------------------------------------------------
-       call    readChar                ; read char from input file
        cp      ASCII_SPC+1             ; whitespace?
        jr      c,      @ok             ; (leave loop at whitespace)
+       dec     E                       ; move to next space in buffer
        ld      [DE],   A               ; add the character to the buffer
        jp      p,      -               ; keep going until buffer full
        ;-----------------------------------------------------------------------
        jp      errWord                 ; word too long!

        ;-----------------------------------------------------------------------
@ok:    ld      A,      WORD_LEN        ; max size - characters remaining
        sub     E                       ;  = length of word
        ld      E,      WORD_LEN+1      ; snap back to length byte
        ld      [DE],   A               ; write word-length byte

        ld      C,      A
        ld      B,      0

        ; find symbol in dictionary:
        ;=======================================================================
        jr      @next                   ; jump into the loop

        ;-----------------------------------------------------------------------
        ; names do not match!
        ;
--      ld      E,      WORD_LEN+1      ; snap back to length byte in buffer
        pop     HL                      ; snap back to length byte in symbol
        ld      C,      [HL]            ; re-get word-length to check
-       inc     HL                      ; move *up* to link addr lo-byte

        ;-----------------------------------------------------------------------
        ; the link field of a symbol points to      - - -+------+
        ; the lo-byte of the next symbol's link          | link |
        ; field in the chain, with the remaining    - - -+--|---+
        ; fields extending *downwards* in RAM            .--'
        ;                                                v
        ;          +-------+---+---+---+---+---+---+-----+------+
        ;  < heap  | value | l | e | b | a | l | : | len | link |
        ;          +-------+---+---+---+---+---+---+-----+------+
        ;
        ; follow this link, but exit if it's $0000
        ; (also setting the zero-flag and clearing carry
        ;  -- did you know that OR cleared carry!??)
        ;
@next:  ld      A,      [HL]            ; read next symbol addr, lo-byte
        inc     HL                      ; move *up* to link addr hi-byte
        ld      H,      [HL]            ; read next symbol addr, hi-byte
        ld      L,      A               ; (complete the addr)
        or      H                       ; is the link addr $0000?
        jr      z,      @end            ; terminate at end of chain

        ; (HL is now the next symbol addr in the heap)

        dec     HL                      ; move down to length byte
        ld      A,      [HL]            ; get symbol name length
        cp      C                       ; compare with word-buffer length
        jr      nz,      -              ; different? return to link and follow

        ;-----------------------------------------------------------------------
        ; symbol length matches, check characters:
        ;
        ; remember this position to snap back to if the symbol doesn't
        ; match and we need to follow the link to the next symbol
        push    HL

        dec     HL                      ; move down a character in the heap
@char:  dec     E                       ; move down a character in word-buffer
        ld      A,      [DE]            ; read char from word-buffer
        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
        jr      nz,     --              ; stop looping if mismatch
        jp      pe,     @char           ; keep looping until chars run out

        ; names match! read and return the symbol value:
        ;-----------------------------------------------------------------------
        ; the flag byte is used to indicate a forward-reference on a label;
        ; the label name is known, but doesn't have a value yet. we return
        ; this flag in the carry flag by shifting it out of the byte
        ;
        ; for a deferred value the byte is 0; the shift keeps this as zero,
        ; sets zero-flag and CCF sets the carry flag accordingly. for a valid
        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
        ; zero flag and CCF clears the carry
        ;
        ; NOTE: CPD has already decremented HL for us!
        ld      A,      [HL]            ; read forward-reference flag byte
        rrca                            ; shift bit 0 into bit 7 AND carry!
        ccf                             ; flip carry so forward-reference = 1

        ; for a forward-reference, BC returns the address of
        ; the flag-byte so that the label's true value can be set
        ;
        ; (it's faster to just do these two instructions
        ;  in all cases and branch on the less-likely case)
        ;
        ld      B,      H               ; copy current heap addr
        ld      C,      L               ;  to BC
        jr      c,      +               ; skip value for forward-reference

        ; get the label's value:
        ;
        dec     HL                      ; step past flag byte
        ld      B,      [HL]            ; symbol value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = symbol value

        ; return the address of the symbol:
+       pop     HL                      ; snap back to the symbol-len field
        inc     HL                      ; move *up* to link addr lo-byte
@end:   ex      DE,     HL              ; swap symbol addr to DE

        pop     HL                      ; restore heap position
        ret


pushLabel:
;===============================================================================
; push a new label to the heap:
; 
; - the link addr to the previous label
; - the label name length; here for faster searching
; - the label name, written right-to-left -- the heap extends downwards!
; - a flag to indicate a forward-reference:
;   this happens when a label that does not exist is encountered in an expr,
;   a placeholder label is added to the heap to be filled in later. this is
;   necessary for the expr to be deferred until later to reference the label
; - the label value; the current virtual program-counter
;
; WARN: does not check if the label already exists!
;
; in:   cf              carry-flag set indicates a forward-reference!
;       HL              heap position to write new label
;       BC              word-length (set by `getSymbol`)
;       [word]          the label is assumed to be in the word-buffer,
;                       i.e. after calling `getSymbol`
; out:  HL              heap position is advanced (downwards!)
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ; link this label to the previous one:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [label]         ; read prev label addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev label addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev label addr lo-byte
        ld      [label],HL              ; update entry point with heap addr

        ; push the label name:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        ; (these instructions don't modify carry...)
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        lddr                            ; copy BC bytes from [DE] to [HL]!

        ; push flag to indicate a forward-reference:
        ;
        ; the flag byte is designed so that `getSymbol` will return zero-flag
        ; set for forward-references, i.e. the label is considered undefined,
        ; but carry is set to distinguish labels that exist in the dictionary
        ; vs. those that don't (required for deferring expressions)
        ;
        ; the flag is flipped to allow some trickery on read out to return
        ; A=0 and set both zero-flag AND carry-flag for forward-references
        ;
        ; NOTE: LDDR has already decremented HL for us
        ;
        ccf                             ; forward-reference = 0, otherwise 1
        rl      B                       ; shift carry flag into bit 0
        ld      [HL],   B               ; B will be 0 or 1

        ; push the label value (virtual program-counter):
        ; if the label is a forward-reference, this value is ignored
        ;
        ; the value comes after the label name to speed up symbol searching
        ; as the value is only needed once a symbol name is matched and then
        ; the addr is in the right place
        ;
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXH
        ld      [HL],   A
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXL
        ld      [HL],   A

        ret


skipToParseExpr:
;===============================================================================
; skip space before parsing an expression:
; (see parseExpr below for parameters)
;
;-------------------------------------------------------------------------------
        call    skipSpace

        ; since the expression is expected/required,
        ; newline or end-of-file is an error:
        jp      z,      errParam

        ; fallthrough
        ; ...

parseExpr:
;===============================================================================
; parse an expression from the input file, tokenise it and evaluate it,
; writing the result to the code-segment. if the expression has forward-
; references, it'll be deferred
;
; in:   HL              current heap addr; if the expr has to be deferred
;                       it'll be pushed to the heap
;       [stride]        the stride (parameter width) needs to be set as this
;                       determines the number of bytes the result fits in
;-------------------------------------------------------------------------------
        call    tokenExpr               ; read expr and tokenise

        ; HL, the start of the expression will be returned as-is. DE will
        ; contain the *end* of the expression. if we can't evaluate the
        ; expression, we need to keep it and append a defer record
        ;


        ; evaluate the expression and return its value:
        ; (fallthrough...)

evalExpr:
;===============================================================================
; evaluates an expr:
;
; in:   HL      addr of the expr tokens on the heap
; out:  BC      result value
;-------------------------------------------------------------------------------
        ret


tokenExpr:
;===============================================================================
; read an expression from the input file into tokens:
;
; words are read and converted into tokens.
; if the expression contains forward references a flag is returned
;
; WARN: the first character of the expression is assumed to be read and
;       the first character of the next word following the expression
;       will be read but not used! this allows chaining of expressions,
;       but you must avoid calling `readChar` without first using the
;       character waiting in `[char]`
;
; TODO: return some flag for evaluable state. A? c? z?
;
; out:  A, BC|DE|HL     (clobbered)
;-------------------------------------------------------------------------------
        ; expressions are tokenised into a temporary space below the stack,
        ; this is because any forward-references to labels will need to be
        ; pushed to the heap so we can't have the expression on the heap
        ; at the same time!
        ;
        ; TODO: `ld HL, [expr]` can be patched with `ld HL, $xx80`
        ;       to save 10 cycles here?
        ;
        ld      HL,     [expr]          ; get addr of expr bytecode space
        ld      A,      [char]          ; get current unused input char
        jr      @unary                  ; jump into the parsing loop

        ;=======================================================================
        ; add an operator and fall-through to the next operand:
        ;
-       dec     HL                      ; move to next token space
        ld      [HL],   A               ; push token in A to expr

        call    skipSpace               ; read first character of the next word
        jp      z,      errExpr         ; newline/EOF = unexpected expr end!

        ; an expression must begin with either a value,
        ; or a unary operator and a value
        ;
        ; unary operator?
        ;-----------------------------------------------------------------------
        ; unary operators can always precede values,
        ; even after an operator, e.g. `$10 + <:label`
        ;
@unary: cp      CHAR_OP_LO              ; lo-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      CHAR_OP_HI              ; hi-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      CHAR_OP_NOT             ; not operator?
        jr      nz,     @value          ; no unary operators, check for values

        ; a unary operator has been added,
        ; read the next character:
+       dec     HL                      ; move to next token space
        ld      [HL],   A               ; push a unary operator token

        call    skipSpace               ; read first character of the next word
        jp      z,      errExpr         ; newline/EOF = unexpected expr end!

        ; hexadecimal literal?
        ;-----------------------------------------------------------------------
        ; a sigil is required because A-F can't be separated
        ; from instruction names without look-ahead
        ;
@value: cp      CHAR_HEX                ; hexadecimal sigil?
        jr      nz,     @const

        dec     HL                      ; move to next token space
        ld      [HL],   A               ; push a number token
        call    parseHexNumber          ; parse the hex number into BC
        dec     HL                      ; move to next token space
        ld      [HL],   B               ; push the number hi-byte
        dec     HL                      ; move to next token space
        ld      [HL],   C               ; push the number lo-byte

        jr      @op                     ; an operator can follow a value

        ; constant?
        ;-----------------------------------------------------------------------
@const: cp      CHAR_CONST              ; a constant?
        jr      nz,     @label

        ld      DE,     const           ; const dictionary entry point
        call    getSymbol               ; try get the constant's value

        halt

        ; label?
        ;-----------------------------------------------------------------------
@label: cp      CHAR_LABEL              ; a label?
        jp      nz,     errExpr         ; expression has no value!!

        ld      DE,     label           ; label dictionary entry point
        call    getSymbol               ; try get the label's value
        jr      c,      @defer

        ; TODO: handle missing label


        halt

        ; any expression that contains a forward-reference to a label causes
        ; the whole expression to be deferred. instead of the label value,
        ; the label's address in the dictionary is tokenised
        ;
@defer: dec     HL                      ; move to next token space
        ld      [HL],   CHAR_LABEL      ; push the label token
        dec     HL                      ; move to next token space
        ld      [HL],   D               ; push the label addr hi-byte
        dec     HL                      ; move to next token space
        ld      [HL],   E               ; push the label addr lo-byte

        ; TODO: set the defer flag
        

        ; push a token with word/addr value:
        ;-----------------------------------------------------------------------
;@word:  dec     HL                      ; move to next token space
;        ld      [HL],   A               ; push the value token
;        dec     HL                      ; move to next token space
;        ld      [HL],   B               ; push the number/addr hi-byte
;        dec     HL                      ; move to next token space
;        ld      [HL],   C               ; push the number/addr lo-byte

        ;-----------------------------------------------------------------------
        ; a value has been added, check for the presence of an operator:
        ; if there's no operator, the expression ends here
        ;
@op:    call    skipSpace               ; read first character of the next word
        jr      z,      @end            ; end expr at newline / end-of-file

        cp      CHAR_OP_ADD             ; add operator?
        jr      z,      -               ; push token to heap, find next operand
        cp      CHAR_OP_SUB             ; subtract operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_MUL             ; multiply operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_DIV             ; divide operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_AND             ; and operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_OR              ; or operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_XOR             ; xor operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_MOD             ; modulo operator?
        jr      z,      -               ; ...

        ; whatever it is, it isn't an operator;
        ; fall through and terminate the expression

        ;-----------------------------------------------------------------------
        ; TODO: check for an overflow here
        ;
@end:   dec     HL                      ; move to next token space
        ld      [HL],   CHAR_END        ; terminate the expression (0)
        ret


parseHexNumber:
;===============================================================================
; parses an ASCII hexadecimal number and returns the value:
;
; TODO: return PC for `$`
;
; out:  BC              the value, 0 padded for numbers < 256
;       A, DE           (clobbered)
;-------------------------------------------------------------------------------
        ; try to read up to 4 digits; the 5th character
        ; must be whitespace or newline / end-of-file!
        ;
        ; the bottom of the word-buffer is used for temporary bytes
        ; (e.g. $FC00..) as we know this is page-aligned and can use
        ; INC E instead of INC DE
        ;
        ld      B,      5
        ld      DE,     [temp]          ; where to write the bytes
        ;-----------------------------------------------------------------------
-       call    readChar                ; read a char from file
        cp      ASCII_SPC+1             ; ASCII space or below?
        jr      c,      +               ; stop when reaching whitespace
        ld      [DE],   A               ; append byte
        inc     E                       ; space for next digit
        djnz    -                       ; decrement B, loop until 0
        ;-----------------------------------------------------------------------
        ; if a 5th byte was read that wasn't whitespace,
        ; it's an error -- the number is too long!
        jp      errHex

        ;-----------------------------------------------------------------------
+       ld      DE,     [temp]          ; go back to the start of the number

        ; number of digits in hex number is reversed;
        ; B=1 for 4 digits, B=2 for 3 digits, B=3 for 2 digits and B=4 for 1
        ;
        dec     B                       ; 4 digits?
        jr      z,      @four
        dec     B                       ; 3 digits?
        jr      z,      @three
        dec     B                       ; 2 digits?
        jr      z,      @two
        dec     B                       ; 1 digit?
        jr      z,      @one

        ; if there were _no_ digits after the hexadecimal
        ; sigil ("$") then B was 5 and we error
        jp      errHex

        ; four-digit hex number:
        ;-----------------------------------------------------------------------
        ; a 4th digit must go in the upper nybble of B:
        ;
@four:  call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      B,      A               ; answer goes in B
        inc     E                       ; move to 3rd digit
        ;-----------------------------------------------------------------------
        ; a 3rd digit goes in the lower nybble of B:
        ;
@three: call    @digit                  ; convert digit to number
        or      B                       ; combine with hi-nybble (if present)
        ld      B,      A               ; answer goes in B
        inc     E                       ; move to 2nd digit
        ;-----------------------------------------------------------------------
        ; a 2nd digit goes in the upper nybble of C:
        ;
@two:   call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      C,      A               ; answer goes in C
        inc     E                       ; move to 1st digit
        ;-----------------------------------------------------------------------
        ; 1st digit goes in the lower nybble of C:
        ;
@one:   call    @digit                  ; convert digit to number
        or      C                       ; combine with hi-nybble (if present)
        ld      C,      A               ; answer goes in C

        ret                             ; ship it!

        ; convert a digit to a number:
        ;=======================================================================
        ; whitespace must already be precluded. err if not hex-digit
        ;
        ; valid hex digit?
        ;
        ; if we unset bit 5 then ASCII "a"-"f" ($61-) becomes "A"-"F" ($41-)
        ; without also altering existing uppercase letters. This also has the
        ; side-effect of changing ASCII "0"-"9" ($30-$39) to codes $10-$19!
        ; (this is why ASCII codes 0-32 must be precluded beforehand)
        ;
@digit: ld      A,      [DE]            ; get digit
        res     5,      A               ; force upper-case for "a"-"f"

        ; by subtracting $41 ("A"), "A" = 0 & "F" = 5 with everything else,
        ; including "0"-"9", being 'above' this (negative is >=128)
        ;
        sub     $41                     ; rebase to "A"
        cp      6                       ; check for "A"-"F"
        jr      c,      +               ; if "A"-"F", exit

        ; having eliminated characters above "F", shift the axis right
        ; so that "0" is at 0. any character below "0" will be negative
        add     $31
        cp      10                      ; check for 0-9
        ret     c                       ; (conditional RET first is slightly
        jp      errHex                  ;  faster than conditional JP first)

+       add     10                      ; change "A"-"F" to 10-15
        ret


printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  A, BC           (clobbered)
;-------------------------------------------------------------------------------
        call    getHexByte
        ld      A,      B
        call    osPrintChar
        ld      A,      C
        jp      osPrintChar

getHexByte:
;===============================================================================
; convert a byte into two ASCII hexadecimal digits:
;
; in:   A               input byte
; out:  BC              ASCII hex digits in hi,lo (printable) order
;       DE|HL|IX/Y      (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      B,      A               ; preserve for 2nd digit
        rra                             ;
        rra                             ; shift upper nybble down
        rra                             ;
        rra                             ;
        call    @digit                  ; convert to ASCII
        ld      A,      B               ; retrieve 2nd digit
        ld      B,      C               ; set upper ASCII digit

        ; fallthrough to convert 2nd digit
        ; ...

        ; NOTE: multiple online sources cite this method,
        ;       dating back to at least the 70s!
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic!
        daa                             ; adjust to decimal
        adc     $40                     ; more magic!
        daa                             ; adjust to decimal
        ld      C,      A
        ret
.ENDB

; * * *   O B J E C T   C O D E   * * *
;===============================================================================
; this is where the assembled code will be placed;
; anything beyond this point will be overwritten
;
code:
;-------------------------------------------------------------------------------
        .ADDR __code                    ; pointer to current position

__code: ; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

;///////////////////////////////////////////////////////////////////////////////

;readWord:
;===============================================================================
; reads a word into a buffer:
;
; NOTE: an error occurs if a word is > WORD_LEN chars long.
;       this routine doesn't handle strings
;
; TODO: needs to return the state of the last char read,
;       i.e. zero-flag for newline/EOF
;
; in:   A               first character of word already read
; out:  BC              length of word
;       HL              (preserved)
;       DE              (clobbered)
;-------------------------------------------------------------------------------
;        ; note that the word is written *downwards* in RAM, to match how
;        ; symbol names are written on the heap, for faster comparison --
;        ; we use the bottom of the stack to hold the incoming word;
;        ; because this is page-aligned we can get away with using
;        ; `DEC E` instead of `DEC DE`
;        ;
;        ld      DE,     [word]          ; top of word-buffer, e.g $FC1F
;        jr      +                       ; (first character already read)
;        ;----------------------------------------------------------------------
;-       call    readChar                ; read char from input file
;        cp      ASCII_SPC+1             ; whitespace?
;        jr      c,      @ok             ; (leave loop at whitespace)
;+       dec     E                       ; move to next space in buffer
;        ld      [DE],   A               ; add the character to the buffer
;        jp      p,      -               ; keep going until buffer full
;        ;----------------------------------------------------------------------
;        jp      errWord                 ; word too long!
;
;        ;----------------------------------------------------------------------
;@ok:    ld      A,      WORD_LEN        ; max size - characters remaining
;        sub     E                       ;  = length of word
;        ld      E,      WORD_LEN+1      ; snap back to length byte
;        ld      [DE],   A               ; write word-length byte
;
;        ld      C,      A               ; return word-length in BC,
;        ld      B,      0               ;  convenient for `findSymbol` etc.
;
;        ret

;findSymbol:
;===============================================================================
; search for a symbol (label / constant) in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;       BC              length of symbol name; `readWord` provides this --
;                       despite names being limited to 30 chars, B must be 0
;       [word]          the label is assumed to be in the word-buffer,
;                       i.e. after calling `readWord`
;
; out:  A               non-zero if found. 0 if symbol not found, including
;                       forward-references that don't have a valid value yet
;       zf              zero-flag is set according to the above
;       cf              carry set indciates the symbol is a forward-reference
;       BC              if symbol found, BC holds its value
;                       if symbol doesn't exist, **BC retains the name length**
;                       if symbol is a forward-reference (carry-set), then BC
;                       is the addr of the flag byte of the symbol record --
;                       this is so that the symbol value can be updated
;       DE              $0000 if label doesn't exist. if the label exists,
;                       inlcuding forward-references that would otherwise
;                       behave as "not found", HL contains the addr of the
;                       symbol record, pointing to the lo-byte of the link field
;       HL              (preserved)
;-------------------------------------------------------------------------------
;        push    HL                      ; preserve HL coming in
;        ex      DE,     HL              ; swap entry point to HL
;        ld      DE,     [word]          ; initialise addr of word-buffer
;        call    _findSymbol             ; jump into the main loop
;        pop     HL                      ; restore HL from caller
;        ret
;
;        ;======================================================================
;        ; names do not match!
;        ;
;--      ld      E,      WORD_LEN+1      ; snap back to length byte in buffer
;        pop     HL                      ; snap back to length byte in symbol
;        ld      C,      [HL]            ; re-get word-length to check
;-       inc     HL                      ; move *up* to link addr lo-byte
;
;_findSymbol:
;        ;----------------------------------------------------------------------
;        ; the link field of a symbol points to      - - -+------+
;        ; the lo-byte of the next symbol's link          | link |
;        ; field in the chain, with the remaining    - - -+--|---+
;        ; fields extending *downwards* in RAM            .--'
;        ;                                                v
;        ;          +-------+---+---+---+---+---+---+-----+------+
;        ;  < heap  | value | l | e | b | a | l | : | len | link |
;        ;          +-------+---+---+---+---+---+---+-----+------+
;        ;
;        ; follow this link, but exit if it's $0000
;        ; (also setting the zero-flag and clearing carry
;        ;  -- did you know that OR cleared carry!??)
;        ;
;        ld      A,      [HL]            ; read next symbol addr, lo-byte
;        inc     HL                      ; move *up* to link addr hi-byte
;        ld      H,      [HL]            ; read next symbol addr, hi-byte
;        ld      L,      A               ; (complete the addr)
;        or      H                       ; is the link addr $0000?
;        jr      z,      @end            ; terminate at end of chain
;
;        ; (HL is now the next symbol addr in the heap)
;
;        dec     HL                      ; move down to length byte
;        ld      A,      [HL]            ; get symbol name length
;        cp      C                       ; compare with word-buffer length
;        jr      nz,      -              ; different? return to link and follow
;
;        ;----------------------------------------------------------------------
;        ; symbol length matches, check characters:
;        ;
;        ; remember this position to snap back to if the symbol doesn't
;        ; match and we need to follow the link to the next symbol
;        push    HL
;
;        dec     HL                      ; move down a character in the heap
;@loop:  dec     E                       ; move down a character in word-buffer
;        ld      A,      [DE]            ; read char from word-buffer
;        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
;        jr      nz,     --              ; stop looping if mismatch
;        jp      pe,     @loop           ; keep looping until chars run out
;
;        ; names match! read and return the symbol value:
;        ;----------------------------------------------------------------------
;        ; the flag byte is used to indicate a forward-reference on a label;
;        ; the label name is known, but doesn't have a value yet. we return
;        ; this flag in the carry flag by shifting it out of the byte
;        ;
;        ; for a deferred value the byte is 0; the shift keeps this as zero,
;        ; sets zero-flag and CCF sets the carry flag accordingly. for a valid
;        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
;        ; zero flag and CCF clears the carry
;        ;
;        ; NOTE: CPD has already decremented HL for us!
;        ld      A,      [HL]            ; read forward-reference flag byte
;        rrca                            ; shift bit 0 into bit 7 AND carry!
;        ccf                             ; flip carry so forward-reference = 1
;
;        ; for a forward-reference, BC returns the address of
;        ; the flag-byte so that the label's true value can be set
;        ;
;        ; (it's faster to just do these two instructions
;        ;  in all cases and jump on the less-likely case)
;        ;
;        ld      B,      H               ; copy current heap addr
;        ld      C,      L               ;  to BC
;        jr      c,      +               ; skip value for forward-reference
;
;        ; get the label's value:
;        ;
;        dec     HL                      ; step past flag byte
;        ld      B,      [HL]            ; symbol value hi-byte
;        dec     HL                      ; move to value lo-byte
;        ld      C,      [HL]            ; return BC = symbol value
;
;        ; return the address of the symbol:
;+       pop     HL                      ; snap back to the symbol-len field
;        inc     HL                      ; move *up* to link addr lo-byte
;@end    ex      DE,     HL              ; swap symbol addr to DE
;
;        ret

;deferExpr:
;===============================================================================
; push an expression to the heap:
;
; - the link addr to the previous expression
; - the current code-segment address
; - the current virtual program-counter
;   (in case of relative jump)
; - the current line number in the input file
; - the current column number in the input file
;   (in case of error)
; - the size of the output; 1 or 2 bytes
; - the addr of the expr tokens
;
; in:   HL              current heap position
;       IX              virtual program-counter
;
; out:  HL              updated heap position (defer record added to heap)
;       DE              updated code-segment addr (expr result space reserved)
;       IX              updated virtual program-counter (as with DE)
;       A, BC           (clobbered)
;-------------------------------------------------------------------------------
;        ld      DE,     [code]          ; retrieve current code-segment addr
;
;        ; we need to push a bunch of values to the heap and the fastest way
;        ; to write 16-bit values easily is... the stack! simply make the heap
;        ; into the stack and we can PUSH our stuff on to it!
;        ;
;        ; WE DO NOT NEED TO DISABLE INTERRUPTS!!! any interrupt is going to
;        ; push to our heap and then pop the address off when it returns,
;        ; which has no affect on the values we're pushing
;        ;
;        ld      [sp],   SP              ; backup stack pointer
;        ld      SP,     HL              ; move stack to heap!
;        ;----------------------------------------------------------------------
;
;        ; link this expression to the previous one:
;        ; (since the heap address is in SP, we can reuse HL)
;        ;
;        ld      HL,     [defer]         ; get previous deferred expr address
;        push    HL                      ; write to heap
;        ld      [defer],SP              ; write heap addr to the entry point!
;
;        ; push the current code-segment position; this is where
;        ; the expression result will be filled in after evaluation
;        push    DE
;
;        ; push the current virtual program-counter
;        ; (for calculating relative jumps)
;        push    IX                      ; PC is always stored in IX, not RAM
;
;        ; push the source file line-number
;        ld      BC,     [row]
;        push    BC
;        ; push the source file column-number, plus the number of bytes
;        ; the result should occupy in the code-segment
;        ld      BC,     [stride_col]
;        push    BC
;
;        ; reserve bytes for the expr result:
;        ;
;        ; this routine is only called if there is a parameter, which assumes
;        ; a minimum of 1 byte, so check for a second byte
;        ;
;        dec     C                       ; is the stride 1 or 2?
;        jr      z,      +               ; if it is 1, skip the 2nd byte
;        inc     DE                      ; reserve a byte and increment
;        inc     IX                      ;  virtual program-counter
;+       inc     DE                      ; reserve an additional byte
;        inc     IX                      ;  and increment program-counter
;        ld      [code], DE              ; write back updated code-segment addr
;
;        ;----------------------------------------------------------------------
;        ld      HL,     0               ; there is no `LD HL, SP` (!?), so
;        add     HL,     SP              ;  it's quicker to just add SP to 0!
;        ld      SP,     [sp]            ; restore stack pointer!
;
;        ; TODO: copy bytecode expr from below the stack
;
;        ld      DE,     [code]
;        ret