; v80, (C) Kroc Camen 2023-2024, MIT License
; a z80 assembler for Z80s
;
.DEF    DEBUG

.INC    "cpm.wla"                       ; CP/M interface
.INC    "err.wla"                       ; error message handling

; syntax:
;
.DEF    CHAR_END         0              ; general terminator
.DEF    CHAR_COMMENT    ';'             ; comment
.DEF    CHAR_KEYWORD    '.'             ; keyword
.DEF    CHAR_HEX        '$'             ; hexadecimal literal or PC
.DEF    CHAR_LABEL      ':'             ; a label (16-bit)
.DEF    CHAR_CONST      '#'             ; a constant (flexible size)
.DEF    CHAR_OP_LO      '<'             ; lo-byte unary operator
.DEF    CHAR_OP_HI      '>'             ; hi-byte unary operator
.DEF    CHAR_OP_NOT     '!'             ; not unary operator
.DEF    CHAR_OP_ADD     '+'             ; add operator
.DEF    CHAR_OP_SUB     '-'             ; subtract operator
.DEF    CHAR_OP_MUL     '*'             ; multiply operator
.DEF    CHAR_OP_DIV     '/'             ; divide operator
.DEF    CHAR_OP_AND     '&'             ; and operator
.DEF    CHAR_OP_OR      '|'             ; or operator
.DEF    CHAR_OP_XOR     '^'             ; xor operator
.DEF    CHAR_OP_MOD     '\'             ; modulo operator

.INC    "expr.wla"                      ; expression parsing and evaluation
.INC    "z80.wla"                       ; Z80 parser & opcode binary tree

.BLOCK  "code"
;===============================================================================
; memory map:
;
;   +-----+-----------------------------------+--------+--------+---------+
;   | v80 | code->                     <-heap | <-word | <-expr | <-stack |
;   +-----+-----------------------------------+--------+--------+---------+
;                                                 32       96       128
;   code:  source code is assembled here
;   heap:  symbols and other in-flight data goes here (builds downwards)
;   word:  a buffer for capturing words (symbol names)
;   expr:  expressions are tokenised here (builds downwards)
;   stack: usual Z80 stack (builds downwards)
;
.DEF    WORD_LEN        31              ; maximum symbol name length

; the bottom of the word buffer, just above the heap, can be used
; as temporary space for a few bytes (so their use can't overlap)
;
; (these addresses are set during initialisation,
;  the values here are only examples based on RunCPM)
;
temp:   .ADDR $fc00                     ; temp bytes at bottom of stack
word:   .ADDR $fc1f                     ; word-buffer (works backwards)
sp:     .ADDR $fd00                     ; stack pointer backup

char:   .BYTE $00                       ; current input character

; NOTE: these two bytes are specifically grouped together because they
;       are required by deferred expressions written to the heap,
;       and are pushed together as a single word
stride_col:
stride: .BYTE $00                       ; number of bytes to occupy
col:    .BYTE $00                       ; current column-number in file
row:    .WORD $0000                     ; current line-number in file

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred expressions
; will be built up on the heap. it works downwards from the top of memory
; in order to maximise the available space before the assembled binary
; and heap collide. during initialisation the heap will be placed 256 bytes
; below the stack at the top of memory, giving enough room for the stack
;
; like the stack, the heap is pre-decrement meaning that the heap address
; is decremented first before writing a value, ergo the heap addr points
; to a currently occupied byte on the heap
;
heap:   .ADDR $fc00                     ; current position on the heap

; dictionaries:
;-------------------------------------------------------------------------------
; labels and constants are stored as a linked-list of dictionary entries.
; each has its own entry point to avoid wasting time searching for labels
; amongst constants and vice-versa. $0000 terminates the list
;
; although the heap extends downwards, the link address has to point to
; the lo-byte of the entry's link field which is technically the 2nd byte
; of the record
;                     +------+
;          .----------+ addr |  (entry point)
;          V          +------+
; - - -----+------+
;  ...data | addr |             (heap extends downwards)
; - - -----+------+
;
label:  .ADDR $000                      ; addr of last label dictionary-entry
const:  .ADDR $000                      ; addr of last const dictionary-entry


init:
;===============================================================================
        ; initialise addresses:
        ;-----------------------------------------------------------------------
        ; this *assumes* the stack is completely empty,
        ; i.e. at $FD00 rather than $FCFE
        ;
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FD00
        dec     H                       ; go down a page e.g. $FD00 > $FC00
        ld      [temp], HL              ; use bottom of stack for temp bytes
        ld      [heap], HL              ; this will also be the top of the heap
        ld      L,      WORD_LEN        ; max word-length for word buffer,
        ld      [word], HL              ;  (word buffer works downwards)
        ld      L,      $7f             ; the expr token space starts in the
        ld      [expr], HL              ;  middle of the page and works down

        ; the virtual program-counter is permanently pinned to IX since
        ; it's a value that needs to be incremented often but not read
        ; back too often. this avoids a bunch of HL/DE register swapping
        ;
        ld      IX,     $0100           ; virtual program-counter

        ; the code-segement address (where assembled binary code goes)
        ; is pinned to IY. as with the virtual program-counter, depsite
        ; the IY register being slower to utilise, it is used sparingly
        ; and avoids costly register swapping
        ;
        ld      IY,     code            ; code-segement address

        call    memStat                 ; print the memory status

        ; assemble the file
        ;-----------------------------------------------------------------------
        call    assembleFile
        ;-----------------------------------------------------------------------

        ld      [heap], HL
        call    memStat
        jp      osQuit                  ; return to CP/M to quit the program


memStat:
;===============================================================================
; prints memory status:
;-------------------------------------------------------------------------------
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ex      DE,     HL              ; swap SP into DE
        ld      HL,     @stack          ; stack addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [heap]
        ld      HL,     @heap           ; heap addr position in string
        call    @hex                    ; convert and insert

        ld      D,      IYH
        ld      E,      IYL
        ld      HL,     @code           ; code addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     @mem
        jp      osPrintStr

        ;-----------------------------------------------------------------------
        ; convert DE to ASCII hexadecimal digits and insert in the string
        ;
@hex:   ld      A,      D
        call    @byte
        ld      A,      E
@byte:  call    getHexByte
        ld      [HL],   B
        inc     HL
        ld      [HL],   C
        inc     HL
        ret

        ;-----------------------------------------------------------------------
@mem    .BYTE   "[stack: "
@stack  .BYTE   "0000"
        .BYTE   " | heap: "
@heap   .BYTE   "0000"
        .BYTE   " | code: "
@code   .BYTE   "0000"
        .BYTE   "]\n$"


assembleFile:
;===============================================================================
; assembles a file:
;
;-------------------------------------------------------------------------------
        ; TODO: do the file opening here so that we can do includes
        call    assemble

        ret

assemble:
;===============================================================================
; NOTE: we avoid using calls here where possible because scopes are linear
;       and we don't want to pressure the stack too much (it's small)
;-------------------------------------------------------------------------------
        ld      HL,     [heap]          ; where symbols / expressions go
        jr      @line                   ; jump into parsing loop

        ;=======================================================================
        ; define constant:
        ;-----------------------------------------------------------------------
        ; because constants can be redefined we don't search for the symbol yet
        ; -- we need the value first! get only the constant name:
        ;
@const: call    readWord                ; read symbol name into buffer
        call    nextExpr                ; try evaluate the following expression
        jp      c,      errExprConst    ; cannot contain forward-references!
        push    BC                      ; keep ahold of the const value

        ld      DE,     const           ; use constant dictionary
        call    findSymbol              ; check if constant already exists
        jr      nz,     +               ; if yes, skip to writing the value

        ; push a new constant to the heap:
        ;-----------------------------------------------------------------------
        ld      DE,     [const]         ; read prev const addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev const addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev const addr lo-byte
        ld      [const],HL              ; update entry point with heap addr

        ; push the const name:
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        ld      HL,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement DE once to adjust for this before the copy
        ;
        dec     DE                      ; adjust heap for post-decrement copy
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push const value:
+       pop     BC                      ; get back the const value to set
        ld      [HL],   B               ; because we're writing downwards
        dec     HL                      ;  in RAM, write value hi-byte first
        ld      [HL],   C               ;  followed by value lo-byte

        ; only one constant can be defined per line
        jr      @line

        ;=======================================================================
        ; define label:
        ;-----------------------------------------------------------------------
@label: call    getLabel                ; read label name and search for it

        ; if the label has been referenced in an expression, but not yet
        ; defined, carry will be set. in this case we want to 'fill in the
        ; blank' so that deferred expressions using this label can be evaluated
        ;
        jr      c,      +               ; does it exist as a forward-reference?
        
        ; zero-flag will be set if the label either does not exist at all,
        ; or was a forward-reference (we've eliminated forward-references
        ; first), therefore if the label *does* exist we're trying to
        ; define a label twice!
        ;
        jp      nz,     errLabelRedef   ; cannot redefine labels!

        call    pushLabel               ; define new label on the heap
        jr      @next                   ; return to parsing

        ;-----------------------------------------------------------------------
        ; when a label has been referred to in an expression in the past,
        ; a placeholder is added to the dictionary awaiting definition --
        ; now that time has come. `getLabel` has returned the addr (DE)
        ; of the last byte of the label record so we can walk up the
        ; bytes and patch in the new value
        ;
+       ld      A,      IXL             ; virtual program-counter, lo-byte
        ld      [DE],   A
        inc     DE                      ; move upwards to value hi-byte
        ld      A,      IXH             ; virtual program-counter, hi-byte
        ld      [DE],   A
        inc     DE                      ; move upwards to flag-byte
        ld      A,      1               ; set flag byte to indicate valid value
        ld      [DE],   A

        jr      @next                   ; return to parsing

        ;=======================================================================
        ; distinguish between newline and end-of-file:
        ;-----------------------------------------------------------------------
        ; readChar returns zero-flag set for both newline and end-of-file,
        ; check the ASCII code to differntiate the two
        ;
@nleof: cp      ASCII_LF                ; check for newline
        ret     nz                      ; no? end-of-file -- end assembling

        ; at newline fallthrough to
        ; the line-starting context
        ; ...

        ; line context:
        ;=======================================================================
        ; at the beginning of the line labels, constants and
        ; the program-counter can be defined, but nowhere else
        ;
@line:  call    nextWord                ; find first character
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ; first character determines the word type:
        ;
        cp      CHAR_LABEL              ; is label?
        jr      z,      @label          ; define a label
        cp      CHAR_CONST              ; is constant?
        jr      z,      @const          ; define a constant

        ; a hexadecimal number at the start of a line
        ; defines the virtual program-counter
        ;
        cp      CHAR_HEX                ; hexadecimal literal?
        jr      nz,     @body           ; if not, skip to body context

        ; set the virtual program-counter:
        ;-----------------------------------------------------------------------
        ; there is no "org" statement to set the program counter as with other
        ; assemblers; if a line begins with a hexadecimal number the virtual
        ; program-counter is set to that value, e.g.
        ;
        ;       $c000   ; PC is now $c000
        ;
        ; to set the virtual program-counter using an expression,
        ; begin the line with a lone `$` followed by the expression, e.g.
        ;
        ;       $       #boot + $0100   ; set PC to #boot constant + 256
        ;
@pc:    call    parseHexNumber          ; capture the number
        call    c,      nextExpr        ; if PC, parse the expr that follows
        jp      c,      errExprConst    ; must be a constant expr!

        ld      IXL,    C               ; change the virtual program-counter
        ld      IXH,    B               ;  to the number given

        ; fallthrough to check for following statements
        ;
        ; TODO: we should probably allow a label following the PC,
        ;       e.g.
        ;               $c000   :label  ret
        ; ...

        ; body context:
        ;=======================================================================
        ; labels and the program-counter must be defined first on the line and
        ; after those, instructions and keywords are allowed. this is known as
        ; the body context and multiple instructions / keywords can occur until
        ; either a comment or the end of the line
        ;
        ; after a keyword or instruction, parsing returns to the body context
        ; unless a newline is encountered. in cases where the last-read char
        ; is whitespace, we need to pickup the next character:
        ;
@next:  ld      A,      [char]          ; last read character
        cp      ASCII_SPC               ; ASCII<32 = newline (or end-of-file)?
        jr      c,      @nleof          ; switch to line context
        call    z,      nextWord        ; SPC = find next char (or newline)
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ;-----------------------------------------------------------------------
@body:  cp      CHAR_KEYWORD            ; is this a keyword?
        jr      z,      @key

        call    parseInstruction        ; if not, must be an instruction

        jr      @next

        ; keywords:
        ;-----------------------------------------------------------------------
@key:   call    readChar                ; get next char after the "."
        jp      z,      errKeyword      ; no letter follows!?
        ld      C,      A               ; hold char to check next char first
        call    readChar                ; get 2nd char
        cp      ASCII_SPC               ; whitespace must follow!
        jp      nz,     errKeyword      ; (i.e. no additional chars)

        ld      A,      C               ; return to first char
        res     5,      A               ; force upper-case for "a"-"z"
        cp      'B'                     ; `.b` keyword?
        jr      z,      @b              ; process bytes
        cp      'W'                     ; `.w' keyword?
        jp      nz,     errKeyword      ; none of the above? invalid keyword!

        ; (fallthrough to handle words)
        ; ...

        ;-----------------------------------------------------------------------
        ; words:
        ;-----------------------------------------------------------------------
@w:     ld      A,              2       ; set the stride to 2 (words)
        jr      +                       ; TODO: use a skip opcode here
        ;-----------------------------------------------------------------------
        ; bytes:
        ;-----------------------------------------------------------------------
@b:     ld      A,              1       ; set the stride to 1 (bytes)
+       ld      [stride],       A

        ; parse expression and output to code-segment. deferred
        ; expressions will automatically be pushed to the heap
-       call    nextParam

        ; the last character read by expression parsing will be either EOL/EOF,
        ; where the line ends without any further expressions, or the fist char
        ; of the following word which may or not be an expression
        ;
        ld      A,      [char]          ; last character read
        cp      ASCII_SPC+1             ; any non-visible char must be EOL/EOF
        jr      c,      @nleof          ; EOL/EOF is always end of keyword
        cp      CHAR_HEX                ; a hexadecimal literal / PC?
        jr      z,      -               ; ...
        cp      CHAR_LABEL              ; a label?
        jr      z,      -               ; ...
        cp      CHAR_CONST              ; a constant?
        jr      z,      -               ; ...
        cp      CHAR_OP_LO              ; the lo-byte unary operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_HI              ; the hi-byte unary operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_NOT             ; the not unary operator?
        jr      z,      -               ; ...

        ; a word follows, but it's not an expression
        ; (instructions or another keyword can follow a keyword)
        jr      @next


nextWord:
;===============================================================================
; reads input and skips spaces until either:
;
; - the next non-terminating character
; - a newline or end-of-line character
; - a comment
;
; in the case of a comment, the comment text is skipped over and the next
; newline / end-of-file is returned instead! therefore this routine
; MUST NOT be used to skip over whitespace in string literals etc.
;
; WARN: this routine will return on newline and that there may be more leading
; whitespace on the next line -- if you want to skip to the next non-whitespace
; character, call the routine again after a newline!
;
; out:  A               ASCII code, 0 = end-of-file
;       zf              zero-flag is set for "no word", i.e. when the line
;                       ends before another valid word. check A for newline
;                       or end-of-file (0) to differentiate those
;-------------------------------------------------------------------------------
-       call    readChar                ; read a character (returns z-flag)
        ret     z                       ; return z-flag set if newline/EOF

        ; we need to be careful not to wrongly return z-flag set!
        ;
        ; we cannot check for ASCII_SPC+1 ("!") as if this character appears,
        ; the parser will think the file ended. instead look for space itself
        ; -- for any ASCII code below we continue looping, and space itself
        ; is caught with the zero-flag and re-looped
        ; 
        cp      ASCII_SPC               ; is ASCII code a space?
        jr      c,      -               ; keep reading if codes 1-31
        jr      z,      -               ; also, keep reading if space

        cp      CHAR_COMMENT            ; is this the start of a comment?
        jr      z,      @skip           ; if so, skip chars until end

        ret

        ;-----------------------------------------------------------------------
        ; skip over a comment until the newline / end-of-line:
        ;
@skip:  call    readChar                ; read a character (returns z-flag)
        jr      nz,     @skip           ; read until newline / end-of-file
        
        ret

readChar:
;===============================================================================
; reads the next character in the file:
; current row and column are maintained
;
; out:  A               ASCII code. 0 = end-of-file
;       zf              zero-flag is set *both* for end-of-file and newline!
;       [char]          the character is also written to RAM
;       DE, HL          (preserved)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        call    osPrintChar             ; print each character as we receive it
        pop     AF                      ; (zero-flag must be preserved)
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        ret     z                       ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      z,      @row            ; handle newline
        cp      ASCII_TAB               ; /t is tab
        jr      z,      @tab            ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; WARN: we do not cap the column number -- keep lines to 80 cols!
        ;       when a line exceeds 255 chars, the 256th character will
        ;       be treated as end-of-file!
        ;
@col:   inc     [HL']
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
@row:   ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
@tab:   dec     A                       ; \t = 9, so change to 8 (width of tab)
        add     [HL']                   ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        ld      [HL'],  A               ; update column number
        ld      A,      ASCII_SPC       ; return a single space instead
        ld      [char], A               ; update retained value to match

        exx                             ; restore HL/DE
        ret


readWord:
;===============================================================================
; read symbol name:
;
; NOTE: the word is written *downwards* in RAM, to match how symbol names are
;       written on the heap, for faster comparison -- we use the bottom of
;       a page to hold the incoming word so that we can get away with using
;       `DEC E` instead of `DEC DE`
; 
; out:  A               length of word
;       DE              DE is set to the first byte (length) of `[word]`
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ld      DE,     [word]          ; top of word-buffer, e.g $FC1F
        jr      +                       ; (first character already read)
        ;-----------------------------------------------------------------------
-       call    readChar                ; read char from input file
        cp      ASCII_SPC+1             ; whitespace?
        jr      c,      @ok             ; (leave loop at whitespace)
+       dec     E                       ; move to next space in buffer
        ld      [DE],   A               ; add the character to the buffer
        jp      p,      -               ; keep going until buffer full
        ;-----------------------------------------------------------------------
        jp      errWord                 ; word too long!

        ;-----------------------------------------------------------------------
@ok:    ld      A,      WORD_LEN        ; max size - characters remaining
        sub     E                       ;  = length of word
        ld      E,      WORD_LEN        ; snap back to length byte
        ld      [DE],   A               ; write word-length byte
        ld      C,      A               ; copy word-length into BC
        ld      B,      0               ; 

        ret


getConst:
;===============================================================================
; reads a constant name from input and searches the const dictionary for it:
;
; out:  A               non-zero if found. 0 if constant not found
;       zf              zero-flag is set according to the above
;       BC              if const found, BC holds its value
;                       if const doesn't exist, **BC retains the name length**
;       DE              addr of the last byte in the const record,
;                       i.e. the lo-byte of the const value
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read const name into word buffer
        ld      DE,     const           ; use the constant dictionary entry
        call    findSymbol              ; search for the const in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; constant found, return value:
        ;-----------------------------------------------------------------------
        ; the address of the last byte of the const record is returned in DE.
        ; when we want to redefine a constant we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | t | s | n | o | c | # | len | link |
        ;          +---------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; constant value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = constant value
        ex      DE,     HL              ; return DE = last addr

        ; (note that DEC HL will have cleared the zero-flag
        ;  as a constant could never end on address $0000)
        ;
        ret


getLabel:
;===============================================================================
; reads a label name from input and searches the label dictionary for it:
;
; out:  A               non-zero if found. 0 if label not found, including
;                       forward-references that don't have a valid value yet
;       zf              zero-flag is set according to the above
;       cf              carry set indciates the label is a forward-reference
;       BC              if label found, BC holds its value
;                       if label doesn't exist, **BC retains the name length**
;       DE              if label is a forward-reference (carry-set), then DE
;                       is the addr of the lo-byte of the label value --
;                       this is so that the label value can be patched in by
;                       stepping DE forwards to the hi-byte and flag-byte
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read label name into word buffer
        ld      DE,     label           ; use the label dictionary entry
        call    findSymbol              ; search for the symbol in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; names match! read and return the symbol value:
        ;-----------------------------------------------------------------------
        ; the flag byte is used to indicate a forward-reference on a label;
        ; i.e. the label name is known, but doesn't have a value yet. we return
        ; this flag in the carry-flag by shifting it out of the byte
        ;
        ; for a deferred value the byte is 0; the shift keeps this as zero,
        ; sets zero-flag and CCF sets the carry-flag accordingly. for a valid
        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
        ; zero-flag and CCF clears the carry
        ;
        ld      A,      [DE]            ; read forward-reference flag byte
        rrca                            ; shift bit 0 into bit 7 AND carry!
        ccf                             ; flip carry so forward-reference = 1
        dec     DE                      ; step past flag byte

        ; get the label's value:
        ; (this is meaningless for a forward-reference)
        ; TODO: could we store the virtual program-counter
        ;       here, saving 2 bytes in the expr record?
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; symbol value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = symbol value

        ; the address of the last byte of the label record is returned in DE.
        ; when we need to upate the label value we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | flag | l | e | b | a | l | : | len | link |
        ;          +---------+------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; return last addr in DE
        ret


findSymbol:
;===============================================================================
; searches for a symbol in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;       [word]          the symbol name needs to already be in the word
;                       buffer, e.g. after calling `readWord`
;
; out:  A               non-zero if found. 0 if symbol not found
;       zf              zero-flag is set according to the above
;       BC              if symbol found, symbol name length is returned in BC
;       DE              $0000 if not found, otherwise an addr pointing
;                       to the byte following the symbol name (e.g. the value)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve heap addr coming in
        ld      HL,     [word]          ; start of word buffer
        ld      C,      [HL]            ; first byte is name length
        ld      B,      0               ; load this into BC
        ex      DE,     HL              ; HL = dict. addr, DE = word buffer
        jr      @next                   ; jump into the loop

        ;=======================================================================
        ; names do not match!
        ;
--      ld      A,      WORD_LEN        ; max symbol size
        sub     E                       ; - characters remaining
        ld      C,      A               ; = length of word
        add     HL,     BC              ; snap back to symbol length field
-       inc     HL                      ; move *up* to link addr lo-byte

        ;-----------------------------------------------------------------------
        ; the link field of a symbol points to      - - -+------+
        ; the lo-byte of the next symbol's link          | link |
        ; field in the chain, with the remaining    - - -+--|---+
        ; fields extending *downwards* in RAM            .--'
        ;                                                v
        ;          ---+---+---+---+---+---+---+-----+------+
        ;  < heap     | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+-----+------+
        ;
        ; follow this link, but exit if it's $0000
        ; (also setting the zero-flag and clearing carry
        ;  -- did you know that OR cleared carry!??)
        ;
@next:  ld      A,      [HL]            ; read next symbol addr, lo-byte
        inc     HL                      ; move *up* to link addr hi-byte
        ld      H,      [HL]            ; read next symbol addr, hi-byte
        ld      L,      A               ; (complete the addr)
        or      H                       ; is the link addr $0000?
        jr      z,      @end            ; terminate at end of chain

        ; (HL is now the next symbol addr in the heap)

        dec     HL                      ; move down to length byte
        ld      A,      [HL]            ; get symbol name length
        cp      C                       ; compare with word-buffer length
        jr      nz,      -              ; different? return to link and follow

        ; symbol length matches, check characters:
        ;=======================================================================
        dec     HL                      ; (skip length byte)
        ld      E,      WORD_LEN        ; start at top of word-buffer
        ;-----------------------------------------------------------------------
@char:  dec     E                       ; move down a character in word-buffer
        ld      A,      [DE]            ; read char from word-buffer
        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
        jr      nz,     --              ; stop looping if mismatch
        jp      pe,     @char           ; keep looping until chars run out
        ;-----------------------------------------------------------------------
        ; CPD ensures that HL is pointing to the byte following the symbol-name
        ; -- on a const this is the value, and for labels this is the flag-byte
        ;
        and     A                       ; A != 0, clear z-flag & carry-flag
@end:   ex      DE,     HL              ; return last addr as DE
        pop     HL                      ; restore old heap addr
        ret


pushLabel:
;===============================================================================
; push a new label to the heap:
; 
; - the link addr to the previous label
; - the label name length; here for faster searching
; - the label name, written right-to-left -- the heap extends downwards!
; - a flag to indicate a forward-reference:
;   this happens when a label that does not exist is encountered in an expr,
;   a placeholder label is added to the heap to be filled in later. this is
;   necessary for the expr to be deferred until later to reference the label
; - the label value; the current virtual program-counter
;
; WARN: does not check if the label already exists!
;
; in:   cf              carry-flag set indicates a forward-reference!
;       HL              heap position to write new label
;       BC              word-length (set by `readWord`)
;       [word]          the label is assumed to be in the word-buffer,
;                       i.e. after calling `readWord`
; out:  HL              heap position is advanced (downwards!)
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        ; link this label to the previous one:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [label]         ; read prev label addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev label addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev label addr lo-byte
        ld      [label],HL              ; update entry point with heap addr

        ; push the label name:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        ; (these instructions don't modify carry...)
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes *from* [HL] *to* [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push flag to indicate a forward-reference:
        ;
        ; the flag byte is designed so that `findSymbol` will return zero-flag
        ; set for forward-references, i.e. the label is considered undefined,
        ; but carry is set to distinguish labels that exist in the dictionary
        ; vs. those that don't (required for deferring expressions)
        ;
        ; the flag is flipped to allow some trickery on read out to return
        ; A=0 and set both zero-flag AND carry-flag for forward-references
        ;
        ; NOTE: LDDR has already decremented HL for us
        ;
        ccf                             ; forward-reference = 0, otherwise 1
        rl      B                       ; shift carry flag into bit 0
        ld      [HL],   B               ; B will be 0 or 1

        ; push the label value (virtual program-counter):
        ; if the label is a forward-reference, this value is ignored
        ;
        ; the value comes after the label name to speed up symbol searching
        ; as the value is only needed once a symbol name is matched and then
        ; the addr is in the right place
        ;
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXH
        ld      [HL],   A
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXL
        ld      [HL],   A

        ret


parseInstruction:
;===============================================================================
; parse an instruction into opcodes:
;
; the CPU-specific module (e.g. "z80.wla") provides a binary tree, `opcodes`,
; that this routine walks to match instruction names to opcodes and a CPU-
; specific set of flags that determines which parameters are required
;
; in:   A               first character of word to parse
;       HL              heap addr
; out:  HL              heap addr is advanced for any expressions deferred
;       IY              binary code is appended to the code-segement,
;       IX              and the virtual program-counter is advanced
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ex      DE,     HL              ; swap heap to DE for now
        ld      HL,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch:
        ;-----------------------------------------------------------------------
        ; once a character matches, the next two bytes are either
        ; an offset to the next branch to follow, or an opcode pair
        ;
@match: inc     HL                      ; step over the matched character
        ld      C,      [HL]            ; read the offset lo-byte / opcode-byte
        inc     HL                      ; move to next byte in tree
        ld      B,      [HL]            ; read the offset hi-byte / opcode-flags

        bit     7,      B               ; is hi-bit of hi-byte set?
        jr      nz,     @opcode         ; if so, this is an opcode

        ; add the offset to the current position to jump to the new branch:
        ; NOTE: the offset in the binary tree is reduced by 1 to compensate
        ; for adding from the hi-byte addr, rather than the lo-byte addr
        ;
        add     HL,     BC

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    readChar                ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting
        ; numbers / [most] punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
       
+       ; compare with opcode tree:
        ;-----------------------------------------------------------------------
-       cp      [HL]                    ; compare input char with tree char
        jr      z,      @match          ; characters match?

        ; if the hi-bit of the character from the opcode tree is set, it's
        ; either a continuation character (>128) or the end of a branch (=128).
        ; in these cases, the result of the compare will always be negative!
        ;
        bit     7,      [HL]            ; check bit 7 of character
        jr      nz,     @cont           ; handle continuation char / end

        ; no match; try the next character:
        ;-----------------------------------------------------------------------
        inc     HL
        inc     HL
        inc     HL
        jr      -

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch -- one character has to
        ; immediately follow another -- any mismatch is an unknown opcode
        ;
@cont:  or      %10000000               ; *add* top bit to input char
        cp      [HL]                    ; redo comparison with tree
        jp      nz,     errOpcode       ; any mismatch is an error!
        inc     HL                      ; match -- move to next char in tree
        jr      @char

        ;=======================================================================
        ; emit opcode(s):
        ;-----------------------------------------------------------------------
        ; if a branch ends in an opcode, then no more characters must follow!
        ;
@opcode and     A                       ; if the last char is already 0,
        jr      z,     +                ; then no further check is needed

        call    readChar
        cp      ASCII_SPC+1             ; is it whitespace (or eof)?
        jp      nc,     errOpcode       ; if not, invalid instruction!

+       ex      DE,     HL              ; swap heap back to HL

        ; emit the opcode and parse any necessary parameters
        ; (this routine is in the CPU-specific module, e.g. z80.wla)
        jp      emitOpcode


printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  BC              (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        push    BC                      ; preserve BC coming in
        call    getHexByte              ; convert A to hexadecimal digits B,C
        ld      A,      B               ; print hi-byte first
        call    osPrintChar
        ld      A,      C               ; print lo-byte next
        pop     BC                      ; (restore BC going out)
        jp      osPrintChar

getHexByte:
;===============================================================================
; convert a byte into two ASCII hexadecimal digits:
;
; in:   A               input byte
; out:  BC              ASCII hex digits in hi,lo (printable) order
;       DE|HL|IX/Y      (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      B,      A               ; preserve for 2nd digit
        rra                             ;
        rra                             ; shift upper nybble down
        rra                             ;
        rra                             ;
        call    @digit                  ; convert to ASCII
        ld      A,      B               ; retrieve 2nd digit
        ld      B,      C               ; set upper ASCII digit

        ; fallthrough to convert 2nd digit
        ; ...

        ; NOTE: multiple online sources cite this method,
        ;       dating back to at least the 70s!
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic!
        daa                             ; adjust to decimal
        adc     $40                     ; more magic!
        daa                             ; adjust to decimal
        ld      C,      A
        ret
.ENDB

; * * *   O B J E C T   C O D E   * * *
;===============================================================================
; this is where the assembled code will be placed;
; anything beyond this point will be overwritten
;
code:
;-------------------------------------------------------------------------------
; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

;///////////////////////////////////////////////////////////////////////////////