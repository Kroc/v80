; v80, (C) Kroc Camen 2023-2024, MIT License
; a z80 assembler for Z80s
;
; constants:
;
NULL                    = 0
LO                      = 0
HI                      = 1

ASCII_SPC               = $20           ; ASCII space (whitespace)
ASCII_TAB               = $09           ; ASCII tab (whitespace)
ASCII_CR                = $0d           ; ASCII carriage-return
ASCII_LF                = $0a           ; ASCII line-feed
ASCII_SUB               = $1a           ; ASCII "substitute", end-of-file char

; system:
;
.INC    "cpm.wla"                       ; CP/M interface
.INC    "debug.wla"                     ; debug-only functionality
.INC    "err.wla"                       ; error messages / debug printing

; syntax:
;
.DEF    CHAR_END         0              ; general terminator
.DEF    CHAR_COMMENT    ';'             ; comment
.DEF    CHAR_KEYWORD    '.'             ; keyword
.DEF    CHAR_HEX        '$'             ; hexadecimal literal or PC
.DEF    CHAR_LABEL      ':'             ; a label (16-bit)
.DEF    CHAR_CONST      '#'             ; a constant (flexible size)
.DEF    CHAR_OP_LO      '<'             ; lo-byte unary operator
.DEF    CHAR_OP_HI      '>'             ; hi-byte unary operator
.DEF    CHAR_OP_NOT     '!'             ; not unary operator
.DEF    CHAR_OP_NEG     '-'             ; negate unary operator
.DEF    CHAR_OP_ADD     '+'             ; add operator
.DEF    CHAR_OP_SUB     '-'             ; subtract operator
.DEF    CHAR_OP_MUL     '*'             ; multiply operator
.DEF    CHAR_OP_DIV     '/'             ; divide operator
.DEF    CHAR_OP_AND     '&'             ; and operator
.DEF    CHAR_OP_OR      '|'             ; or operator
.DEF    CHAR_OP_XOR     '^'             ; xor operator
.DEF    CHAR_OP_MOD     '\'             ; modulo operator

.INC    "file.wla"                      ; file input / output
.INC    "expr.wla"                      ; expression parsing and evaluation
.INC    "z80.wla"                       ; Z80 parser & opcode binary tree

.BLOCK  "code"
;===============================================================================
; memory map:
;
;   +-----+-----------------------------------+--------+--------+---------+
;   | v80 | code->                     <-heap | <-word | <-expr | <-stack |
;   +-----+-----------------------------------+--------+--------+---------+
;                                                   32       96       128
;   code:  source code is assembled here
;   heap:  symbols and other in-flight data goes here; builds downwards
;   word:  a buffer for capturing words (symbol names); builds downwards
;   expr:  expressions are tokenised here; builds downwards
;   stack: usual Z80 stack; builds downwards
;
.DEF    WORD_LEN        31              ; maximum symbol name length
.DEF    STACK_SLOTS     64              ; maximum size of stack (*2 for bytes)

; the bottom of the word buffer, just above the heap, can be used
; as temporary space for a few bytes (so their use can't overlap)
;
; (these addresses are set during initialisation,
;  the values here are only examples based on RunCPM)
;
temp:   .ADDR $fc00                     ; temp bytes at bottom of stack
word:   .ADDR $fc1f                     ; word-buffer (works backwards)
sp:     .ADDR $fd00                     ; stack pointer backup

char:   .BYTE $00                       ; current input character

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred expressions
; will be built up on the heap. it works downwards from the top of memory
; in order to maximise the available space before the assembled binary
; and heap collide. during initialisation the heap will be placed 256 bytes
; below the stack at the top of memory, giving enough room for the stack
;
; like the stack, the heap is pre-decrement meaning that the heap address
; is decremented first before writing a value, ergo the heap addr points
; to a currently occupied byte on the heap
;
heap:   .ADDR $fc00                     ; current position on the heap

; dictionaries:
;-------------------------------------------------------------------------------
; labels and constants are stored as a linked-list of dictionary entries.
; each has its own entry point to avoid wasting time searching for labels
; amongst constants and vice-versa. $0000 terminates the list
;
; although the heap extends downwards, the link address has to point to
; the lo-byte of the entry's link field which is technically the 2nd byte
; of the record
;                     +------+
;          .----------+ addr |  (entry point)
;          V          +------+
; - - -----+------+
;  ...data | addr |             (heap extends downwards)
; - - -----+------+
;
label:  .ADDR $000                      ; addr of last label dictionary-entry
const:  .ADDR $000                      ; addr of last const dictionary-entry


init:
;===============================================================================
        ; initialise addresses:
        ;-----------------------------------------------------------------------
        ; this *assumes* the stack is completely empty,
        ; i.e. at $FD00 rather than $FCFE
        ;
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FD00
        ld      [sp],   HL              ; (save value for printing later)
        dec     H                       ; go down a page e.g. $FD00 > $FC00
        ld      [temp], HL              ; use bottom of stack for temp bytes
        ld      [heap], HL              ; this will also be the top of the heap
        ld      L,      WORD_LEN        ; max word-length for word buffer,
        ld      [word], HL              ;  (word buffer works downwards)
        ld      L,  $ff-(STACK_SLOTS*2) ; the expr token space starts
        ld      [expr], HL              ;  under the stack and works down

        ; print addresses:
        ;
        ld      DE,     @addrc          ; start with "CODE @ ..."
        ld      HL,     code            ; start addr of code-segment
        call    @print                  ; print string and value
        ld      HL,     [heap]          ; start addr of heap
        call    @print                  ; print next string and value
        ld      HL,     [sp]            ; start addr of stack
        call    @print                  ; print next string and value
        ld      A,      ASCII_LF        ; print newline
        call    osPrintChar             ; ...

        ; how do you measure the maximum depth of the stack used
        ; during program execution?
        ;-----------------------------------------------------------------------
        ; you could record the stack depth every time you push, or at least
        ; often enough, but that slows down execution. rather, we can write
        ; an initial value to every stack space and after execution we can
        ; check how deep the original value remains. But what if the data
        ; puhsed to the stack happens to contain that value?
        ;
        ; the only value you can almost guarantee will never be pushed to the
        ; stack is... the address of the stack itself! For example, if the
        ; stack is at $FC80 then you won't ever see $FC80 stored there
        ; -- this is programatically useless
        ;
        ; therefore we fill each stack space with its own address and after
        ; execution check for stack positions that have changed, revealing
        ; the deepest push to the stack during execution!
        ;
        ld      [sp],   SP              ; backup stack pointer
        ld      HL,     0               ; load HL with the stack pointer
        add     HL,     SP              ; (oddly, there's no `ld HL, SP`!)
        ld      B,      STACK_SLOTS     ; number of slots allocated to stack
-       dec     HL                      ; decrement HL first to match the
        dec     HL                      ;  stack-pointer after it pushes HL
        push    HL                      ;  (stack is decrement-then-copy)
        djnz    -                       ; loop all stack pushes
        ld      SP,     [sp]            ; restore stack pointer

        ; the virtual program-counter is permanently pinned to IX since
        ; it's a value that needs to be incremented often but not read
        ; back too often. this avoids a bunch of HL/DE register swapping
        ;
        ld      IX,     $0100           ; virtual program-counter

        ; the code-segment address (where assembled binary code goes)
        ; is pinned to IY. as with the virtual program-counter, depsite
        ; the IY register being slower to utilise, it is used sparingly
        ; and avoids costly register swapping
        ;
        ld      IY,     code            ; code-segment address

        ; assemble the source file
        ;=======================================================================
        ld      HL,     [heap]          ; where symbols / expressions go
        call    assembleFile

        ; print final stats:
        ;=======================================================================
        ;
        ; +----------------+----------------------+---------------+
        ; | code-segment > |     < free RAM >     | < heap        |
        ; +----------------+----------------------+---------------+
        ; ^ code           ^ IY                   ^ HL            ^ [heap]
        ;
        ex      DE,     HL              ; put current heap address aside
        xor     A                       ; (clear carry)

        ; size of the heap:
        ; (works downwards from top of RAM)
        ;
        ld      HL,     [heap]          ; get heap starting address (high!)
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@heap],HL              ; save value for printing later

        ; free RAM size:
        ; (size between end of code-segment and end-of-heap)
        ;
        ex      DE,     HL              ; return last heap addr to HL
        push    IY                      ; swap code-segement last address
        pop     DE                      ;  into DE for SBC HL, DE
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@free],HL              ; save value for printing later

        ; size of code-segment:
        ; (size of generated binary)
        ;
        ex      DE,     HL              ; swap code end addr into HL
        ld      DE,     code            ; code-segment start addr
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@code],HL              ; save value for printing later

        ; how deep is your stack?
        ;
        ; since counting towards zero is faster on Z80 we start at the top and
        ; walk down the stack slots checking if each contains its own address
        ;
        ; WARN: this code assumes that stack is at its top (e.g. $FD00),
        ;       because this code is in the top-most init routine
        ; 
        ld      HL,     0               ; load HL with the stack pointer
        add     HL,     SP              ; (oddly, there's no `ld HL, SP`!)
        ld      BC,     STACK_SLOTS     ; begin at the top, report remaining
        ;-----------------------------------------------------------------------
-       dec     HL                      ; (decrement into hi-byte)
        ld      A,      H               ; compare hi-byte first
        cpd                             ; CP A, [HL]; DEC HL; DEC BC
        jp      po,     +               ; exit when BC = 0 (all stack checked)
        jr      nz,     -               ; skip checking lo-byte if mismatch
        ld      A,      L               ; compare lo-byte of stack addr
        cp      A,      [HL]            ;  with lo-byte in stack slot
        jr      nz,     -               ; keep looping if mismatch
        ;-----------------------------------------------------------------------
+       ld      A,      C               ; BC is number of unused stack slots
        rla                             ; * 2 for bytes
        ld      [@stack],       A       ; save value for printing later

        ; print results:
        ;
        ld      DE,     @strc           ; string to print ("CODE")
        ld      HL,     [@code]         ; value to print (code size)
        call    @size                   ; ...
        ld      DE,     @strh           ; string to print ("HEAP")
        ld      HL,     [@heap]         ; value to print (heap size)
        call    @size                   ; ...
        ld      DE,     @strf           ; string to print ("FREE")
        ld      HL,     [@free]         ; value to print (free bytes)
        call    @size                   ; ...
        ld      DE,     @strs           ; string to print ("STACK")
        call    osPrintStrZ
        ld      A,      [@stack]
        call    printHexByte
        ld      DE,     @peak
        call    osPrintStrZ

        .dumpCode                       ; DEBUG_DUMP: hex-dump the code-segment

        jp      osQuit                  ; jump to CP/M to quit the program

        ;=======================================================================
@code   .WORD   $0000                   ; size of code-segment
@free   .WORD   $0000                   ; free RAM between code and heap
@heap   .WORD   $0000                   ; size of heap
@stack  .WORD   $0000                   ; bytes stack used (peak)

        ;-----------------------------------------------------------------------
@print: call    osPrintStrZ             ; print string passed in DE
        ld      A,      H               ; print HL in hi-lo byte order
        call    printHexByte
        ld      A,      L
        jp      printHexByte

@addrc  .BYTE   "CODE @ $", 0
@addrh  .BYTE   ", HEAP @ $", 0
@addrs  .BYTE   ", STACK @ $", 0

        ;-----------------------------------------------------------------------
@size:  call    @print                  ; print string (DE) and value (HL)
        ld      DE,     @bytes          ; append " bytes"
        jp      osPrintStrZ             ;  and return

@strc   .BYTE   "\nCODE : $", 0
@strh   .BYTE   "HEAP : $", 0
@strf   .BYTE   "FREE : $", 0
@bytes  .BYTE   " bytes\n", 0
@strs   .BYTE   "STACK: $00", 0
@peak   .BYTE   " free", 0


assembleFile:
;===============================================================================
; assembles a file:
;
;-------------------------------------------------------------------------------
        ; TODO: do the file opening here so that we can do includes
        call    assemble

        ret

assemble:
;===============================================================================
; NOTE: we avoid using calls here where possible because scopes are linear
;       and we don't want to pressure the stack too much (it's small)
;-------------------------------------------------------------------------------
        jr      @line                   ; jump into parsing loop

        ;=======================================================================
        ; define constant:
        ;-----------------------------------------------------------------------
        ; because constants can be redefined we don't search for the symbol yet
        ; -- we need the value first! get only the constant name:
        ;
@const: call    readWord                ; read symbol name into buffer
        call    nextExpr                ; try evaluate the following expression
        jp      c,      errExprConst    ; cannot contain forward-references!
        push    BC                      ; keep ahold of the const value

        ld      DE,     const           ; use constant dictionary
        call    findSymbol              ; check if constant already exists
        jr      nz,     +               ; if yes, skip to writing the value

        ; push a new constant to the heap:
        ;-----------------------------------------------------------------------
        ld      DE,     [const]         ; read prev const addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev const addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev const addr lo-byte
        ld      [const],HL              ; update entry point with heap addr

        ; push the const name:
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        ld      HL,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement DE once to adjust for this before the copy
        ;
        dec     DE                      ; adjust heap for post-decrement copy
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push const value:
+       pop     BC                      ; get back the const value to set
        ld      [HL],   B               ; because we're writing downwards
        dec     HL                      ;  in RAM, write value hi-byte first
        ld      [HL],   C               ;  followed by value lo-byte

        ; only one constant can be defined per line
        jr      @line

        ;=======================================================================
        ; define label:
        ;-----------------------------------------------------------------------
@label: call    getLabel                ; read label name and search for it

        ; if the label has been referenced in an expression, but not yet
        ; defined, carry will be set. in this case we want to 'fill in the
        ; blank' so that deferred expressions using this label can be evaluated
        ;
        jr      c,      +               ; does it exist as a forward-reference?
        
        ; zero-flag will be set if the label either does not exist at all,
        ; or was a forward-reference (we've eliminated forward-references
        ; first), therefore if the label *does* exist we're trying to
        ; define a label twice!
        ;
        jp      nz,     errLabelRedef   ; cannot redefine labels!

        call    pushLabel               ; define new label on the heap
        jr      @next                   ; return to parsing

        ;-----------------------------------------------------------------------
        ; when a label has been referred to in an expression in the past,
        ; a placeholder is added to the dictionary awaiting definition --
        ; now that time has come. `getLabel` has returned the addr (DE)
        ; of the last byte of the label record so we can walk up the
        ; bytes and patch in the new value
        ;
+       ld      A,      IXL             ; virtual program-counter, lo-byte
        ld      [DE],   A
        inc     DE                      ; move upwards to value hi-byte
        ld      A,      IXH             ; virtual program-counter, hi-byte
        ld      [DE],   A
        inc     DE                      ; move upwards to flag-byte
        ld      A,      1               ; set flag byte to indicate valid value
        ld      [DE],   A

        jr      @next                   ; return to parsing

        ;=======================================================================
        ; distinguish between newline and end-of-file:
        ;-----------------------------------------------------------------------
        ; readChar returns zero-flag set for both newline and end-of-file,
        ; check the ASCII code to differntiate the two
        ;
@nleof: cp      ASCII_LF                ; check for newline
        ret     nz                      ; no? end-of-file -- end assembling

        ; at newline fallthrough to
        ; the line-starting context
        ; ...

        ; line context:
        ;=======================================================================
        ; at the beginning of the line labels, constants and
        ; the program-counter can be defined, but nowhere else
        ;
@line:  call    nextWord                ; find first character
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ; first character determines the word type:
        ;
        cp      CHAR_LABEL              ; is label?
        jr      z,      @label          ; define a label
        cp      CHAR_CONST              ; is constant?
        jr      z,      @const          ; define a constant

        ; a hexadecimal number at the start of a line
        ; defines the virtual program-counter
        ;
        cp      CHAR_HEX                ; hexadecimal literal?
        jr      nz,     @body           ; if not, skip to body context

        ; set the virtual program-counter:
        ;-----------------------------------------------------------------------
        ; there is no "org" statement to set the program counter as with other
        ; assemblers; if a line begins with a hexadecimal number the virtual
        ; program-counter is set to that value, e.g.
        ;
        ;       $c000   ; PC is now $c000
        ;
        ; to set the virtual program-counter using an expression,
        ; begin the line with a lone `$` followed by the expression, e.g.
        ;
        ;       $       #boot + $0100   ; set PC to #boot constant + 256
        ;
@pc:    call    parseHexNumber          ; capture the number
        call    c,      nextExpr        ; if PC, parse the expr that follows
        jp      c,      errExprConst    ; must be a constant expr!

        ld      IXL,    C               ; change the virtual program-counter
        ld      IXH,    B               ;  to the number given

        ; fallthrough to check for following statements
        ;
        ; TODO: we should probably allow a label following the PC,
        ;       e.g.
        ;               $c000   :label  ret
        ; ...

        ; body context:
        ;=======================================================================
        ; labels and the program-counter must be defined first on the line and
        ; after those, instructions and keywords are allowed. this is known as
        ; the body context and multiple instructions / keywords can occur until
        ; either a comment or the end of the line
        ;
        ; after a keyword or instruction, parsing returns to the body context
        ; unless a newline is encountered. in cases where the last-read char
        ; is whitespace, we need to pickup the next character:
        ;
@next:  ld      A,      [char]          ; last read character
        cp      ASCII_SPC               ; ASCII<32 = newline (or end-of-file)?
        jr      c,      @nleof          ; switch to line context
        call    z,      nextWord        ; SPC = find next char (or newline)
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ;-----------------------------------------------------------------------
@body:  cp      CHAR_KEYWORD            ; is this a keyword?
        jr      z,      @key

        call    parseInstruction        ; if not, must be an instruction

        jr      @next

        ; keywords:
        ;-----------------------------------------------------------------------
@key:   call    readChar                ; get next char after the "."
        jp      z,      errKeyword      ; no letter follows!?
        ld      C,      A               ; hold char to check next char first
        call    readChar                ; get 2nd char
        cp      ASCII_SPC               ; whitespace must follow!
        jp      nz,     errKeyword      ; (i.e. no additional chars)

        ld      A,      C               ; return to first char
        res     5,      A               ; force upper-case for "a"-"z"
        cp      'B'                     ; `.b` keyword?
        jr      z,      @b              ; process bytes
        cp      'W'                     ; `.w' keyword?
        jp      nz,     errKeyword      ; none of the above? invalid keyword!

        ; (fallthrough to handle words)
        ; ...

        ;-----------------------------------------------------------------------
        ; words:
        ;-----------------------------------------------------------------------
@w:     ld      A,              2       ; set parameter size to 2 (words)
        jr      +                       ; TODO: use a skip opcode here
        ;-----------------------------------------------------------------------
        ; bytes:
        ;-----------------------------------------------------------------------
@b:     ld      A,              1       ; set parameter size to 1 (bytes)
+       ld      [param],        A       ; save parameter size to reuse

        ; parse expression and output to code-segment. deferred
        ; expressions will automatically be pushed to the heap:
        ;
-       call    nextParam

        ; the last character read by expression parsing will be either EOL/EOF,
        ; where the line ends without any further expressions, or the fist char
        ; of the following word which may or not be an expression
        ;
        ld      A,      [char]          ; last character read
        cp      ASCII_SPC+1             ; any non-visible char must be EOL/EOF
        jr      c,      @nleof          ; EOL/EOF is always end of keyword
        cp      CHAR_HEX                ; a hexadecimal literal / PC?
        jr      z,      -               ; ...
        cp      CHAR_LABEL              ; a label?
        jr      z,      -               ; ...
        cp      CHAR_CONST              ; a constant?
        jr      z,      -               ; ...
        cp      CHAR_OP_LO              ; the lo-byte unary operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_HI              ; the hi-byte unary operator?
        jr      z,      -               ; ...
        cp      CHAR_OP_NOT             ; the not unary operator?
        jr      z,      -               ; ...

        ; a word follows, but it's not an expression
        ; (instructions or another keyword can follow a keyword)
        jr      @next


getConst:
;===============================================================================
; reads a constant name from input and searches the const dictionary for it:
;
; out:  A               non-zero if found. 0 if constant not found
;       zf              zero-flag is set according to the above
;       BC              if const found, BC holds its value
;                       if const doesn't exist, **BC retains the name length**
;       DE              addr of the last byte in the const record,
;                       i.e. the lo-byte of the const value
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read const name into word buffer
        ld      DE,     const           ; use the constant dictionary entry
        call    findSymbol              ; search for the const in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; constant found, return value:
        ;-----------------------------------------------------------------------
        ; the address of the last byte of the const record is returned in DE.
        ; when we want to redefine a constant we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | t | s | n | o | c | # | len | link |
        ;          +---------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; constant value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = constant value
        ex      DE,     HL              ; return DE = last addr

        ; (note that DEC HL will have cleared the zero-flag
        ;  as a constant could never end on address $0000)
        ;
        ret


getLabel:
;===============================================================================
; reads a label name from input and searches the label dictionary for it:
;
; out:  A               non-zero if found. 0 if label not found, including
;                       forward-references that don't have a valid value yet
;       zf              zero-flag is set according to the above
;       cf              carry set indciates the label is a forward-reference
;       BC              if label found, BC holds its value
;                       if label doesn't exist, **BC retains the name length**
;       DE              if label is a forward-reference (carry-set), then DE
;                       is the addr of the lo-byte of the label value --
;                       this is so that the label value can be patched in by
;                       stepping DE forwards to the hi-byte and flag-byte
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read label name into word buffer
        ld      DE,     label           ; use the label dictionary entry
        call    findSymbol              ; search for the symbol in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; names match! read and return the symbol value:
        ;-----------------------------------------------------------------------
        ; the flag byte is used to indicate a forward-reference on a label;
        ; i.e. the label name is known, but doesn't have a value yet. we return
        ; this flag in the carry-flag by shifting it out of the byte
        ;
        ; for a deferred value the byte is 0; the shift keeps this as zero,
        ; sets zero-flag and CCF sets the carry-flag accordingly. for a valid
        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
        ; zero-flag and CCF clears the carry
        ;
        ld      A,      [DE]            ; read forward-reference flag byte
        rrca                            ; shift bit 0 into bit 7 AND carry!
        ccf                             ; flip carry so forward-reference = 1
        dec     DE                      ; step past flag byte

        ; get the label's value:
        ; (this is meaningless for a forward-reference)
        ; TODO: could we store the virtual program-counter
        ;       here, saving 2 bytes in the expr record?
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; symbol value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = symbol value

        ; the address of the last byte of the label record is returned in DE.
        ; when we need to upate the label value we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | flag | l | e | b | a | l | : | len | link |
        ;          +---------+------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; return last addr in DE
        ret


findSymbol:
;===============================================================================
; searches for a symbol in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;       [word]          the symbol name needs to already be in the
;                       word-buffer, e.g. after calling `readWord`
;
; out:  A               non-zero if found. 0 if symbol not found
;       zf              zero-flag is set according to the above
;       BC              if symbol found, symbol name length is returned in BC
;       DE              $0000 if not found, otherwise an addr pointing
;                       to the byte following the symbol name (e.g. the value)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve heap addr coming in
        ld      HL,     [word]          ; start of word buffer
        ld      C,      [HL]            ; first byte is name length
        ld      B,      0               ; load this into BC
        ex      DE,     HL              ; DE = word buffer, HL = dict. addr
        jr      @next                   ; jump into the loop

        ;=======================================================================
        ; names do not match!
        ;
--      ld      A,      WORD_LEN        ; max symbol size
        sub     E                       ; - characters remaining
        ld      C,      A               ; = length of word
        add     HL,     BC              ; snap back to symbol length field
        inc     HL                      ; move *up* to length byte

        ; FIXME: the length of the input word needs to be restored
        ;        as this is the comparison we use against each symbol
        ld      E,      WORD_LEN
        ld      A,      [DE]
        ld      C,      A

-       inc     HL                      ; move *up* to link addr lo-byte

        ;-----------------------------------------------------------------------
        ; the link field of a symbol points to      - - -+------+
        ; the lo-byte of the next symbol's link          | link |
        ; field in the chain, with the remaining    - - -+--|---+
        ; fields extending *downwards* in RAM       .-------'
        ;                                           v
        ;          ---+---+---+---+---+---+---+-----+------+
        ;  < heap     | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+-----+------+
        ;
        ; follow this link, but exit if it's $0000
        ; (also setting the zero-flag and clearing carry
        ;  -- did you know that OR cleared carry!??)
        ;
@next:  ld      A,      [HL]            ; read next symbol addr, lo-byte
        inc     HL                      ; move *up* to link addr hi-byte
        ld      H,      [HL]            ; read next symbol addr, hi-byte
        ld      L,      A               ; (complete the addr)
        or      H                       ; is the link addr $0000?
        jr      z,      @end            ; terminate at end of chain

        ; (HL is now the next symbol addr in the heap)

        dec     HL                      ; move down to length byte
        ld      A,      [HL]            ; get symbol name length
        cp      C                       ; compare with word-buffer length
        jr      nz,      -              ; different? return to link and follow

        ; symbol length matches, check characters:
        ;=======================================================================
        dec     HL                      ; (skip length byte)
        ld      E,      WORD_LEN        ; start at top of word-buffer
        ;-----------------------------------------------------------------------
-       dec     E                       ; move down a char in word-buffer
        ld      A,      [DE]            ; read char from word-buffer
        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
        jr      nz,     --              ; stop looping if mismatch
        jp      pe,     -               ; keep looping until chars run out
        ;-----------------------------------------------------------------------
        ; if all characters match we fall through to here
        ;
        ; CPD ensures that HL is pointing to the byte following the symbol-name
        ; -- on a const this is the value, and for labels this is the flag-byte
        ;
        and     A                       ; A != 0, clear z-flag & carry-flag
@end:   ex      DE,     HL              ; return last addr as DE
        pop     HL                      ; restore old heap addr
        ret


pushLabel:
;===============================================================================
; push a new label to the heap:
; 
; - the link addr to the previous label
; - the label name length; here for faster searching
; - the label name, written right-to-left -- the heap extends downwards!
; - a flag to indicate a forward-reference:
;   this happens when a label that does not exist is encountered in an expr,
;   a placeholder label is added to the heap to be filled in later. this is
;   necessary for the expr to be deferred until later to reference the label
; - the label value; the current virtual program-counter
;
; WARN: does not check if the label already exists!
;
; in:   cf              carry-flag set indicates a forward-reference!
;       HL              heap position to write new label
;       BC              word-length (set by `readWord`)
;       [word]          the label is assumed to be in the word-buffer,
;                       i.e. after calling `readWord`
; out:  HL              heap position is advanced (downwards!)
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        ; link this label to the previous one:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [label]         ; read prev label addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev label addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev label addr lo-byte
        ld      [label],HL              ; update entry point with heap addr

        ; push the label name:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [word]          ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        ; (these instructions don't modify carry...)
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes *from* [HL] *to* [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push flag to indicate a forward-reference:
        ;
        ; the flag byte is designed so that `findSymbol` will return zero-flag
        ; set for forward-references, i.e. the label is considered undefined,
        ; but carry is set to distinguish labels that exist in the dictionary
        ; vs. those that don't (required for deferring expressions)
        ;
        ; the flag is flipped to allow some trickery on read out to return
        ; A=0 and set both zero-flag AND carry-flag for forward-references
        ;
        ; NOTE: LDDR has already decremented HL for us
        ;
        ccf                             ; forward-reference = 0, otherwise 1
        rl      B                       ; shift carry flag into bit 0
        ld      [HL],   B               ; B will be 0 or 1

        ; push the label value (virtual program-counter):
        ; if the label is a forward-reference, this value is ignored
        ;
        ; the value comes after the label name to speed up symbol searching
        ; as the value is only needed once a symbol name is matched and then
        ; the heap addr is in the right place
        ;
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXH             ; ..
        ld      [HL],   A               ; .
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXL             ; ..
        ld      [HL],   A               ; .

.IFDEF  DEBUG_LABELS
        ;///////////////////////////////////////////////////////////////////////
        push    HL
        ld      HL,     [label]         ; addr of last label defined
        call    _printLabel             ; dump label definition
        pop     HL
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ret


parseInstruction:
;===============================================================================
; parse an instruction into opcodes:
;
; the CPU-specific module (e.g. "z80.wla") provides a binary tree, `opcodes`,
; that this routine walks to match instruction names to opcodes and a CPU-
; specific set of flags that determines which parameters are required
;
; in:   A               first character of word to parse
;       HL              heap addr
; out:  HL              heap addr is advanced for any expressions deferred
;       IY              binary code is appended to the code-segment,
;       IX              and the virtual program-counter is advanced
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ex      DE,     HL              ; swap heap to DE for now
        ld      HL,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch:
        ;-----------------------------------------------------------------------
        ; once a character matches, the next two bytes are either
        ; an offset to the next branch to follow, or an opcode pair
        ;
@match: inc     HL                      ; step over the matched character
        ld      C,      [HL]            ; read the offset lo-byte / opcode-byte
        inc     HL                      ; move to next byte in tree
        ld      B,      [HL]            ; read the offset hi-byte / opcode-flags

        bit     7,      B               ; is hi-bit of hi-byte set?
        jr      nz,     @opcode         ; if so, this is an opcode

        ; add the offset to the current position to jump to the new branch:
        ; NOTE: the offset in the binary tree is reduced by 1 to compensate
        ; for adding from the hi-byte addr, rather than the lo-byte addr
        ;
        add     HL,     BC

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    readChar                ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting
        ; numbers / [most] punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
       
+       ; compare with opcode tree:
        ;-----------------------------------------------------------------------
-       cp      [HL]                    ; compare input char with tree char
        jr      z,      @match          ; characters match?

        ; if the hi-bit of the character from the opcode tree is set, it's
        ; either a continuation character (>128) or the end of a branch (=128).
        ; in these cases, the result of the compare will always be negative!
        ;
        bit     7,      [HL]            ; check bit 7 of character
        jr      nz,     @cont           ; handle continuation char / end

        ; no match; try the next character:
        ;-----------------------------------------------------------------------
        inc     HL
        inc     HL
        inc     HL
        jr      -

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch -- one character has to
        ; immediately follow another -- any mismatch is an unknown opcode
        ;
@cont:  or      %10000000               ; *add* top bit to input char
        cp      [HL]                    ; redo comparison with tree
        jp      nz,     errOpcode       ; any mismatch is an error!
        inc     HL                      ; match -- move to next char in tree
        jr      @char

        ;=======================================================================
        ; emit opcode(s):
        ;-----------------------------------------------------------------------
        ; if a branch ends in an opcode, then no more characters must follow!
        ;
@opcode and     A                       ; if the last char is already 0,
        jr      z,     +                ; then no further check is needed

        call    readChar
        cp      ASCII_SPC+1             ; is it whitespace (or eof)?
        jp      nc,     errOpcode       ; if not, invalid instruction!

+       ex      DE,     HL              ; swap heap back to HL

        ; emit the opcode and parse any necessary parameters
        ; (this routine is in the CPU-specific module, e.g. z80.wla)
        jp      emitOpcode


printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  BC              (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        push    BC                      ; preserve BC coming in
        call    getHexByte              ; convert A to hexadecimal digits B,C
        ld      A,      B               ; print hi-byte first
        call    osPrintChar
        ld      A,      C               ; print lo-byte next
        pop     BC                      ; (restore BC going out)
        jp      osPrintChar

getHexByte:
;===============================================================================
; convert a byte into two ASCII hexadecimal digits:
;
; in:   A               input byte
; out:  BC              ASCII hex digits in hi,lo (printable) order
;       DE|HL           (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      B,      A               ; preserve for 2nd digit
        rra                             ;
        rra                             ; shift upper nybble down
        rra                             ;
        rra                             ;
        call    @digit                  ; convert to ASCII
        ld      A,      B               ; retrieve 2nd digit
        ld      B,      C               ; set upper ASCII digit

        ; fallthrough to convert 2nd digit
        ; ...

        ; NOTE: multiple online sources cite this method,
        ;       dating back to at least the 1970s!
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic!
        daa                             ; adjust to decimal
        adc     $40                     ; more magic!
        daa                             ; adjust to decimal
        ld      C,      A
        ret
.ENDB

; * * *   C O D E   S E G M E N T   * * *
;===============================================================================
; this is where the assembled code will be placed;
; anything beyond this point will be overwritten
;
code:
;-------------------------------------------------------------------------------
; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

;///////////////////////////////////////////////////////////////////////////////