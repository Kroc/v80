; v80, (C) Kroc Camen 2023-2024, MIT License
; a z80 assembler for Z80s
;
; constants:
;
NULL                    = 0
LO                      = 0
HI                      = 1

ASCII_SPC               = $20           ; ASCII space (whitespace)
ASCII_TAB               = $09           ; ASCII tab (whitespace)
ASCII_CR                = $0d           ; ASCII carriage-return
ASCII_LF                = $0a           ; ASCII line-feed
ASCII_SUB               = $1a           ; ASCII "substitute", end-of-file char

; syntax:
;
.DEF    CHAR_COMMENT    ';'             ; comment
.DEF    CHAR_KEYWORD    '.'             ; keyword
.DEF    CHAR_HEX        '$'             ; hexadecimal literal or PC
.DEF    CHAR_LABEL      ':'             ; a label (16-bit)
.DEF    CHAR_CONST      '#'             ; a constant (flexible size)
.DEF    CHAR_STR        '"'             ; a string
.DEF    CHAR_OP_LO      '<'             ; lo-byte unary operator
.DEF    CHAR_OP_HI      '>'             ; hi-byte unary operator
.DEF    CHAR_OP_NOT     '!'             ; not unary operator
.DEF    CHAR_OP_NEG     '-'             ; negate unary operator
.DEF    CHAR_OP_ADD     '+'             ; add operator
.DEF    CHAR_OP_SUB     '-'             ; subtract operator
.DEF    CHAR_OP_MUL     '*'             ; multiply operator
.DEF    CHAR_OP_DIV     '/'             ; divide operator
.DEF    CHAR_OP_AND     '&'             ; and operator
.DEF    CHAR_OP_OR      '|'             ; or operator
.DEF    CHAR_OP_XOR     '^'             ; xor operator
.DEF    CHAR_OP_MOD     '\'             ; modulo operator

;.DEF    DEBUG                           ; enable debug features
;.DEF    DEBUG_LABELS                    ; dump label records when defined
;.DEF    DEBUG_DUMP                      ; dump binary after assembly

.INC    "cpm.wla"                       ; CP/M bootstrap and interface
.INC    "debug.wla"                     ; debug-only functionality

; memory map:
;
;   +-----+------+------+-----+-------------------------------+---------+
;   | v80 | word | expr | str | code->                 <-heap | <-stack |
;   +-----+------+------+-----+-------------------------------+---------+
;         | <-32   <-96   128 |                               |     256
;
;       v80:    the v80 assembler
;       word:   a buffer for capturing words (symbol names); builds downwards
;       expr:   expressions are tokenised here; builds downwards
;       str:    forward buffer for reading strings, file-names
;       code:   source code is assembled here
;       heap:   symbols and other in-flight data goes here; builds downwards
;       stack:  usual Z80 stack; builds downwards
;
.DEF    WORD_LEN        31              ; maximum symbol name length

; the word buffer is used to capture symbol names. it works backwards with
; the first byte being the word-length. it must start at a page boundary
; because the lo-byte addr is assumed to be $00...$1F for optimisation
;
word            = buffers + WORD_LEN    ; e.g. $1000...$101F (32 bytes)

; calculations are compiled into bytecode to allow for later evaluation,
; i.e. for deferred calculations where a symbol is not yet known
;
expr            = buffers + 127         ; e.g. $1020...$107F (96 bytes)

; the string buffer is used to capture forwards strings
; e.g. file-names used in include keywords
;
str             = buffers + 128         ; e.g. $1080...$10FF (128 bytes)

; CP/M writes files in 128-byte sectors requiring us to pad the end of the file
; to the next 128-bytes, thus the align above ensures that the code-segment is
; aligned to a $00 or $80 address after the buffers (256 bytes)
;
code            = buffers + 256         ; e.g. $1100

;===============================================================================
.INC    "err.wla"                       ; error messages
.INC    "expr.wla"                      ; expression parsing and evaluation
.INC    "z80.wla"                       ; Z80 parser & opcode binary tree

.BLOCK  "code"
;===============================================================================
; NOTE: these two bytes are specifically grouped together because they
;       are required by deferred expressions written to the heap
;       and are pushed together as a single word
param_col:
param:  .BYTE   $00                     ; parameter type / relative-flag
col:    .BYTE   $00                     ; current column-number in file
row:    .WORD   $0000                   ; current line-number in file

char:   .BYTE   $00                     ; current input character

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred expressions
; will be built up on the heap. it works downwards from the top of memory
; in order to maximise the available space before the assembled binary
; and heap collide. during initialisation the heap will be placed 512 bytes
; below the stack at the top of memory, giving enough room for the stack
; and other buffers
;
; like the stack, the heap is pre-decrement meaning that the heap address
; is decremented first before writing a value, ergo the heap addr points
; to a currently occupied byte on the heap
;
sp:     .ADDR   $fd00                   ; stack pointer backup
heap:   .ADDR   $fc00                   ; current position on the heap

; dictionaries:
;-------------------------------------------------------------------------------
; labels and constants are stored as a linked-list of dictionary entries.
; each has its own entry point to avoid wasting time searching for labels
; amongst constants and vice-versa. $0000 terminates the list
;
; although the heap extends downwards, the link address has to point to
; the lo-byte of the entry's link field which is technically the 2nd byte
; of the record
;                     +------+
;          .----------+ addr |  (entry point)
;          V          +------+
; - - -----+------+
;  ...data | addr |             (heap extends downwards)
; - - -----+------+
;
label:  .ADDR   $000                    ; addr of last label dictionary-entry
const:  .ADDR   $000                    ; addr of last const dictionary-entry

; the name of each file needs to be kept in case of error. a deferred
; expression could error long after a file has been closed and another opened.
; each file name is stored as a symbol on the heap and its addr is used as a
; reference. this avoids duplicating names for files included multiple times
;
file:   .ADDR $0000                     ; addr of current file-name
files:  .ADDR $0000                     ; dictionary entry point for file-names


main:
;===============================================================================
        ; initialise stack / heap:
        ;
        ; this *assumes* the stack is completely empty, i.e. at $FD00 rather
        ; than $FCFE. the OS bootstrap *must* JP to main instead of CALL!
        ;
        ;   - - - -------+------------------+
        ;         <-heap |          <-stack |
        ;   - - - -------+------------------+
        ;
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FD00
        ld      [sp],   HL              ; (save value for printing later)
        dec     H                       ; go down 1 page (e.g. $FD00 > $FC00)
        ld      [heap], HL              ; this will be the top of the heap

        ; how do you measure the maximum depth of the stack
        ; used during program execution?
        ;
        ; you could record the stack depth every time you push, or at least
        ; often enough, but that slows down execution. rather, we can write
        ; an initial value to every stack space and after execution we can
        ; check how deep the original value remains. But what if the data
        ; pushed to the stack happens to contain that value?
        ;
        ; the only value you can almost guarantee will never be pushed to the
        ; stack is... the address of the stack itself! For example, if the
        ; stack is at $FC80 then you won't ever see $FC80 stored there
        ; -- this is programmatically useless
        ;
        ; therefore we fill each stack space with its own address and after
        ; execution check for stack positions that have changed, revealing
        ; the deepest push to the stack during execution!
        ;
        ld      HL,     [sp]            ; load HL with the stack pointer
        ld      B,      256/2           ; number of slots in stack, 2 bytes ea.
-       dec     HL                      ; decrement HL first to match the
        dec     HL                      ;  stack-pointer after it pushes HL
        push    HL                      ;  (stack is decrement-then-copy)
        djnz    -                       ; loop all stack pushes
        ld      SP,     [sp]            ; restore stack pointer

        ; print addresses:
        ;
        ld      DE,     @addrc          ; start with "CODE @ ..."
        ld      HL,     code            ; start addr of code-segment
        call    @print                  ; print string and value
        ld      HL,     [heap]          ; start addr of heap
        call    @print                  ; print next string and value
        ld      HL,     [sp]            ; start addr of stack
        call    @print                  ; print next string and value
        call    osPrintNewline
        call    osPrintNewline

        ; assemble the source file:
        ;=======================================================================
        ; parse the command-line parameters and return an addr (DE) to the
        ; input file-name as a forwards, null-terminated string but also set
        ; the output file-name privately -- we leave all command-line parsing
        ; to the OS due to differing file-system limitations
        ;
        call    osParseParameters

        ; the virtual program-counter is permanently pinned to IX since
        ; it's a value that needs to be incremented often but not read
        ; back too often. this avoids a bunch of HL/DE register swapping
        ;
        ld      IX,     $0000           ; virtual program-counter

        ; the code-segment address (where assembled binary code goes)
        ; is pinned to IY. as with the virtual program-counter, despite
        ; the IY register being slower to utilise, it is used sparingly
        ; and avoids costly register swapping
        ;
        ld      IY,     code            ; code-segment address

        ld      HL,     [heap]          ; start the heap (file-name is pushed)
        call    assembleFile            ; assemble! (DE is file-name str addr)

        ; TODO: 2nd pass!

        ; calculate final stats:
        ;
        ; +----------------+----------------------+---------------+
        ; | code-segment-> |     <-free RAM->     | <-heap        |
        ; +----------------+----------------------+---------------+
        ; ^ code           ^ IY                   ^ HL            ^ [heap]
        ;
        ; size of the heap:
        ; (works downwards from top of RAM)
        ;
        xor     A                       ; (clear carry)
        ex      DE,     HL              ; swap heap end-address to DE
        ld      HL,     [heap]          ; get heap starting address (high!)
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@heap],HL              ; save value for printing later

        ; free RAM size:
        ; (size between end of code-segment and end-of-heap)
        ;
        ex      DE,     HL              ; return last heap addr to HL
        ld      D,      IYH             ; copy code-segment last address
        ld      E,      IYL             ;  into DE for SBC HL, DE
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@free],HL              ; save value for printing later

        ; size of code-segment:
        ; (size of generated binary)
        ;
        ex      DE,     HL              ; swap code end addr into HL
        ld      DE,     code            ; code-segment start addr
        sbc     HL,     DE              ; calculate end-start difference
        ld      [@code],HL              ; save value for printing later

        ; how deep is your stack?
        ;
        ; since counting towards zero is faster on Z80 we start at the top and
        ; walk down the stack slots checking if each contains its own address
        ;
        ; WARN: this code assumes that stack is at its top (e.g. $FD00),
        ;       because this code is in the top-most init routine
        ; 
        ld      HL,     0               ; load HL with the stack pointer
        add     HL,     SP              ; (oddly, there's no `ld HL, SP`!)
        ld      BC,     256/2           ; begin at the top, report remaining
        ;-----------------------------------------------------------------------
-       dec     HL                      ; (decrement into hi-byte)
        ld      A,      H               ; compare hi-byte first
        cpd                             ; CP A, [HL]; DEC HL; DEC BC
        jp      po,     +               ; exit when BC = 0 (all stack checked)
        jr      nz,     -               ; skip checking lo-byte if mismatch
        ld      A,      L               ; compare lo-byte of stack addr
        cp      A,      [HL]            ;  with lo-byte in stack slot
        jr      nz,     -               ; keep looping if mismatch
        ;-----------------------------------------------------------------------
+       ld      A,      C               ; BC is number of unused stack slots
        rla                             ; * 2 for bytes
        ld      [@stack],       A       ; save value for printing later

        ; output file:
        ;=======================================================================
        ; the output file-name is already known to the OS which read it
        ; from the command-line parameters during osParseParameters
        ;
        ld      HL,     code            ; = code-segment start addr
        push    IY                      ; transfer code-segment end addr
        pop     DE                      ;  to DE for file write
        call    osSaveCode              ; defer all writing work to the OS

        ; print final stats:
        ;-----------------------------------------------------------------------
        ld      DE,     @strc           ; string to print ("CODE")
        ld      HL,     [@code]         ; value to print (code size)
        call    @size                   ; ...
        ld      DE,     @strh           ; string to print ("HEAP")
        ld      HL,     [@heap]         ; value to print (heap size)
        call    @size                   ; ...
        ld      DE,     @strf           ; string to print ("FREE")
        ld      HL,     [@free]         ; value to print (free bytes)
        call    @size                   ; ...
        ld      DE,     @strs           ; string to print ("STACK")
        call    osPrintStrZ             ; ...
        ld      A,      [@stack]        ; lastly, the number of bytes free
        call    printHexByte            ;  on the stack at peak usage
        ld      DE,     @peak           ;  i.e. the deepest the stack got,
        call    osPrintLn               ;  not the current level

        .dumpCode                       ; DEBUG_DUMP: hex-dump the code-segment

        jp      osQuit                  ; jump to CP/M to quit the program

        ;=======================================================================
@code   .WORD   $0000                   ; size of code-segment
@free   .WORD   $0000                   ; free RAM between code and heap
@heap   .WORD   $0000                   ; size of heap
@stack  .WORD   $0000                   ; bytes stack used (peak)

        ; print calculated address:
        ;-----------------------------------------------------------------------
@print: call    osPrintStrZ             ; print string passed in DE
        ld      A,      H               ; print HL in hi-lo byte order
        call    printHexByte            ; ...
        ld      A,      L               ; ..
        jp      printHexByte            ; .

@addrc  .BYTE   "CODE @ $", 0
@addrh  .BYTE   ", HEAP @ $", 0
@addrs  .BYTE   ", STACK @ $", 0

        ; print a string and append "bytes":
        ;-----------------------------------------------------------------------
@size:  call    @print                  ; print string (DE) and value (HL)
        ld      DE,     @bytes          ; append " bytes"
        jp      osPrintLn               ;  and return

@strc   .BYTE   "\r\n\r\n"
        .BYTE   "CODE : $", 0
@strh   .BYTE   "HEAP : $", 0
@strf   .BYTE   "FREE : $", 0
@bytes  .BYTE   " bytes", 0
@strs   .BYTE   "STACK: $00", 0
@peak   .BYTE   " free", 0


assembleFile:
;===============================================================================
; opens a file and assembles it:
;
; in:   DE              addr of file-name string, forwards, null-terminated
;                       -- currently assumed to be the string buffer
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    osFileOpen              ; use the OS to open the file (DE)

        ; search the file-name dictionary and return the address
        ; of the file-name record (in BC), adding it if not present
        ;
        ; this is done *after* opening the file so that if the file
        ; is missing, the source of the error is reported as the
        ; file+line containing the include statement
        ;
        ld      DE,     str             ; rewind to start of string
        call    getFileID               ; search for or add file-name
        ld      [file], BC              ; set current file-name addr

        call    @line                   ; run the parsing loop
        call    osFileClose             ; close the file

        ; WARN: this cannot be optimised into a JP due to
        ;       osFileClose doing stack manipulation
        ret

        ;=======================================================================
        ; define constant:
        ;-----------------------------------------------------------------------
        ; because constants can be redefined we don't search for the symbol yet
        ; -- we need the value first! get only the constant name:
        ;
@const: call    readWord                ; read symbol name into buffer
        call    nextExpr                ; try evaluate the following expression
        jp      c,      errUnexpDefer   ; cannot contain forward-references!
        push    BC                      ; keep ahold of the const value

        ld      DE,     const           ; use constant dictionary
        call    findSymbol              ; check if constant already exists
        jr      nz,     +               ; if yes, skip to writing the value

        ; push a new constant to the heap:
        ;-----------------------------------------------------------------------
        ld      DE,     [const]         ; read prev const addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev const addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev const addr lo-byte
        ld      [const],HL              ; update entry point with heap addr

        ; push the const name:
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        ld      HL,     word            ; get word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement DE once to adjust for this before the copy
        ;
        dec     DE                      ; adjust heap for post-decrement copy
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push const value:
+       pop     BC                      ; get back the const value to set
        ld      [HL],   B               ; because we're writing downwards
        dec     HL                      ;  in RAM, write value hi-byte first
        ld      [HL],   C               ;  followed by value lo-byte

        ; only one constant can be defined per line
        jr      @line

        ;=======================================================================
        ; define label:
        ;-----------------------------------------------------------------------
@label: call    getLabel                ; read label name and search for it

        ; if the label has been referenced in an expression, but not yet
        ; defined, carry will be set. in this case we want to 'fill in the
        ; blank' so that deferred expressions using this label can be evaluated
        ;
        jr      c,      +               ; does it exist as a forward-reference?
        
        ; zero-flag will be set if the label either does not exist at all,
        ; or was a forward-reference (we've eliminated forward-references
        ; first), therefore if the label *does* exist we're trying to
        ; define a label twice!
        ;
        jp      nz,     errRedefLabel   ; cannot redefine labels!

        call    pushLabel               ; define new label on the heap
        jr      @next                   ; return to parsing

        ;-----------------------------------------------------------------------
        ; when a label has been referred to in an expression in the past,
        ; a placeholder is added to the dictionary awaiting definition --
        ; now that time has come. `getLabel` has returned the addr (DE)
        ; of the last byte of the label record so we can walk up the
        ; bytes and patch in the new value
        ;
+       ld      A,      IXL             ; virtual program-counter, lo-byte
        ld      [DE],   A               ; ...
        inc     DE                      ; move upwards to value hi-byte
        ld      A,      IXH             ; virtual program-counter, hi-byte
        ld      [DE],   A               ; ...
        inc     DE                      ; move upwards to flag-byte
        ld      A,      1               ; set flag byte to indicate valid value
        ld      [DE],   A               ; ...

        jr      @next                   ; return to parsing

        ;=======================================================================
        ; distinguish between newline and end-of-file:
        ;-----------------------------------------------------------------------
        ; readChar returns zero-flag set for both newline and end-of-file,
        ; check the ASCII code to differentiate the two
        ;
@nleof: cp      ASCII_LF                ; check for newline
        ret     nz                      ; no? end-of-file -- end assembling

        ; at newline fallthrough to
        ; the line-starting context
        ; ...

        ; line context:
        ;=======================================================================
        ; at the beginning of the line, labels, constants and
        ; the program-counter can be defined but nowhere else
        ;
@line:  call    nextWord                ; find first character
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ; first character determines the word type:
        ;
        cp      CHAR_LABEL              ; is label?
        jr      z,      @label          ; define a label
        cp      CHAR_CONST              ; is constant?
        jr      z,      @const          ; define a constant

        ; a hexadecimal number at the start of a line
        ; defines the virtual program-counter
        ;
        cp      CHAR_HEX                ; hexadecimal literal?
        jr      nz,     @body           ; if not, skip to body context

        ; set the virtual program-counter:
        ;-----------------------------------------------------------------------
        ; there is no "org" statement to set the program counter as with other
        ; assemblers; if a line begins with a hexadecimal number the virtual
        ; program-counter is set to that value, e.g.
        ;
        ;       $c000   ; PC is now $c000
        ;
        ; to set the virtual program-counter using an expression,
        ; begin the line with a lone `$` followed by the expression, e.g.
        ;
        ;       $       #boot + $0100   ; set PC to #boot constant + 256
        ;
@pc:    call    parseHexNumber          ; capture the number
        call    c,      nextExpr        ; if PC, parse the expr that follows
        jp      c,      errUnexpDefer   ; must be a constant expr!

        ld      IXL,    C               ; change the virtual program-counter
        ld      IXH,    B               ;  to the number given

        ; fallthrough to check for following statements
        ;
        ; TODO: we should probably allow a label following the PC,
        ;       e.g.
        ;               $c000   :label  ret
        ; ...

        ; body context:
        ;=======================================================================
        ; labels and the program-counter must be defined first on the line and
        ; after those, instructions and keywords are allowed. this is known as
        ; the body context and multiple instructions / keywords can occur until
        ; either a comment or the end of the line
        ;
        ; after a keyword or instruction, parsing returns to the body context
        ; unless a newline is encountered. in cases where the last-read char
        ; is whitespace, we need to pickup the next character:
        ;
@next:  ld      A,      [char]          ; last read character
        cp      ASCII_SPC               ; ASCII<32 = newline (or end-of-file)?
        jr      c,      @nleof          ; switch to line context
        call    z,      nextWord        ; SPC = find next char (or newline)
        jr      z,      @nleof          ; did we hit newline or end-of-file?

        ;-----------------------------------------------------------------------
@body:  cp      CHAR_KEYWORD            ; is this a keyword?
        jr      z,      @key

        call    parseInstruction        ; if not, must be an instruction

        jr      @next

        ; keywords:
        ;-----------------------------------------------------------------------
@key:   call    readChar                ; get next char after the "."
        jp      z,      errInvalKey     ; no letter follows!?
        ld      C,      A               ; hold char to check next char first
        call    readChar                ; get 2nd char
        cp      ASCII_SPC               ; whitespace must follow!
        jp      nz,     errInvalKey     ; (i.e. no additional chars)

        ld      A,      C               ; return to first char
        res     5,      A               ; force upper-case for "a"-"z"
        cp      'I'                     ; .`i` keyword?
        jr      z,      @i              ; handle file include
        cp      'B'                     ; `.b` keyword?
        jr      z,      @b              ; process bytes
        cp      'W'                     ; `.w' keyword?
        jp      nz,     errInvalKey     ; none of the above? invalid keyword!

        ; (fallthrough to handle words)
        ; ...

        ;-----------------------------------------------------------------------
        ; words:
        ;-----------------------------------------------------------------------
@w:     ld      A,              2       ; set parameter size to 2 (words)
        jr      +                       ; TODO: use a skip opcode here?
        ;-----------------------------------------------------------------------
        ; bytes:
        ;-----------------------------------------------------------------------
@b:     ld      A,              1       ; set parameter size to 1 (bytes)
+       ld      [param],        A       ; save parameter size to reuse

        ; check if either a string OR an expression follows:
        ;
--      call    nextWord                ; skip in-between spaces
        jr      z,      @nleof          ; stop at EOL/EOF
        cp      A,      CHAR_STR        ; a string?
        jr      z,      @str            ; process string literal

        ; not a string, parse as an expression and output to code-segment:
        ; deferred expressions will automatically be pushed to the heap
        ;
        call    nextParam

        ; the last character read by expression parsing will be either EOL/EOF,
        ; where the line ends without any further expressions, or the fist char
        ; of the following word which may or may not be an expression
        ;
        ld      A,      [char]          ; last character read
-       cp      ASCII_SPC+1             ; any non-visible char must be EOL/EOF
        jr      c,      @nleof          ; EOL/EOF is always end of keyword
        cp      CHAR_HEX                ; a hexadecimal literal / PC?
        jr      z,      --              ; ...
        cp      CHAR_LABEL              ; a label?
        jr      z,      --              ; ...
        cp      CHAR_CONST              ; a constant?
        jr      z,      --              ; ...
        cp      CHAR_OP_LO              ; the lo-byte unary operator?
        jr      z,      --              ; ...
        cp      CHAR_OP_HI              ; the hi-byte unary operator?
        jr      z,      --              ; ...
        cp      CHAR_OP_NOT             ; the not unary operator?
        jr      z,      --              ; ...
        cp      CHAR_OP_NEG             ; the negate unary operator
        jr      z,      --              ; ...

        ; a word follows, but it's not an expression
        ; (instructions or another keyword can follow a keyword)
        jr      @next

        ;-----------------------------------------------------------------------
        ; string literal:
        ;-----------------------------------------------------------------------
        ; it's important to note that a string is not a value and cannot be
        ; a part of an expression or a parameter; it is a series of bytes
        ; written directly to the code-segment
        ;
@str:   ld      A,      [param]         ; a string cannot be a part of 
        cp      2                       ;  a list of words! (i.e. `.w` keyword)
        jp      z,      errInvalExpr    ; FIXME: better error message for this
        ;-----------------------------------------------------------------------
-       call    readChar                ; read next character
        jp      z,      errInvalStr     ; sudden EOL/EOF? unterminated string!
        cp      CHAR_STR                ; string terminator?
        jr      z,      --              ; yes, check for next string/expr
        ld      [IY+$00],       A       ; emit byte to code-segment
        inc     IY                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        jr      -                       ; keep reading

        ;-----------------------------------------------------------------------
        ; include:
        ;-----------------------------------------------------------------------
        ; TODO: should we read ALL bytes until the end of the line, including
        ;       expressions? where do we store these? (need a 256B temp string)
        ;       we could temporarily relocate the code-segment addr (IY) and
        ;       reuse the `.b` bytes parser but we'd need to disallow defers
        ;
        ; next parameter must be a string. unlike other strings this shouldn't
        ; be written directly to the code-segment but is instead captured in
        ; the string-buffer
        ;
        ; FIXME: protect against strings > 127 bytes
        ;
@i:     call    nextWord                ; skip in-between spaces
        jp      z,      errUnexpEOL     ; error if no parameter!
        cp      CHAR_STR                ; is it a string?
        jp      nz,     errInvalStr     ; error if not a string
        ld      DE,     str             ; addr of forwards string-buffer $xx80
        ;-----------------------------------------------------------------------
-       call    readChar                ; read next character
        jp      z,      errInvalStr     ; sudden EOL/EOF? unterminated string!
        cp      CHAR_STR                ; string terminator?
        jr      z,      +               ; yes, stop reading chars
        ld      [DE],   A               ; add char to word-buffer
        inc     E                       ; move to next byte in string-buffer
        jr      -                       ; keep reading
        ;-----------------------------------------------------------------------
+       xor     A                       ; add null terminator
        ld      [DE],   A               ; ...
        ld      E,      <str            ; rewind addr to start of string

        ; backup the current file-name, col & row:
        ;
        ; we don't have to backup the last read character because
        ; `assemble` doesn't use it before reading another character
        ;
        ld      BC,     [file]          ; address of current file-name
        push    BC                      ; ...
        ld      BC,     [row]           ; the row (line) number is 16-bit
        push    BC                      ; ...
        ld      A,      [col]           ; col is only 1 byte
        push    AF                      ;  a bit of a waste :|

.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      A,      '['
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        call    assembleFile            ; assemble the included file
.IFNDEF DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ld      A,      ']'
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        pop     AF                      ; pop column number
        ld      [col],  A               ; (only 1 byte)
        pop     BC                      ; pop row (line) number
        ld      [row],  BC              ; restore current file row-number
        pop     BC                      ; pop file-name addr
        ld      [file], BC              ; ...

        ; skip any whitespace / comment following the file-name and return
        ; to the line context (other keywords cannot follow `.i`)
        jp      @line


nextWord:
;===============================================================================
; reads input and skips spaces until either:
;
; - the next non-terminating character
; - a newline or end-of-line character
; - a comment
;
; in the case of a comment, the comment text is skipped over and the next
; newline / end-of-file is returned instead! therefore this routine
; MUST NOT be used to skip over whitespace in string literals etc.
;
; WARN: this routine will return on newline and that there may be more leading
;       whitespace on the next line -- if you want to skip to the next non-
;       whitespace character, call the routine again after a newline!
;
; out:  A               ASCII code
;       zf              zero-flag is set for "no word", i.e. when the line
;                       ends before another valid word. check A for newline
;                       (ASCII_LF) to differentiate those. end-of-file might
;                       NOT be null! (e.g. CP/M uses ASCII_SUB)
;-------------------------------------------------------------------------------
-       call    readChar                ; read a character (returns z-flag)
        ret     z                       ; return z-flag set if newline/EOF

        ; we need to be careful not to wrongly return z-flag set!
        ;
        ; we cannot check for ASCII_SPC+1 ("!") as if this character appears,
        ; the parser will think the file ended. instead look for space itself
        ; -- for any ASCII code below we continue looping, and space itself
        ; is caught with the zero-flag and re-looped
        ; 
        cp      ASCII_SPC               ; is ASCII code a space?
        jr      c,      -               ; keep reading if codes 1-31
        jr      z,      -               ; also, keep reading if space

        cp      CHAR_COMMENT            ; is this the start of a comment?
        ret     nz                      ; if not, quit quickly

        ; skip over a comment until the newline / end-of-line:
        ;
-       call    readChar                ; read a character (returns z-flag)
        jr      nz,     -               ; read until newline / end-of-file

        ret


readWord:
;===============================================================================
; read symbol name:
;
; NOTE: the word is written *downwards* in RAM, to match how symbol names are
;       written on the heap, for faster comparison -- we use the bottom of
;       a page to hold the incoming word so that we can get away with using
;       `DEC E` instead of `DEC DE`
;
; out:  A               length of word
;       DE              DE is set to the first byte (length) of `word`
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;-------------------------------------------------------------------------------
        ld      DE,     word            ; top of word-buffer
        jr      +                       ; (first character already read)
        ;-----------------------------------------------------------------------
-       call    readChar                ; read char from input file
        cp      ASCII_SPC+1             ; whitespace or end-of-line/file?
        jr      c,      @ok             ; (leave loop at whitespace)
+       dec     E                       ; move to next space in buffer
        ld      [DE],   A               ; add the character to the buffer
        jp      p,      -               ; keep going until buffer full
        ;-----------------------------------------------------------------------
        jp      errInvalSym             ; quit with invalid symbol error

        ;-----------------------------------------------------------------------
@ok:    ld      A,      WORD_LEN        ; max size - characters remaining
        sub     E                       ;  = length of word
        ld      E,      <word           ; snap back to length byte
        ld      [DE],   A               ; write word-length byte
        ret


readChar:
;===============================================================================
; reads the next character in the file:
; current row and column are maintained
;
; out:  A               ASCII code. 0 = end-of-file
;       zf              zero-flag is set *both* for end-of-file and newline!
;       [char]          the character is also written to RAM
;       BC, DE, HL      (preserved)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        ;push    AF
        ;call    osPrintChar             ; print each character as we receive it
        ;pop     AF                      ; (zero-flag must be preserved)
.ENDIF  ;///////////////////////////////////////////////////////////////////////
        ret     z                       ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      z,      @row            ; handle newline
        cp      ASCII_TAB               ; /t is tab
        jr      z,      @tab            ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; WARN: we do not cap the column number -- keep lines to 80 cols!
        ;       when a line exceeds 255 chars, the 256th character will
        ;       be treated as end-of-file!
        ;
@col:   inc     [HL']
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
        ; FIXME: line-number should be set to 1 by default
        ;
@row:   ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
@tab:   dec     A                       ; \t = 9, so change to 8 (width of tab)
        add     [HL']                   ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        ld      [HL'],  A               ; update column number
        ld      A,      ASCII_SPC       ; return a single space instead
        ld      [char], A               ; update retained value to match
        and     A                       ; ensure zero-flag is clear!

        exx                             ; restore HL/DE
        ret


getFileID:
;===============================================================================
; find, and if it doesn't exist, add a file-name to the heap:
;
; in:   DE              addr of file-name string, forwards, null-terminated
; out:  BC              addr of file-name record (backwards), length-byte
;       DE              addr of byte following the file-name in the record
;                       (for storing arbitrary data in the file-name record)
;       HL              if unknown, the file-name string is pushed to the heap
;       A               (clobbered)
;
;                    ---+---+---+---+---+---+---+---+---+---+-----+------+
;            < heap     | ? | e | m | a | n | e | l | i | f | len | link |
;                    ---+---+---+---+---+---+---+---+---+---+-----+------+
;                    DE ^   ^ HL (if file-name pushed)      ^ BC
;-------------------------------------------------------------------------------
        ; copy the forwards string file-name from the string-buffer into the
        ; word-buffer, backwards, to do a symbol search. if the file-name is
        ; not known it's added to the heap in this backwards form
        ;
        ; WARN: this places a limit of 31 characters on the file-name even
        ;       though we can read a much longer string. this is acceptable
        ;       for CP/M but Agon MOS / Zeal support subdirectories. this
        ;       will have to be resolved for later versions of v80
        ;
        push    HL                      ; preserve current heap-addr
        ld      HL,     word            ; destination is word-buffer
        jr      +                       ; jump into loop (skip length-byte)
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read char from string-buffer
        and     A                       ; check for null terminator (set flags)
        jr      z,      ++              ; stop copying at null terminator
        ld      [HL],   A               ; write to backwards word-buffer
        inc     E                       ; move to next char in string-buffer
+       dec     L                       ; move to next char in word-buffer
        jp      po,     -               ; loop for max. 31 chars (L >= 0)
        ;-----------------------------------------------------------------------
        jp      errUndefFile            ; error if string > 31 chars

        ; the length of the string has to be written
        ; at the topmost byte of the word-buffer
        ;
++      ld      A,      WORD_LEN        ; max size - characters remaining
        sub     L                       ;  = length of word
        ld      L,      WORD_LEN        ; snap back to length byte
        ld      [HL],   A               ; write word-length byte
        pop     HL                      ; restore heap-addr

        ; check if this file name is already known:
        ;
        ; if an include file is used many times (like a macro), we don't
        ; want the heap bloated with repeated instances of the same file-name
        ;
        ld      DE,     files           ; use the files dictionary
        call    findSymbol              ; search for file-name in word-buffer
        ret     nz                      ; if found, return the ID

        ; add the file-name to the heap:
        ;=======================================================================
        ; link this file-name to the previous one: (for searching)
        ;
@add:   ld      DE,     [files]         ; read prev addr in files dictionary
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev file-name addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev file-name addr lo-byte
        ld      [files],HL              ; update entry point with heap addr

        ; copy the file-name to the heap:
        ; note that BC is set to the file-name length by `findSymbol`
        ;
        ld      DE,     word            ; word-buffer addr ($xx00)
        ld      A,      [DE]            ; get symbol length
        dec     E                       ; (move past length byte)
        dec     HL                      ; pre-decrement the heap
        ld      [HL],   A               ; push symbol length

        ; this address is what will be used to identify the file-name,
        ; it has to be returned in BC (below) to match `findSymbol` behaviour
        push    HL

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex      DE,     HL              ; swap back to heap in HL
        ld      D,      H               ; the byte following the file-name str
        ld      E,      L               ;  is returned in DE like `findSymbol`
        inc     HL                      ; fix heap addr after LDDR copy

        pop     BC                      ; return the file-name addr
        ret


getConst:
;===============================================================================
; reads a constant name from input and searches the const dictionary for it:
;
; out:  A               non-zero if found. 0 if constant not found
;       zf              zero-flag is set according to the above
;       BC              if const found, BC holds its value
;                       if const doesn't exist, **BC retains the name length**
;       DE              addr of the last byte in the const record,
;                       i.e. the lo-byte of the const value
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read const name into word buffer
        ld      DE,     const           ; use the constant dictionary entry
        call    findSymbol              ; search for the const in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; constant found, return value:
        ;-----------------------------------------------------------------------
        ; the address of the last byte of the const record is returned in DE.
        ; when we want to redefine a constant we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | t | s | n | o | c | # | len | link |
        ;          +---------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; constant value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = constant value
        ex      DE,     HL              ; return DE = last addr

        ; (note that DEC HL will have cleared the zero-flag
        ;  as a constant could never end on address $0000)
        ;
        ret


getLabel:
;===============================================================================
; reads a label name from input and searches the label dictionary for it:
;
; out:  A               non-zero if found. 0 if label not found, including
;                       forward-references that don't have a valid value yet
;       zf              zero-flag is set according to the above
;       cf              carry set indicates the label is a forward-reference
;       BC              if label found, BC holds its value
;                       if label doesn't exist, **BC retains the name length**
;       DE              if label is a forward-reference (carry-set), then DE
;                       is the addr of the lo-byte of the label value --
;                       this is so that the label value can be patched in by
;                       stepping DE forwards to the hi-byte and flag-byte
;       HL              (preserved)
;-------------------------------------------------------------------------------
        call    readWord                ; read label name into word buffer
        ld      DE,     label           ; use the label dictionary entry
        call    findSymbol              ; search for the symbol in word-buffer
        ret     z                       ; if not found, return 0 & zf-set

        ; names match! read and return the symbol value:
        ;-----------------------------------------------------------------------
        ; the flag byte is used to indicate a forward-reference on a label;
        ; i.e. the label name is known, but doesn't have a value yet. we return
        ; this flag in the carry-flag by shifting it out of the byte
        ;
        ; for a deferred value the byte is 0; the shift keeps this as zero,
        ; sets zero-flag and CCF sets the carry-flag accordingly. for a valid
        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
        ; zero-flag and CCF clears the carry
        ;
        ld      A,      [DE]            ; read forward-reference flag byte
        rrca                            ; shift bit 0 into bit 7 AND carry!
        ccf                             ; flip carry so forward-reference = 1
        dec     DE                      ; step past flag byte

        ; get the label's value:
        ; (this is meaningless for a forward-reference)
        ; TODO: could we store the virtual program-counter
        ;       here, saving 2 bytes in the expr record?
        ;
        ex      DE,     HL              ; swap to HL for reg-loading
        ld      B,      [HL]            ; symbol value hi-byte
        dec     HL                      ; move to value lo-byte
        ld      C,      [HL]            ; return BC = symbol value

        ; the address of the last byte of the label record is returned in DE.
        ; when we need to update the label value we can just walk up the bytes
        ;
        ;          | DE
        ;          v---------+------+---+---+---+---+---+---+-----+------+
        ;  < heap  | lo | hi | flag | l | e | b | a | l | : | len | link |
        ;          +---------+------+---+---+---+---+---+---+-----+------+
        ;
        ex      DE,     HL              ; return last addr in DE
        ret


findSymbol:
;===============================================================================
; searches for a symbol in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;       word            the symbol name needs to already be in the
;                       word-buffer, e.g. after calling `readWord`
;
; out:  A               non-zero if found. 0 if symbol not found
;       zf              zero-flag is set according to the above
;       BC              if symbol found, BC is addr of symbol length byte
;                       if symbol not found, BC is the symbol name length
;       DE              $0000 if not found, otherwise an addr pointing to
;                       the byte following the symbol name (e.g. the value)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve heap addr coming in
        ld      HL,     word            ; start of word buffer
        ld      C,      [HL]            ; first byte is name length
        ld      B,      0               ; load this into BC
        ex      DE,     HL              ; DE = word buffer, HL = dict. addr
        jr      @next                   ; jump into the loop

        ;=======================================================================
        ; names do not match!
        ;
--      ld      E,      WORD_LEN        ; return to word-buffer length byte
        ld      A,      [DE]            ; restore the word-length to BC
        ld      C,      A               ; ...
        pop     HL                      ; return symbol length byte
-       inc     HL                      ; move *up* to link addr lo-byte

        ;-----------------------------------------------------------------------
        ; the link field of a symbol points to      - - -+------+
        ; the lo-byte of the next symbol's link          | link |
        ; field in the chain, with the remaining    - - -+--|---+
        ; fields extending *downwards* in RAM       .-------'
        ;                                           v
        ;          ---+---+---+---+---+---+---+-----+------+
        ;  < heap     | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+-----+------+
        ;
        ; follow this link, but exit if it's $0000
        ; (also setting the zero-flag and clearing carry
        ;  -- did you know that OR cleared carry!??)
        ;
@next:  ld      A,      [HL]            ; read next symbol addr, lo-byte
        inc     HL                      ; move *up* to link addr hi-byte
        ld      H,      [HL]            ; read next symbol addr, hi-byte
        ld      L,      A               ; (complete the addr)
        or      H                       ; is the link addr $0000?
        jr      z,      @end            ; terminate at end of chain

        ; (HL is now the next symbol addr in the heap)

        dec     HL                      ; move down to length byte
        ld      A,      [HL]            ; get symbol name length
        cp      C                       ; compare with word-buffer length
        jr      nz,      -              ; different? return to link and follow

        ; symbol length matches, check characters:
        ;=======================================================================
        push    HL                      ; store symbol length addr to snap back
        dec     HL                      ; (skip length byte)
        ld      E,      WORD_LEN        ; start at top of word-buffer
        ;-----------------------------------------------------------------------
@char:  dec     E                       ; move down a char in word-buffer
        ld      A,      [DE]            ; read char from word-buffer
        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
        jr      nz,     --              ; stop looping if mismatch
        jp      pe,     @char           ; keep looping until chars run out
        ;-----------------------------------------------------------------------
        ; if all characters match we fall through to here. CPD ensures
        ; that HL is pointing to the byte following the symbol-name
        ;
        ; the addr of the byte following (downwards) the symbol-name
        ; is returned in DE  -- on a const this is the value (hi-byte),
        ; and for labels this is the flag-byte
        ;
        ;          ---+---+---+---+---+---+---+---+-----+------+
        ;  < heap     | ? | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+---+-----+------+
        ;             ^ DE                        ^ BC
        ;
        pop     BC                      ; return symbol-length addr
        and     A                       ; A != 0, clear z-flag & carry-flag
@end:   ex      DE,     HL              ; return last addr as DE
        pop     HL                      ; restore old heap addr
        ret


pushLabel:
;===============================================================================
; push a new label to the heap:
; 
; - the link addr to the previous label
; - the label name length; here for faster searching
; - the label name, written right-to-left -- the heap extends downwards!
; - a flag to indicate a forward-reference:
;   this happens when a label that does not exist is encountered in an expr,
;   a placeholder label is added to the heap to be filled in later. this is
;   necessary for the expr to be deferred until later to reference the label
; - the label value; the current virtual program-counter
;
; WARN: does not check if the label already exists!
;
; in:   cf              carry-flag set indicates a forward-reference!
;       HL              heap position to write new label
;       BC              word-length (set by `readWord`)
;       word            the label is assumed to be in the word-buffer,
;                       i.e. after calling `readWord`
; out:  HL              heap position is advanced (downwards!)
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        ; link this label to the previous one:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     [label]         ; read prev label addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev label addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev label addr lo-byte
        ld      [label],HL              ; update entry point with heap addr

        ; push the label name:
        ; (these instructions don't modify carry...)
        ;
        ld      DE,     word            ; word-buffer addr
        inc     C                       ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        ; (these instructions don't modify carry...)
        ;
        dec     HL                      ; adjust heap for post-decrement copy
        ex      DE,     HL              ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes *from* [HL] *to* [DE]!
        ex      DE,     HL              ; swap back to heap in HL

        ; push flag to indicate a forward-reference:
        ;
        ; the flag byte is designed so that `findSymbol` will return zero-flag
        ; set for forward-references, i.e. the label is considered undefined,
        ; but carry is set to distinguish labels that exist in the dictionary
        ; vs. those that don't (required for deferring expressions)
        ;
        ; the flag is flipped to allow some trickery on read out to return
        ; A=0 and set both zero-flag AND carry-flag for forward-references
        ;
        ; NOTE: LDDR has already decremented HL for us
        ;
        ccf                             ; forward-reference = 0, otherwise 1
        rl      B                       ; shift carry flag into bit 0
        ld      [HL],   B               ; B will be 0 or 1

        ; push the label value (virtual program-counter):
        ; if the label is a forward-reference, this value is ignored
        ;
        ; the value comes after the label name to speed up symbol searching
        ; as the value is only needed once a symbol name is matched and then
        ; the heap addr is in the right place
        ;
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXH             ; virtual program-counter hi-byte
        ld      [HL],   A               ; ...
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXL             ; virtual program-counter lo-byte
        ld      [HL],   A               ; ...

.IFDEF  DEBUG_LABELS
        ;///////////////////////////////////////////////////////////////////////
        push    HL
        ld      HL,     [label]         ; addr of last label defined
        call    _printLabel             ; dump label definition
        pop     HL
.ENDIF  ;///////////////////////////////////////////////////////////////////////

        ret


parseInstruction:
;===============================================================================
; parse an instruction into opcodes:
;
; the CPU-specific module (e.g. "z80.wla") provides a binary tree, `opcodes`,
; that this routine walks to match instruction names to opcodes and a CPU-
; specific set of flags that determines which parameters are required
;
; in:   A               first character of word to parse
;       HL              heap addr
; out:  HL              heap addr is advanced for any expressions deferred
;       IY              binary code is appended to the code-segment,
;       IX              and the virtual program-counter is advanced
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        ex      DE,     HL              ; swap heap to DE for now
        ld      HL,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch:
        ;-----------------------------------------------------------------------
        ; once a character matches, the next two bytes are either
        ; an offset to the next branch to follow, or an opcode pair
        ;
@match: inc     HL                      ; step over the matched character
        ld      C,      [HL]            ; read the offset lo-byte / opcode-byte
        inc     HL                      ; move to next byte in tree
        ld      B,      [HL]            ; read the offset hi-byte / opcode-flags

        bit     7,      B               ; is hi-bit of hi-byte set?
        jr      nz,     @opcode         ; if so, this is an opcode

        ; add the offset to the current position to jump to the new branch:
        ; NOTE: the offset in the binary tree is reduced by 1 to compensate
        ; for adding from the hi-byte addr, rather than the lo-byte addr
        ;
        add     HL,     BC

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    readChar                ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting
        ; numbers / [most] punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
       
+       ; compare with opcode tree:
        ;-----------------------------------------------------------------------
-       cp      [HL]                    ; compare input char with tree char
        jr      z,      @match          ; characters match?

        ; if the hi-bit of the character from the opcode tree is set, it's
        ; either a continuation character (>128) or the end of a branch (=128).
        ; in these cases, the result of the compare will always be negative!
        ;
        bit     7,      [HL]            ; check bit 7 of character
        jr      nz,     @cont           ; handle continuation char / end

        ; no match; try the next character:
        ;-----------------------------------------------------------------------
        inc     HL
        inc     HL
        inc     HL
        jr      -

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch -- one character has to
        ; immediately follow another -- any mismatch is an unknown opcode
        ;
@cont:  or      %10000000               ; *add* top bit to input char
        cp      [HL]                    ; redo comparison with tree
        jp      nz,     errInvalIns     ; any mismatch is an error!
        inc     HL                      ; match -- move to next char in tree
        jr      @char

        ;=======================================================================
        ; emit opcode(s):
        ;-----------------------------------------------------------------------
        ; if a branch ends in an opcode, then no more characters must follow!
        ;
@opcode and     A                       ; if the last char is already 0,
        jr      z,     +                ; then no further check is needed

        call    readChar
        cp      ASCII_SPC+1             ; is it whitespace (or eof)?
        jp      nc,     errInvalIns     ; if not, invalid instruction!

+       ex      DE,     HL              ; swap heap back to HL

        ; emit the opcode and parse any necessary parameters
        ; (this routine is in the CPU-specific module, e.g. z80.wla)
        jp      emitOpcode


printHexWord:
;===============================================================================
; print a word as hexadecimal:
;
; in:   BC              word to print
; out:  BC              (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      A,      B
        call    printHexByte
        ld      A,      C

        ; fallthrough
        ; ...

printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  BC              (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        push    BC                      ; preserve BC coming in
        call    getHexByte              ; convert A to hexadecimal digits B,C
        ld      A,      B               ; print hi-byte first
        call    osPrintChar             ; ...
        ld      A,      C               ; print lo-byte next
        pop     BC                      ; (restore BC going out)
        jp      osPrintChar             ; ...


getHexByte:
;===============================================================================
; convert a byte into two ASCII hexadecimal digits:
;
; in:   A               input byte
; out:  BC              ASCII hex digits in hi,lo (printable) order
;       DE|HL           (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      B,      A               ; preserve for 2nd digit
        rra                             ;
        rra                             ; shift upper nybble down
        rra                             ;
        rra                             ;
        call    @digit                  ; convert to ASCII
        ld      A,      B               ; retrieve 2nd digit
        ld      B,      C               ; set upper ASCII digit

        ; fallthrough to convert 2nd digit
        ; ...

        ; NOTE: multiple online sources cite this method,
        ;       dating back to at least the 1970s!
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic!
        daa                             ; adjust to decimal
        adc     $40                     ; more magic!
        daa                             ; adjust to decimal
        ld      C,      A
        ret
.ENDB

end_of_v80:                             ; where code ends before align padding

; buffers:
;===============================================================================
.ALIGN $100                             ; align to page

;-------------------------------------------------------------------------------
; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

buffers:
;///////////////////////////////////////////////////////////////////////////////