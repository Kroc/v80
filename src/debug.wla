; v80, (C) Kroc Camen 2023-2024, MIT License
; debug only code
;
.BLOCK  "code-debug"

; these macros have to be defined, even if debugging is not enabled, so that
; assembly can still succeed with debugging off where these macros occur

.MACRO .printFlags
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printFlags
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO .printCharA
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    osPrintChar
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printChar
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      \1
        call    osPrintChar
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register A as a hexadecimal number:
;
.MACRO  .printA
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printA
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register BC as a hexadecimal number:
;
.MACRO  .printBC
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printBC
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print the value stored at an absolute address:
;
.MACRO  .printAddr
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [\1]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print the character stored at an absolute address:
;
.MACRO  .printAddrChar
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      [\1]
        call    osPrintChar
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; print register HL as a hexadecimal word:
;
.MACRO  .printHL
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        call    _printHL
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printAddrHL
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [HL]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printDE
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      D
        call    printHexByte
        ld      A,      E
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.MACRO  .printAddrDE
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG
        ;///////////////////////////////////////////////////////////////////////
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      [DE]
        call    printHexByte
        pop     AF
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.IFDEF  DEBUG
;///////////////////////////////////////////////////////////////////////////////

_printA:
        ;=======================================================================
        push    AF
        ld      A,      '$'
        call    osPrintChar             ; (does currently preserve A)
        pop     AF
        push    AF
        call    printHexByte            ; (does not preseve A)
        pop     AF
        ret

_printBC:
        ;=======================================================================
        push    AF
        ld      A,      '$'
        call    osPrintChar             ; (does currently preserve A)
        ld      A,      B
        call    printHexByte
        ld      A,      C
        call    printHexByte
        pop     AF
        ret

_printHL:
        ;=======================================================================
        push    AF
        ld      A,      '$'
        call    osPrintChar
        ld      A,      H
        call    printHexByte
        ld      A,      L
        call    printHexByte
        pop     AF
        ret

_printFlags:
        ;=======================================================================
        .printChar '['
        jr      nz,     +               ; zero flag?
        .printChar 'z'
+       jp      p,      +               ; sign flag?
        .printChar 'm'
+       jr      nc,     +               ; carry flag?
        .printChar 'c'
+       jp      po,     +               ; overflow flag?
        .printChar 'v'
+       .printChar ']'
        ret
;///////////////////////////////////////////////////////////////////////////////
.ENDIF

.MACRO  .dumpCode
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.IFDEF  DEBUG_DUMP
        ;///////////////////////////////////////////////////////////////////////
        ld      DE,     \1
        call    _dumpCode
.ENDIF  ;///////////////////////////////////////////////////////////////////////
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

.IFDEF  DEBUG_DUMP
;///////////////////////////////////////////////////////////////////////////////

_dumpCode:
;===============================================================================
; hex dump the code-segment:
;-------------------------------------------------------------------------------
        ; the number of bytes to dump is the current code-segment
        ; address sans the start address of the code segment
        ;
        push    IY                      ; code-segment end address
        pop     HL                      ; transfer to HL for SBC HL, DE
        xor     A                       ; clear carry
        sbc     HL,     DE              ; HL = HL - DE
        ex      DE,     HL              ; swap length to DE, start addr to HL
        ;-----------------------------------------------------------------------
-       ld      A,      [HL]            ; read one byte from the code-segment
        inc     HL                      ; move to next byte
        call    printHexByte            ; print byte as two hex digits
        ld      A,      ' '             ; print separating space
        call    osPrintChar             ; ...
        dec     DE                      ; decrement number of bytes to dump
        ld      A,      E               ; have we reached zero?
        or      D                       ; (bitwise OR lo & hi bytes)
        jr      nz,     -               ; keep looping until zero
        ;-----------------------------------------------------------------------
        ret

;///////////////////////////////////////////////////////////////////////////////
.ENDIF

.ENDB