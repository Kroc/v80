; v80, (C) Kroc Camen 2023-2024, MIT License
; the parsing / assembling loop
;
; TODO: could we hold the scope permenantly in A'?
;
; include the selected ISA:
;===============================================================================
; remember that this is the instruction set that you want your v80 binary
; to assemble, not the CPU it's running on! this code is already the z80
; port ("v80"), so it's implied that you're running on Z80
;
?=      #V80_ISA - #ISA_Z80
        .i      "v80_z80.v80"           ; Z80 ISA support code
        .i      "isa_z80.v80"           ; Z80 ISA instructions

?=      #V80_ISA - #ISA_6502
        .i      "v80_6502.v80"          ; 6502 ISA support code
        .i      "isa_6502.v80"          ; 6502 ISA instructions

; (for measuring size of new assembler)
:asm2

:assembleFile
;===============================================================================
; opens a file and assembles it:
;
; in:   DE              addr of file-name string, forwards, null-terminated
;       HL              current heap addr
; out:  HL              (preserved) -- stuff may be pushed to heap
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        call    :echoCommentNewline
        call    :osFileOpen             ; use the OS to open the file [DE]
        call    :echoCommentLn          ; (echo the file-name
        call    :echoCommentBar         ;  and a dividing line)

        ; search the file-name dictionary and return the address
        ; of the file-name record (in BC), adding it if not present
        ;
        ; this is done *after* opening the file so that if the file
        ; is missing, the source of the error is reported as the
        ; file+line containing the include statement
        ;
        call    :getFileID              ; search for or add file-name [DE]
        ld*$.BC [ :file ]               ; set current file-name addr

        ; reset line & column number when changing file:
        ; (the call to :_line will call :nextWord which will
        ;  set the start-of-word line/col number for us)
        ;
        xor.A                           ; (set A to zero)
        ld*$.A  [ :ccol ]               ; reset column number
        ld.BC   1                       ; line number however
        ld*$.BC [ :crow ]               ;  defaults to 1

        ;call    :_line                  ; run the parsing loop
        call    :osFileClose            ; close the file

        ; WARN: this cannot be optimised into a JP due to
        ;       osFileClose doing stack manipulation
        ret


:getFileID
;===============================================================================
; find, and if it doesn't exist, add a file-name to the heap:
;
; in:   DE              addr of file-name string, forwards, null-terminated
; out:  BC              addr of file-name record (backwards), length-byte
;       DE              addr of byte following the file-name in the record
;                       (for storing arbitrary data in the file-name record)
;       HL              if unknown, the file-name string is pushed to the heap
;       A               (clobbered)
;
;              - - - ---+---+---+---+---+---+---+---+---+---+-----+------+
;            <-heap     | ? | e | m | a | n | e | l | i | f | len | link |
;              - - - ---+---+---+---+---+---+---+---+---+---+-----+------+
;                    DE ^   ^ HL (if file-name pushed)      ^ BC
;-------------------------------------------------------------------------------
        ; copy the forwards string file-name from the string-buffer into the
        ; word-buffer, backwards, to do a symbol search. if the file-name is
        ; not known it's added to the heap in this backwards form
        ;
        ; FIXME this places a limit of 31 characters on the file-name even
        ;       though we can read a much longer string. this is acceptable
        ;       for CP/M but Agon MOS / Zeal support subdirectories. this
        ;       will have to be resolved for later versions of v80
        ;
        push.HL                         ; preserve current heap-addr
        ld.HL   :word                   ; destination is word-buffer
        jr      _in                     ; jump into loop (skip length-byte)
        ;-----------------------------------------------------------------------
_get    ld.A*DE                         ; read char from string-buffer
        and.A                           ; check for null terminator (set flags)
        ld*HL.A                         ; write to backwards word-buffer
        jr?z    _ok                     ; stop copying at null terminator
        inc.E                           ; move to next char in string-buffer
_in     dec.L                           ; move to next char in word-buffer
        jp?nv   _get                    ; loop for max. 31 chars (L >= 0)
        ;-----------------------------------------------------------------------
        jp      :errInvalFile           ; error if string > 31 chars

        ; the length of the string has to be written
        ; at the topmost byte of the word-buffer
        ;
_ok     ld.A    #WORD_LEN               ; max size - characters remaining
        sub.L                           ;  = length of word
        ld.L    #WORD_LEN               ; snap back to length byte
        ld*HL.A                         ; write word-length byte
        pop.HL                          ; restore heap-addr

        ; check if this file name is already known:
        ;
        ; if an include file is used many times (like a macro), we don't
        ; want the heap bloated with repeated instances of the same file-name
        ;
        ld.DE   :files                  ; use the files dictionary
        call    :findSymbol             ; search for file-name in word-buffer
        ret?nz                          ; if found, return the ID

        ; add the file-name to the heap:
        ;=======================================================================
        ; link this file-name to the previous one: (for searching)
        ;
        ld.DE*  [ :files ]              ; read prev addr in files dictionary
        dec.HL                          ; pre-decrement heap to empty byte
        ld*HL.D                         ; write prev file-name addr hi-byte
        dec.HL                          ; (this is the heap addr we want)
        ld*HL.E                         ; write prev file-name addr lo-byte
        ld*$.HL [ :files ]              ; update entry point with heap addr

        ; copy the file-name to the heap:
        ; note that BC is set to the file-name length by findSymbol
        ;
        ld.DE   :word                   ; word-buffer addr ($xx00)
        ld.A*DE                         ; get symbol length
        dec.E                           ; (move past length byte)
        dec.HL                          ; pre-decrement the heap
        ld*HL.A                         ; push symbol length

        ; this address is what will be used to identify the file-name,
        ; it has to be returned in BC (below) to match findSymbol behaviour
        push.HL

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        dec.HL                          ; adjust heap for post-decrement copy
        ex.DE.HL                        ; copy goes *from* [HL] *to* [DE]...
        lddr                            ; copy BC bytes from [HL] to [DE]!
        ex.DE.HL                        ; swap back to heap in HL
        ld.D.H                          ; the byte following the file-name str
        ld.E.L                          ;  is returned in DE like findSymbol
        inc.HL                          ; fix heap addr after LDDR copy

        call    :errIfHeapOverflow      ; check heap didn't overflow

        pop.BC                          ; return the file-name addr
        ret


:getConst
;===============================================================================
; reads a constant name from input and searches the const dictionary for it:
;
; out:  A               non-zero if found. 0 if constant not found
;       zf              zero-flag is set according to the above
;       BC              if const found, BC holds its value
;                       if const doesn't exist, **BC retains the name length**
;       DE              addr of the last byte in the const record,
;                       i.e. the lo-byte of the const value
;                       otherwise $0000 if not found
;       HL              (preserved)
;
;                       | DE (found)                   | BC (not-found)
;                - - - -+-------+---+---+---+---+---+--V--+------+
;                <-heap | value | t | s | n | o | c | len | link |
;                - - - -+---^---+---+---+---+---+---+-----+------+
;                           | BC (found)
;-------------------------------------------------------------------------------
        call    :readWord               ; read const name into word buffer
        ld.DE   :const                  ; use the constant dictionary entry
        call    :findSymbol             ; search for the const in word-buffer
        ret?z                           ; if not found, return 0 & zf-set

        ; constant found, return value:
        ;-----------------------------------------------------------------------
        ; the address of the last byte of the const record is returned in DE.
        ; when we want to redefine a constant we can just walk up the bytes
        ;
        ex.DE.HL                        ; swap to HL for reg-loading
        ld.B*HL                         ; constant value hi-byte
        dec.HL                          ; move to value lo-byte
        ld.C*HL                         ; return BC = constant value
        ex.DE.HL                        ; return DE = last addr

        ; (note that DEC HL will have cleared the zero-flag
        ;  as a constant could never end on address $0000)
        ;
        ret


:getLabel
;===============================================================================
; reads a label from input and does a number of things:
;
; if the label exists:
; - if it's not a forward-reference, its value is returned
; - for forward-references, carry-set is returned
;
; if the label does not exist:
; - the label is created on the heap as a forward-reference
;   and carry-set is returned
;
; out:  cf              carry set indicates the label is a forward-reference.
;                       if the label doesn't exist, it is automatically added
;                       as a forward-reference
;       BC              - if label found and isn't a fwd-ref, BC is its value
;                       - if label doesn't exist, it is added as a fwd-ref
;                         and BC is as returned from findSymbol, which is the
;                         addr of the name-length byte in the label record
;       DE              if label is a forward-reference (carry-set), then DE
;                       is the addr of the flag-byte
;       HL              if label doesn't exist, it will be pushed to the heap
;                       as a forward-reference
;       A               (clobbered)
;
;                       | DE    | DE (fwd-ref)             | BC (fwd-ref)
;                - - - -v-------v------+---+---+---+---+---v-----+------+
;                <-heap | value | flag | l | e | b | a | l | len | link |
;                - - - -+---^---+------+---+---+---+---+---+-----+------+
;                           | BC
;-------------------------------------------------------------------------------
        call    :readWord               ; read label name into word buffer
        ld.DE   :label                  ; use the label dictionary entry
        call    :findSymbol             ; search for label from word-buffer
        jr?z    _add                    ; add the label if doesn't exist

        ; label found:
        ;-----------------------------------------------------------------------
        ; the flag byte is used to indicate a forward-reference on a label;
        ; i.e. the label name is known, but doesn't have a value yet. we return
        ; this flag in the carry-flag by shifting it out of the byte
        ;
        ; for a deferred value the byte is 0; the shift keeps this as zero,
        ; sets zero-flag and CCF sets the carry-flag accordingly. for a valid
        ; value the byte is 1; the shift sets carry AND bit 7 (=$80), clearing
        ; zero-flag and CCF clears the carry
        ;
        ld.A*DE                         ; read forward-reference flag byte
        rrca                            ; shift bit 0 into bit 7 AND carry!
        ccf                             ; flip carry so forward-reference = 1
        ret?c                           ; return early on forward-reference

        ; return the label's value in BC:
        ;-----------------------------------------------------------------------
        dec.DE                          ; step past flag byte
        ex.DE.HL                        ; swap to HL for reg-loading
        ld.B*HL                         ; symbol value hi-byte
        dec.HL                          ; move to value lo-byte
        ld.C*HL                         ; return BC = symbol value
        ex.DE.HL                        ; return last addr in DE
        ret

        ; create a new label record on the heap:
        ;=======================================================================
        ; (any reference to a label that doesn't exist is a forward-reference)
        ;
        ;       - - - -+-------+------+---+---+---+---+---+-----+------+
        ;       <-heap | rsrvd | flag | l | e | b | a | l | len | link |
        ;       - - - -+-------+------+---+---+---+---+---+-----+------+
        ;
        ; - the link addr to the previous label
        ; - the label name length; here for faster searching
        ; - the label name, written right-to-left -- heap extends downwards!
        ; - a flag to indicate a forward-reference: this happens when a label
        ;   that does not exist is encountered in an expr, a placeholder label
        ;   is added to the heap to be filled in later. this is necessary for
        ;   the expr to be re-evaluated in the 2nd pass
        ; - two bytes are reserved for the value
        ;
        ; link this label to the previous one:
        ;
_add    ld.DE*  [ :label ]              ; read prev label addr
        dec.HL                          ; pre-decrement heap to empty byte
        ld*HL.D                         ; write prev label addr hi-byte
        dec.HL                          ; (this is the heap addr we want)
        ld*HL.E                         ; write prev label addr lo-byte
        ld*$.HL [ :label ]              ; update entry point with heap addr

        ; push the label name:
        ;-----------------------------------------------------------------------
        ld.DE   :word                   ; word-buffer addr
        inc.C                           ; length +1 to include the length-byte

        ; note that LDDR is post-decrement (copy-then-decrement), whereas
        ; the heap is pre-decrement like the stack (decrement-then-copy)
        ; -- decrement HL once to adjust for this before the copy
        ;
        dec.HL                          ; adjust heap for post-decrement copy
        push.HL                         ; this will be the length byte addr
        ex.DE.HL                        ; LDDR copies *from* [HL] *to* [DE]...
        lddr                            ; copy from word-buffer to heap

        ; push forward-reference flag:
        ;-----------------------------------------------------------------------
        ; the flag byte is designed so that findSymbol will return zero-flag
        ; set for forward-references, i.e. the label is considered undefined,
        ; but carry is set to distinguish labels that exist in the dictionary
        ; vs. those that don't (required for deferring expressions)
        ;
        ; the flag is flipped to allow some trickery on read out to return
        ; A=0 and set both zero-flag AND carry-flag for forward-references
        ;
        ; NOTE: LDDR has already decremented HL for us
        ;
        ld.H.D                          ; addr of flag-byte for forward-
        ld.L.E                          ;  references is returned in DE
        ld*HL.C                         ; fwd-ref = 0 (LDDR guarantees C=0)

        dec.HL                          ; reserve two bytes on the heap
        dec.HL                          ;  for the label value

        call    :errIfHeapOverflow      ; check for heap overflow

        pop.BC                          ; return length byte addr in BC
        scf                             ; return carry-flag set
        ret                             ;  for forward-references


:findSymbol
;===============================================================================
; searches for a symbol in a dictionary:
;
; in:   DE              dictionary entry point: an addr that contains the
;                       addr of the last symbol added to the dictionary,
;                       i.e. `label` for labels & `const` for constants
;       word            the symbol name needs to already be in the
;                       word-buffer, e.g. after calling `readWord`
;
; out:  A               non-zero if found. 0 if symbol not found
;       zf              zero-flag is set according to the above
;       BC              if symbol found, BC is addr of symbol length byte
;                       if symbol not found, BC is the symbol name length
;       DE              $0000 if not found, otherwise an addr pointing to
;                       the byte following the symbol name (e.g. the value)
;       HL              (preserved)
;-------------------------------------------------------------------------------
        push.HL                         ; preserve heap addr coming in
        ld.HL   :word                   ; start of word buffer
        ld.C*HL                         ; first byte is name length
        ld.B    0                       ; load this into BC
        ex.DE.HL                        ; DE = word buffer, HL = dict. addr
        jr      _next                   ; jump into the loop

        ;=======================================================================
        ; names do not match!
        ;
_nope   ld.E    <:word                  ; return to word-buffer length byte
        ld.A*DE                         ; restore the word-length to BC
        ld.C.A                          ; ...
        pop.HL                          ; return symbol length byte
_link   inc.HL                          ; move *up* to link addr lo-byte

        ;-----------------------------------------------------------------------
        ; the link field of a symbol points to      - - -+------+
        ; the lo-byte of the next symbol's link          | link |
        ; field in the chain, with the remaining    - - -+--|---+
        ; fields extending *downwards* in RAM       .-------'
        ;                                           v
        ;          ---+---+---+---+---+---+---+-----+------+
        ;  < heap     | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+-----+------+
        ;
        ; follow this link, but exit if it's $0000
        ; (also setting the zero-flag and clearing carry
        ;  -- did you know that OR cleared carry!??)
        ;
_next   ld.A*HL                         ; read next symbol addr, lo-byte
        inc.HL                          ; move *up* to link addr hi-byte
        ld.H*HL                         ; read next symbol addr, hi-byte
        ld.L.A                          ; (complete the addr)
        or.H                            ; is the link addr $0000?
        jr?z    _end                    ; terminate at end of chain

        ; (HL is now the next symbol addr in the heap)

        dec.HL                          ; move down to length byte
        ld.A*HL                         ; get symbol name length
        cp.C                            ; compare with word-buffer length
        jr?nz    _link                  ; different? return to link and follow

        ; symbol length matches, check characters:
        ;=======================================================================
        push.HL                         ; store symbol length addr to snap back
        dec.HL                          ; (skip length byte)
        ld.E    <:word                  ; start at top of word-buffer
        ;-----------------------------------------------------------------------
_char   dec.E                           ; move down a char in word-buffer
        ld.A*DE                         ; read char from word-buffer
        cpd                             ; = CP A, [HL]; DEC HL; DEC BC
        jr?nz   _nope                   ; stop looping if mismatch
        jp?v    _char                   ; keep looping until chars run out
        ;-----------------------------------------------------------------------
        ; if all characters match we fall through to here. CPD ensures
        ; that HL is pointing to the byte following the symbol-name
        ;
        ; the addr of the byte following (downwards) the symbol-name
        ; is returned in DE  -- on a const this is the value (hi-byte),
        ; and for labels this is the flag-byte
        ;
        ;          ---+---+---+---+---+---+---+---+-----+------+
        ;  < heap     | ? | l | o | b | m | y | s | len | link |
        ;          ---+---+---+---+---+---+---+---+-----+------+
        ;             ^ DE                        ^ BC
        ;
        pop.BC                          ; return symbol-length addr
        and.A                           ; A != 0, clear z-flag & carry-flag
_end    ex.DE.HL                        ; return last addr as DE
        pop.HL                          ; restore old heap addr
        ret


; types:
; - conditionals
; - keywords
; - strings
; - instructions
; - numbers / constants / labels or parens
; - operators

; there are only a handful of scopes that dictate
; which types are expected, where
;
; starting scope for an empty line:
; - PC (number)
; - label definition
; - conditional
#SCOPE_ROOT     $00
; an expression -- specifically an operand:
; - number / constant / label or parens
; - unary operator: < > ! -
#SCOPE_EXPR     $10
; an infix operator: + - * / & | ^ \
#SCOPE_INFIX    $11

:scope  .b      #SCOPE_ROOT             ; current scope during parsing

; which characters are valid in symbol names:
;-------------------------------------------------------------------------------
:symchr .b      $ff                     ; $20 SPC space
        .b      $ff                     ; $21  !  unary NOT operator
        .b      $ff                     ; $22  "  string marker
        .b      $ff                     ; $23  #  constant
        .b      $ff                     ; $24  $  hex literal / PC
        .b      $ff                     ; $25  %  binary literal
        .b      $ff                     ; $26  &  unary AND operator
        .b      $00                     ; $27  '  character literal
        .b      $ff                     ; $28  (  open parenthesis
        .b      $ff                     ; $29  )  close parenthesis
        .b      $ff                     ; $2A  *  multiply operator
        .b      $ff                     ; $2B  +  add operator
        .b      $ff                     ; $2C  ,  ...
        .b      $ff                     ; $2D  -  subtract operator
        .b      $00                     ; $2E  .  keyword
        .b      $ff                     ; $2F  /  divide operator
        .b      $00                     ; $30  0  decimal literal
        .b      $00                     ; $31  1  decimal literal
        .b      $00                     ; $32  2  decimal literal
        .b      $00                     ; $33  3  decimal literal
        .b      $00                     ; $34  4  decimal literal
        .b      $00                     ; $35  5  decimal literal
        .b      $00                     ; $36  6  decimal literal
        .b      $00                     ; $37  7  decimal literal
        .b      $00                     ; $38  8  decimal literal
        .b      $00                     ; $39  9  decimal literal
        .b      $ff                     ; $3A  :  label
        .b      $ff                     ; $3B  ;  comment
        .b      $ff                     ; $3C  <  unary lo-byte operator
        .b      $ff                     ; $3D  =  ...
        .b      $ff                     ; $3E  >  unary hi-byte operator
        .b      $ff                     ; $3F  ?  condition marker
        .b      $ff                     ; $40  @  ...
        .b      $00                     ; $41  A  CPU instruction mnemonic
        .b      $00                     ; $42  B  CPU instruction mnemonic
        .b      $00                     ; $43  C  CPU instruction mnemonic
        .b      $00                     ; $44  D  CPU instruction mnemonic
        .b      $00                     ; $45  E  CPU instruction mnemonic
        .b      $00                     ; $46  F  CPU instruction mnemonic
        .b      $00                     ; $47  G  CPU instruction mnemonic
        .b      $00                     ; $48  H  CPU instruction mnemonic
        .b      $00                     ; $49  I  CPU instruction mnemonic
        .b      $00                     ; $4A  J  CPU instruction mnemonic
        .b      $00                     ; $4B  K  CPU instruction mnemonic
        .b      $00                     ; $4C  L  CPU instruction mnemonic
        .b      $00                     ; $4D  M  CPU instruction mnemonic
        .b      $00                     ; $4E  N  CPU instruction mnemonic
        .b      $00                     ; $4F  O  CPU instruction mnemonic
        .b      $00                     ; $50  P  CPU instruction mnemonic
        .b      $00                     ; $51  Q  CPU instruction mnemonic
        .b      $00                     ; $52  R  CPU instruction mnemonic
        .b      $00                     ; $53  S  CPU instruction mnemonic
        .b      $00                     ; $54  T  CPU instruction mnemonic
        .b      $00                     ; $55  U  CPU instruction mnemonic
        .b      $00                     ; $56  V  CPU instruction mnemonic
        .b      $00                     ; $57  W  CPU instruction mnemonic
        .b      $00                     ; $58  X  CPU instruction mnemonic
        .b      $00                     ; $59  Y  CPU instruction mnemonic
        .b      $00                     ; $5A  Z  CPU instruction mnemonic
        .b      $ff                     ; $5B  [  open square brackets
        .b      $ff                     ; $5C  \  modulo operator
        .b      $ff                     ; $5D  ]  close square brackets
        .b      $ff                     ; $5E  ^  ...
        .b      $00                     ; $5F  _  ...
        .b      $ff                     ; $60  `  ...
        .b      $00                     ; $61  a  CPU instruction mnemonic
        .b      $00                     ; $62  b  CPU instruction mnemonic
        .b      $00                     ; $63  c  CPU instruction mnemonic
        .b      $00                     ; $64  d  CPU instruction mnemonic
        .b      $00                     ; $65  e  CPU instruction mnemonic
        .b      $00                     ; $66  f  CPU instruction mnemonic
        .b      $00                     ; $67  g  CPU instruction mnemonic
        .b      $00                     ; $68  h  CPU instruction mnemonic
        .b      $00                     ; $69  i  CPU instruction mnemonic
        .b      $00                     ; $6A  j  CPU instruction mnemonic
        .b      $00                     ; $6B  k  CPU instruction mnemonic
        .b      $00                     ; $6C  l  CPU instruction mnemonic
        .b      $00                     ; $6D  m  CPU instruction mnemonic
        .b      $00                     ; $6E  n  CPU instruction mnemonic
        .b      $00                     ; $6F  o  CPU instruction mnemonic
        .b      $00                     ; $70  p  CPU instruction mnemonic
        .b      $00                     ; $71  q  CPU instruction mnemonic
        .b      $00                     ; $72  r  CPU instruction mnemonic
        .b      $00                     ; $73  s  CPU instruction mnemonic
        .b      $00                     ; $74  t  CPU instruction mnemonic
        .b      $00                     ; $75  u  CPU instruction mnemonic
        .b      $00                     ; $76  v  CPU instruction mnemonic
        .b      $00                     ; $77  w  CPU instruction mnemonic
        .b      $00                     ; $78  x  CPU instruction mnemonic
        .b      $00                     ; $79  y  CPU instruction mnemonic
        .b      $00                     ; $7A  z  CPU instruction mnemonic
        .b      $ff                     ; $7B  {  ...
        .b      $ff                     ; $7C  |  unary OR operator
        .b      $ff                     ; $7D  }  ...
        .b      $ff                     ; $7E  ~  ...
        .b      $ff                     ; $7F DEL ERROR


:nextWord
;===============================================================================
; reads input and skips spaces until either:
;
; - the next non-terminating character
; - a newline or end-of-line character
; - a comment -- the comment text is skipped over and the next newline /
;   end-of-file is returned instead! therefore this routine MUST NOT
;   be used to skip over whitespace in string literals etc.
;
; WARN: this routine will return on newline and that there may be more leading
;       whitespace on the next line -- if you want to skip to the next non-
;       whitespace character, call the routine again after a newline!
;
; out:  A               ASCII code
;       zf              zero-flag is set for "no word", i.e. when the line
;                       ends before another valid word. check A for newline
;                       (ASCII_LF) to differentiate those. end-of-file might
;                       NOT be null! (e.g. CP/M uses ASCII_SUB)
;       HL, DE          (preserved)
;       BC              (clobbered)
;-------------------------------------------------------------------------------
_get    call    :getChr                 ; read a character (returns z-flag)
        ret?z                           ; return z-flag set if newline/EOF

        ; we need to be careful not to wrongly return z-flag set!
        ;
        ; we cannot check for ASCII_SPC+1 ("!") as if this character appears,
        ; the parser will think the file ended. instead look for space itself
        ; -- for any ASCII code below we continue looping, and space itself
        ; is caught with the zero-flag and re-looped
        ; 
        cp      #SPC                    ; is ASCII code a space?
        jr?c    _get                    ; keep reading if codes 1-31
        jr?z    _get                    ; also, keep reading if space

        cp      #CHR_COMMENT            ; is this the start of a comment?
        jr?z    _skip                   ; if yes, skip comment

        ; start of a word, update the line/col number for errors
        ;
        ld.BC*  [ :crow ]               ; copy current line number
        ld*$.BC [ :wrow ]               ;  to start-of-word line-number
        ld.C.A                          ; preserve read character
        ld.A*   [ :ccol ]               ; copy current column number
        ld*$.A  [ :wcol ]               ;  to start-of-word column-number
        ld.A.C                          ; restore read character
        ret

        ; skip over a comment until the newline / end-of-line:
        ;-----------------------------------------------------------------------
_skip   call    :getChr                 ; read a character (returns z-flag)
        jr?nz   _skip                   ; read until newline / end-of-file

        ret


:readWord
;===============================================================================
; read symbol name:
;
; if the symbol begins with `_` it's a local label and the last-defined label
; name will automatically be prepended to the symbol name being read in
;
; to save bytes in the heap, ":" and "#" sigils are automatically skipped,
; causing labels and consts to be stored on the heap without sigils
;
; NOTE: the word is written *downwards* in RAM, to match how symbol names
;       are pushed to the heap, for faster comparison -- we use the bottom
;       of a page to hold the incoming word so that we can get away with
;       using `DEC E` instead of `DEC DE`
;
; in:   A               first char is already read
; out:  A               length of word
;       DE              DE is set to the first byte (length) of `word`
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;       BC              (clobbered)
;-------------------------------------------------------------------------------
        ld.DE   :word                   ; top of word-buffer
        cp      #CHR_LOCAL              ; is this a local label?
        call?z  _local                  ; prepend last label defined
        cp      #CHR_LABEL              ; skip sigil for label?
        jr?z    _loop                   ; enter loop at point that skips char
        cp      #CHR_CONST              ; do the same for const sigil
        jr?nz   _in                     ; otherwise, append first char
        ;-----------------------------------------------------------------------
_loop   call    :getChr                 ; read char from input file
        cp      #SPC + 1                ; whitespace or end-of-line/file?
        jr?c    _ok                     ; (leave loop at whitespace)
_in     dec.E                           ; move to next space in buffer
        ld*DE.A                         ; add the character to the buffer
        jp?p    _loop                   ; keep going until buffer full
        ;-----------------------------------------------------------------------
        jp      :errInvalSym            ; quit with invalid symbol error

        ;-----------------------------------------------------------------------
_ok     ld.A    #WORD_LEN               ; max size - characters remaining
        sub.E                           ;  = length of word
        ld.E    <:word                  ; snap back to length byte
        ld*DE.A                         ; write word-length byte
        ret

        ; prepend last label name:
        ;=======================================================================
_local  push.HL                         ; preserve HL before copy

        ld.HL*  [ :local ]              ; last non-local label record addr
        ld.A.H                          ; but make sure it's not $0000!
        or.L                            ; can't define local label before label
        jp?z    :errUndefLocal          ; error if no label defined yet
        ld.C*HL                         ; read label-name length for copy
        ld.B    0                       ; (LDDR copies BC bytes...)
        inc.C                           ; +1 to include label-name length byte
        lddr                            ; copy BC bytes from [HL] to [DE]

        inc.E                           ; compensate for last DEC before return
        ld.A    #CHR_LOCAL              ; local label sigil must be included
        pop.HL                          ; restore HL used for copy
        ret


:getChr
;===============================================================================
; gets the next character from input file:
; current row and column are maintained
;
; out:  A               ASCII code
;       zf              zero-flag is set *both* for end-of-file and newline!
;       :char           the character read is also written to RAM
;       :crow, :ccol    line & column number are advanced accordingly
;       BC, DE, HL      (preserved)
;-------------------------------------------------------------------------------
        call    :osGetChar              ; read a char from file
        ld*$.A  [ :char ]               ; retain returned character

        ?!      #DEBUG
                ;///////////////////////////////////////////////////////////////
                push.AF
                call    :osPrintChar    ; print each character as we receive it
                pop.AF                  ; (zero-flag must be preserved)
                ;///////////////////////////////////////////////////////////////
        ret?z                           ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      #CR                     ; /r is always ignored,
        jr?z    :getChr                 ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld.HL'  :ccol                   ; prepare to increment column number

        cp      #LF                     ; /n is newline
        jr?z    _row                    ; handle newline
        cp      #TAB                    ; /t is tab
        jr?z    _tab                    ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; lines in v80 source code are hard limited to 127 columns to ensure
        ; PC-users don't write code that exceeds real 8-bit hardware's limits,
        ; although 80 cols is strongly recommended as this is the practical
        ; width of many 8-bit system's displays
        ;
_col    inc*HL'                         ; line length is limited to 127 bytes
        jp?m    :errRangeLine           ; 128th char (sign bit) line too long!
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
_row    ld.DE'* [ :crow ]               ; 16-bit load,
        inc.DE'                         ;  and increment,
        ld*$.DE' [ :crow ]              ;  and write
        ld*HL'  $00                     ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
_tab    dec.A                           ; \t = 9, so change to 8 (width of tab)
        add*HL'                         ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        jp?m    :errRangeLine           ; stop if line too long! (>=128 chars)
        ld*HL'A                         ; update column number
        ld.A    #SPC                    ; return a single space instead
        ld*$.A  [ :char ]               ; update retained value to match
        and.A                           ; ensure zero-flag is clear!

        exx                             ; restore HL/DE
        ret


:defLabel
;===============================================================================
        ret

:chrErr
;===============================================================================
        halt

:chrAny
;===============================================================================
        ret

:chrEOL
;===============================================================================
; could be newline (LF), or end-of-file
;-------------------------------------------------------------------------------
        ret

:chrSpc
;===============================================================================
        ret

:chrComment
;===============================================================================
        ret

:chrKeyword
;===============================================================================
        ret

:chrHex
;===============================================================================
        ; parse the number first, decide what to do based on scope afterwards:
        ;
        ; note that if the word is a single `$`, the current
        ; program-counter value is returned with carry-flag set
        ;
        ; FIXME :parseHexNum must break at any non-number,
        ;       not just whitespace, e.g. operators
        ;
        call    :parseHexNum            ; parse number into BC
        ld.A*   [ :scope ]              ; (get current scope)
        jr?c    _pc                     ; is program-counter?

        ;jp?z   :exprPushOperand        ; append value to the expr bytecode

        ret

        ;-----------------------------------------------------------------------
_pc     and.A                           ; check if scope is zero (root)
        jr?z    _pcexpr                 ; defining program counter with expr?
        ; TODO: if yes, we are defining the program-counter
        ;jp     :exprPushOperand        ; otherwise append vaue to expr

        ;-----------------------------------------------------------------------
_pcexpr 

:chrBin
;===============================================================================
        ret

:chrDec
;===============================================================================
        ret

:chrChr
;===============================================================================
        ret

:chrLabel
;===============================================================================
        ; assume correctness and read the label first
        ;
        ld.A    ':
        call    :readWord

;;        ; is a label expected in this mode?
;;        ;
;;        pop.AF                          ; current mode
;;        cp      #MODE_LINE              ; at the start of a line?
;;        jp?z    :defLabel               ; if yes, define a label

        halt                            ; unexpected label!

:chrLocal
;===============================================================================
        ret

:chrConst
;===============================================================================
        ret

:chrStr
;===============================================================================
        ret

:chrCond
;===============================================================================
        ret

:chrEqu
;===============================================================================
        ret

:chrLo
;===============================================================================
        ret

:chrHi
;===============================================================================
        ret

:chrAND
;===============================================================================
        ret

:chrOR
;===============================================================================
        ret

:chrNOT
;===============================================================================
        ret

:chrXOR
;===============================================================================
        ret

:chrIn
;===============================================================================
        ret

:chrOut
;===============================================================================
        ret

:chrAdd
;===============================================================================
        ret

:chrSub
;===============================================================================
        ret

:chrMul
;===============================================================================
        ret

:chrDiv
;===============================================================================
        ret

:chrMod
;===============================================================================
        ret

:chrCPU
;===============================================================================
        ret

;===============================================================================
.a      $0100

:ascjp  .w      :chrSpc                 ; $20 SPC space
        .w      :chrNOT                 ; $21  !  unary NOT operator
        .w      :chrStr                 ; $22  "  string marker
        .w      :chrConst               ; $23  #  constant
        .w      :chrHex                 ; $24  $  hex literal / PC
        .w      :chrBin                 ; $25  %  binary literal
        .w      :chrAND                 ; $26  &  unary AND operator
        .w      :chrChr                 ; $27  '  character literal
        .w      :chrIn                  ; $28  (  open parenthesis
        .w      :chrOut                 ; $29  )  close parenthesis
        .w      :chrMul                 ; $2A  *  multiply operator
        .w      :chrAdd                 ; $2B  +  add operator
        .w      :chrAny                 ; $2C  ,  ...
        .w      :chrSub                 ; $2D  -  subtract operator
        .w      :chrKeyword             ; $2E  .  keyword
        .w      :chrDiv                 ; $2F  /  divide operator
        .w      :chrDec                 ; $30  0  decimal literal
        .w      :chrDec                 ; $31  1  decimal literal
        .w      :chrDec                 ; $32  2  decimal literal
        .w      :chrDec                 ; $33  3  decimal literal
        .w      :chrDec                 ; $34  4  decimal literal
        .w      :chrDec                 ; $35  5  decimal literal
        .w      :chrDec                 ; $36  6  decimal literal
        .w      :chrDec                 ; $37  7  decimal literal
        .w      :chrDec                 ; $38  8  decimal literal
        .w      :chrDec                 ; $39  9  decimal literal
        .w      :chrLabel               ; $3A  :  label
        .w      :chrComment             ; $3B  ;  comment
        .w      :chrLo                  ; $3C  <  unary lo-byte operator
        .w      :chrAny                 ; $3D  =  ...
        .w      :chrHi                  ; $3E  >  unary hi-byte operator
        .w      :chrCond                ; $3F  ?  condition marker
        .w      :chrAny                 ; $40  @  ...
        .w      :chrCPU                 ; $41  A  CPU instruction mnemonic
        .w      :chrCPU                 ; $42  B  CPU instruction mnemonic
        .w      :chrCPU                 ; $43  C  CPU instruction mnemonic
        .w      :chrCPU                 ; $44  D  CPU instruction mnemonic
        .w      :chrCPU                 ; $45  E  CPU instruction mnemonic
        .w      :chrCPU                 ; $46  F  CPU instruction mnemonic
        .w      :chrCPU                 ; $47  G  CPU instruction mnemonic
        .w      :chrCPU                 ; $48  H  CPU instruction mnemonic
        .w      :chrCPU                 ; $49  I  CPU instruction mnemonic
        .w      :chrCPU                 ; $4A  J  CPU instruction mnemonic
        .w      :chrCPU                 ; $4B  K  CPU instruction mnemonic
        .w      :chrCPU                 ; $4C  L  CPU instruction mnemonic
        .w      :chrCPU                 ; $4D  M  CPU instruction mnemonic
        .w      :chrCPU                 ; $4E  N  CPU instruction mnemonic
        .w      :chrCPU                 ; $4F  O  CPU instruction mnemonic
        .w      :chrCPU                 ; $50  P  CPU instruction mnemonic
        .w      :chrCPU                 ; $51  Q  CPU instruction mnemonic
        .w      :chrCPU                 ; $52  R  CPU instruction mnemonic
        .w      :chrCPU                 ; $53  S  CPU instruction mnemonic
        .w      :chrCPU                 ; $54  T  CPU instruction mnemonic
        .w      :chrCPU                 ; $55  U  CPU instruction mnemonic
        .w      :chrCPU                 ; $56  V  CPU instruction mnemonic
        .w      :chrCPU                 ; $57  W  CPU instruction mnemonic
        .w      :chrCPU                 ; $58  X  CPU instruction mnemonic
        .w      :chrCPU                 ; $59  Y  CPU instruction mnemonic
        .w      :chrCPU                 ; $5A  Z  CPU instruction mnemonic
        .w      :chrIn                  ; $5B  [  open square brackets
        .w      :chrMod                 ; $5C  \  modulo operator
        .w      :chrOut                 ; $5D  ]  close square brackets
        .w      :chrAny                 ; $5E  ^  ...
        .w      :chrLocal               ; $5F  _  ...
        .w      :chrAny                 ; $60  `  ...
        .w      :chrCPU                 ; $61  a  CPU instruction mnemonic
        .w      :chrCPU                 ; $62  b  CPU instruction mnemonic
        .w      :chrCPU                 ; $63  c  CPU instruction mnemonic
        .w      :chrCPU                 ; $64  d  CPU instruction mnemonic
        .w      :chrCPU                 ; $65  e  CPU instruction mnemonic
        .w      :chrCPU                 ; $66  f  CPU instruction mnemonic
        .w      :chrCPU                 ; $67  g  CPU instruction mnemonic
        .w      :chrCPU                 ; $68  h  CPU instruction mnemonic
        .w      :chrCPU                 ; $69  i  CPU instruction mnemonic
        .w      :chrCPU                 ; $6A  j  CPU instruction mnemonic
        .w      :chrCPU                 ; $6B  k  CPU instruction mnemonic
        .w      :chrCPU                 ; $6C  l  CPU instruction mnemonic
        .w      :chrCPU                 ; $6D  m  CPU instruction mnemonic
        .w      :chrCPU                 ; $6E  n  CPU instruction mnemonic
        .w      :chrCPU                 ; $6F  o  CPU instruction mnemonic
        .w      :chrCPU                 ; $70  p  CPU instruction mnemonic
        .w      :chrCPU                 ; $71  q  CPU instruction mnemonic
        .w      :chrCPU                 ; $72  r  CPU instruction mnemonic
        .w      :chrCPU                 ; $73  s  CPU instruction mnemonic
        .w      :chrCPU                 ; $74  t  CPU instruction mnemonic
        .w      :chrCPU                 ; $75  u  CPU instruction mnemonic
        .w      :chrCPU                 ; $76  v  CPU instruction mnemonic
        .w      :chrCPU                 ; $77  w  CPU instruction mnemonic
        .w      :chrCPU                 ; $78  x  CPU instruction mnemonic
        .w      :chrCPU                 ; $79  y  CPU instruction mnemonic
        .w      :chrCPU                 ; $7A  z  CPU instruction mnemonic
        .w      :chrAny                 ; $7B  {  ...
        .w      :chrOR                  ; $7C  |  unary OR operator
        .w      :chrAny                 ; $7D  }  ...
        .w      :chrAny                 ; $7E  ~  ...
        .w      :chrErr                 ; $7F DEL ERROR

:nextToken
;===============================================================================
        call    :getChr                 ; pull the next character from input
        cp      #SPC                    ; is non-visible ASCII code < $20?
        jp?c    :chrEOL                 ; handle CR|LF (EOL) or EOF

        ; TODO: can remove this instruction if we place :nextToken before
        ;       the table and offset the table by 32 bytes, or expand the
        ;       table to include $00-$1F so the space comparison is not
        ;       paid for every byte at the cost of 64 bytes
        ;
        sub     $20                     ; rebase ASCII code for table
        add.A                           ; x2 for table of addresses
        ld*$.A  [ _jp + 1 ]             ; set lo-byte of table-entry    ;+13=13
_jp     ld.HL*  [ :ascjp ]              ; read addr from table          ;+16=29
        jp*HL                           ; jump to result!               ;+ 4=33


:asm
;===============================================================================
        jp      :nextToken

#size_of_asm2   $ - :asm2