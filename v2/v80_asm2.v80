; v80, (C) Kroc Camen 2023-2024, MIT License
; the parsing / assembling loop
;
; include the selected ISA:
;-------------------------------------------------------------------------------
; remember that this is the instruction set that you want your v80 binary
; to assemble, not the CPU it's running on! this code is already the z80
; port ("v80"), so it's implied that you're running on Z80
;
?=      #V80_ISA - #ISA_Z80
        .i      "v80_z80.v80"           ; Z80 ISA support code
        .i      "isa_z80.v80"           ; Z80 ISA instructions

?=      #V80_ISA - #ISA_6502
        .i      "v80_6502.v80"          ; 6502 ISA support code
        .i      "isa_6502.v80"          ; 6502 ISA instructions

; (for measuring size of new assembler)
:asm2

; the parser roughly implements this EBNF:
; <https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>
;
; SPC           = \s | \t, { SPC } ;
; EOL           = EOF | { \r }, \n ;
; EOF           = 0x00 | 0x1A ;                   (* EOF is 0x1A on CP/M! *)
;
; comment       = ";", { \t | 0x20-0x7E } ;
;
; (* note the mutual exclusivity of defining a constant
;    or including a file, and any other line content *)
;
; root          = [ SPC ],                      (* optional leading space *)
;                 [ include                     (* include and const-def *)
;                 | const_def                   (*  are mutually exclusive *)
;                 | line                        (*  with assembly code *)
;                 ], [ SPC, comment ]           (* optional comment *)
;                 EOL                           (* end of line / file *)
;               ;
; include       = ".i", SPC, string ;
; const_def     = const, SPC, expr ;
;
; line          = [ label_def ],                (* def PC / label once *)
;               | cond                          (* condition block, or *)
;               | body                          (* assembly code *)
;               ;
; body          = ( keyword | instr ), { SPC, asm } ;
;
; label_def     = [ pc_def ], label ;
; cond          = "?", ( "=" | "!" | "+" | "-" ), SPC, expr
;
; const         = "#", name ;
; label         = ( ":" | "_" ), name ;
;
; name          = char, { char } ;
; char          = "a"-"z" | "A"-"Z" | "0"-"9" | "." | "_" ;
;
; pc_def        = ( "$", SPC, expr ) | hex ;
;
; num           = hex | bin | dec | chr ;
; hex           = "$", { "0"-"9" | "A"-"F" | "a"-"f" } ;
; bin           = "%", ( "0" | "1" ), { "0", "1" } ;
; dec           = "0"-"9", { "0"-"9" } ;
; chr           = "'", 0x21-0x7E ;
;
; keyword       = ".", ( align | fill | byte | word ) ;
; align         = "a", SPC, expr ;
; fill          = "f", SPC, expr, { SPC }, expr ;
; byte          = "b", SPC, bytes ;             (* may contain strings *)
; word          = "w", SPC, list ;              (* may NOT contain strings *)
;
; bytes         = ( string | expr ), { SPC, bytes } ;
; list          = expr, { SPC, expr } ;
; string        = '"', { \t | 0x20-0x21 | 0x23-0x7E }, '"' ;
;
; expr          = { unary }, value, { [ SPC ] op [ SPC ], expr } ;
; unary         = "-" | "<" | ">" | "!" ;
; value         = ( "(", [ SPC ], expr, [ SPC ], ")" )
;               | ( "[", [ SPC ], expr, [ SPC ], "]" )
;               | const | label | num
;               ;
; op            = "+" | "-" | "*" | "/" | "&" | "|" | "^" | "\" ;
;
; instr         = ? CPU INSTRUCTION ?, { SPC, expr } ;
;
;
; there are only a handful of scopes that dictate
; which words are expected, where
;
; TODO: could we hold the scope permenantly in A'?
;
; an empty line can begin with either an include, a program-counter
; declaration, a label or constant definition, a conditional block,
; or finally, keywords and assembly instructions
;
;       #const  $0000                   ; define constant
;       $0000   ...                     ; define PC
;       $0000   :label  ...             ; define PC and label
;       :label  ...                     ; define label alone
;
#SCOPE_ROOT     $00
; once a program-counter is defined it cannot be defined again
; so we change from "root" scope to "line" scope:
#SCOPE_LINE     $01
; and if a label or const is defined, it cannot be defined again
; so we enter the "body" scope to exclude that:
#SCOPE_BODY     $02

; when a parameter is parsed and no other content is allowed on the line,
; e.g. a constant definition, this scope expects only end-of-line or file
#SCOPE_EOL      $0f

; an expression -- specifically an operand:
; - number / constant / label or parens
; - unary operator: < > ! -
#SCOPE_EXPR     $10
; once an operand is parsed it must be followed by either an infix operator,
; + - * / & | ^ \, or a non-expression word ending the expression
#SCOPE_INFIX    $11

:scope  .b      #SCOPE_ROOT             ; current scope during parsing


:assembleFile
;===============================================================================
; opens a file and assembles it:
;
; in:   DE              addr of file-name string, forwards, null-terminated
;       HL              current heap addr
; out:  HL              (preserved) -- stuff may be pushed to heap
;       A, BC, DE       (clobbered)
;-------------------------------------------------------------------------------
        call    :echoCommentNewline
        call    :osFileOpen             ; use the OS to open the file [DE]
        call    :echoCommentLn          ; (echo the file-name
        call    :echoCommentBar         ;  and a dividing line)

        ; search the file-name dictionary and return the address
        ; of the file-name record (in BC), adding it if not present
        ;
        ; this is done *after* opening the file so that if the file
        ; is missing, the source of the error is reported as the
        ; file+line containing the include statement
        ;
        call    :getFileID              ; search for or add file-name [DE]
        ld*$.BC [ :file ]               ; set current file-name addr

        ; reset line & column number when changing file:
        ; (the call to :_line will call :nextWord which will
        ;  set the start-of-word line/col number for us)
        ;
        xor.A                           ; (set A to zero)
        ld*$.A  [ :ccol ]               ; reset column number
        ld.BC   1                       ; line number however
        ld*$.BC [ :crow ]               ;  defaults to 1

        ld.A    #SCOPE_ROOT             ; set starting parsing scope
        call    :next                   ; run the parsing loop

        halt

        ; execution will be returned here
        ; once the end of the file is reached
        ;
_eof    call    :osFileClose            ; close the file

        ; WARN: this cannot be optimised into a JP due to
        ;       osFileClose doing stack manipulation
        ret


; which characters are valid in symbol names:
;-------------------------------------------------------------------------------
:symchr .b      $ff                     ; $20 SPC space
        .b      $ff                     ; $21  !  unary NOT operator
        .b      $ff                     ; $22  "  string marker
        .b      $ff                     ; $23  #  constant
        .b      $ff                     ; $24  $  hex literal / PC
        .b      $ff                     ; $25  %  binary literal
        .b      $ff                     ; $26  &  AND operator
        .b      $ff                     ; $27  '  character literal
        .b      $ff                     ; $28  (  open parenthesis
        .b      $ff                     ; $29  )  close parenthesis
        .b      $ff                     ; $2A  *  multiply operator
        .b      $ff                     ; $2B  +  add operator
        .b      $ff                     ; $2C  ,  ...
        .b      $ff                     ; $2D  -  negate / subtract operator
        .b      $00                     ; $2E  .  keyword
        .b      $ff                     ; $2F  /  divide operator
        .b      $00                     ; $30  0  decimal literal
        .b      $00                     ; $31  1  decimal literal
        .b      $00                     ; $32  2  decimal literal
        .b      $00                     ; $33  3  decimal literal
        .b      $00                     ; $34  4  decimal literal
        .b      $00                     ; $35  5  decimal literal
        .b      $00                     ; $36  6  decimal literal
        .b      $00                     ; $37  7  decimal literal
        .b      $00                     ; $38  8  decimal literal
        .b      $00                     ; $39  9  decimal literal
        .b      $ff                     ; $3A  :  label
        .b      $ff                     ; $3B  ;  comment
        .b      $ff                     ; $3C  <  unary lo-byte operator
        .b      $ff                     ; $3D  =  ...
        .b      $ff                     ; $3E  >  unary hi-byte operator
        .b      $ff                     ; $3F  ?  condition marker
        .b      $ff                     ; $40  @  ...
        .b      $00                     ; $41  A  CPU instruction mnemonic
        .b      $00                     ; $42  B  CPU instruction mnemonic
        .b      $00                     ; $43  C  CPU instruction mnemonic
        .b      $00                     ; $44  D  CPU instruction mnemonic
        .b      $00                     ; $45  E  CPU instruction mnemonic
        .b      $00                     ; $46  F  CPU instruction mnemonic
        .b      $00                     ; $47  G  CPU instruction mnemonic
        .b      $00                     ; $48  H  CPU instruction mnemonic
        .b      $00                     ; $49  I  CPU instruction mnemonic
        .b      $00                     ; $4A  J  CPU instruction mnemonic
        .b      $00                     ; $4B  K  CPU instruction mnemonic
        .b      $00                     ; $4C  L  CPU instruction mnemonic
        .b      $00                     ; $4D  M  CPU instruction mnemonic
        .b      $00                     ; $4E  N  CPU instruction mnemonic
        .b      $00                     ; $4F  O  CPU instruction mnemonic
        .b      $00                     ; $50  P  CPU instruction mnemonic
        .b      $00                     ; $51  Q  CPU instruction mnemonic
        .b      $00                     ; $52  R  CPU instruction mnemonic
        .b      $00                     ; $53  S  CPU instruction mnemonic
        .b      $00                     ; $54  T  CPU instruction mnemonic
        .b      $00                     ; $55  U  CPU instruction mnemonic
        .b      $00                     ; $56  V  CPU instruction mnemonic
        .b      $00                     ; $57  W  CPU instruction mnemonic
        .b      $00                     ; $58  X  CPU instruction mnemonic
        .b      $00                     ; $59  Y  CPU instruction mnemonic
        .b      $00                     ; $5A  Z  CPU instruction mnemonic
        .b      $ff                     ; $5B  [  open square brackets
        .b      $ff                     ; $5C  \  modulo operator
        .b      $ff                     ; $5D  ]  close square brackets
        .b      $ff                     ; $5E  ^  XOR operator
        .b      $00                     ; $5F  _  ...
        .b      $ff                     ; $60  `  ...
        .b      $00                     ; $61  a  CPU instruction mnemonic
        .b      $00                     ; $62  b  CPU instruction mnemonic
        .b      $00                     ; $63  c  CPU instruction mnemonic
        .b      $00                     ; $64  d  CPU instruction mnemonic
        .b      $00                     ; $65  e  CPU instruction mnemonic
        .b      $00                     ; $66  f  CPU instruction mnemonic
        .b      $00                     ; $67  g  CPU instruction mnemonic
        .b      $00                     ; $68  h  CPU instruction mnemonic
        .b      $00                     ; $69  i  CPU instruction mnemonic
        .b      $00                     ; $6A  j  CPU instruction mnemonic
        .b      $00                     ; $6B  k  CPU instruction mnemonic
        .b      $00                     ; $6C  l  CPU instruction mnemonic
        .b      $00                     ; $6D  m  CPU instruction mnemonic
        .b      $00                     ; $6E  n  CPU instruction mnemonic
        .b      $00                     ; $6F  o  CPU instruction mnemonic
        .b      $00                     ; $70  p  CPU instruction mnemonic
        .b      $00                     ; $71  q  CPU instruction mnemonic
        .b      $00                     ; $72  r  CPU instruction mnemonic
        .b      $00                     ; $73  s  CPU instruction mnemonic
        .b      $00                     ; $74  t  CPU instruction mnemonic
        .b      $00                     ; $75  u  CPU instruction mnemonic
        .b      $00                     ; $76  v  CPU instruction mnemonic
        .b      $00                     ; $77  w  CPU instruction mnemonic
        .b      $00                     ; $78  x  CPU instruction mnemonic
        .b      $00                     ; $79  y  CPU instruction mnemonic
        .b      $00                     ; $7A  z  CPU instruction mnemonic
        .b      $ff                     ; $7B  {  ...
        .b      $ff                     ; $7C  |  OR operator
        .b      $ff                     ; $7D  }  ...
        .b      $ff                     ; $7E  ~  ...
        .b      $ff                     ; $7F DEL ERROR


:nextWord
;===============================================================================
; reads input and skips spaces until either:
;
; - the next non-terminating character
; - a newline or end-of-line character
; - a comment -- the comment text is skipped over and the next newline /
;   end-of-file is returned instead! therefore this routine MUST NOT
;   be used to skip over whitespace in string literals etc.
;
; WARN: this routine will return on newline and that there may be more leading
;       whitespace on the next line -- if you want to skip to the next non-
;       whitespace character, call the routine again after a newline!
;
; out:  A               ASCII code
;       zf              zero-flag is set for "no word", i.e. when the line
;                       ends before another valid word. check A for newline
;                       (ASCII_LF) to differentiate those. end-of-file might
;                       NOT be null! (e.g. CP/M uses ASCII_SUB)
;       HL, DE          (preserved)
;       BC              (clobbered)
;-------------------------------------------------------------------------------
_get    call    :getChr                 ; read a character (returns z-flag)
        ret?z                           ; return z-flag set if newline/EOF

        ; we need to be careful not to wrongly return z-flag set!
        ;
        ; we cannot check for ASCII_SPC+1 ("!") as if this character appears,
        ; the parser will think the file ended. instead look for space itself
        ; -- for any ASCII code below we continue looping, and space itself
        ; is caught with the zero-flag and re-looped
        ; 
        cp      #SPC                    ; is ASCII code a space?
        jr?c    _get                    ; keep reading if codes 1-31
        jr?z    _get                    ; also, keep reading if space

        cp      #CHR_COMMENT            ; is this the start of a comment?
        jr?z    _skip                   ; if yes, skip comment

        ; start of a word, update the line/col number for errors
        ;
        ld.BC*  [ :crow ]               ; copy current line number
        ld*$.BC [ :wrow ]               ;  to start-of-word line-number
        ld.C.A                          ; preserve read character
        ld.A*   [ :ccol ]               ; copy current column number
        ld*$.A  [ :wcol ]               ;  to start-of-word column-number
        ld.A.C                          ; restore read character
        ret

        ; skip over a comment until the newline / end-of-line:
        ;-----------------------------------------------------------------------
_skip   call    :getChr                 ; read a character (returns z-flag)
        jr?nz   _skip                   ; read until newline / end-of-file

        ret


:getWord
;===============================================================================
; read symbol name:
;
; if the symbol begins with `_` it's a local label and the last-defined label
; name will automatically be prepended to the symbol name being read in
;
; to save bytes in the heap, ":"/"_" and "#" sigils are automatically skipped,
; causing labels and consts to be stored on the heap without sigils
;
; NOTE: the word is written *downwards* in RAM, to match how symbol names
;       are pushed to the heap, for faster comparison -- we use the bottom
;       of a page to hold the incoming word so that we can get away with
;       using `DEC E` instead of `DEC DE`
;
; in:   A               first char is already read
; out:  A               length of word
;       DE              DE is set to the first byte (length) of `word`
;       [char]          the last character read will always be some kind
;                       of whitespace -- space, newline or end-of-file
;       HL              (preserved)
;       BC              (clobbered)
;       !               errors on invalid character in a word, or when
;                       a local label is named before a label is defined
;-------------------------------------------------------------------------------
        ld.DE   :word                   ; top of word-buffer
        cp      #CHR_LOCAL              ; is this a local label?
        call?z  _local                  ; prepend last label defined
        cp      #CHR_LABEL              ; skip sigil for label?
        jr?z    _loop                   ; enter loop at point that skips char
        cp      #CHR_CONST              ; do the same for const sigil
        jr?nz   _in                     ; otherwise, append first char
        ;-----------------------------------------------------------------------
_loop   call    :getChr                 ; read char from input file
        cp      #SPC + 1                ; whitespace or end-of-line/file?
        jr?c    _ok                     ; (leave loop at whitespace)
_in     dec.E                           ; move to next space in buffer
        ld*DE.A                         ; add the character to the buffer
        jp?p    _loop                   ; keep going until buffer full
        ;-----------------------------------------------------------------------
        jp      :errInvalSym            ; quit with invalid symbol error

        ;-----------------------------------------------------------------------
_ok     ld.A    #WORD_LEN               ; max size - characters remaining
        sub.E                           ;  = length of word
        ld.E    <:word                  ; snap back to length byte
        ld*DE.A                         ; write word-length byte
        ret

        ; prepend last label name:
        ;=======================================================================
_local  push.HL                         ; preserve HL before copy

        ld.HL*  [ :local ]              ; last non-local label record addr
        ld.A.H                          ; but make sure it's not $0000!
        or.L                            ; can't define local label before label
        jp?z    :errUndefLocal          ; error if no label defined yet
        ld.C*HL                         ; read label-name length for copy
        ld.B    0                       ; (LDDR copies BC bytes...)
        inc.C                           ; +1 to include label-name length byte
        lddr                            ; copy BC bytes from [HL] to [DE]

        inc.E                           ; compensate for last DEC before return
        ld.A    #CHR_LOCAL              ; local label sigil must be included
        pop.HL                          ; restore HL used for copy
        ret


:getChr
;===============================================================================
; gets the next character from input file:
; current row and column are maintained
;
; out:  A               ASCII code
;       zf              zero-flag is set *both* for end-of-file and newline!
;       :char           the character read is also written to RAM
;       :crow, :ccol    line & column number are advanced accordingly
;       BC, DE, HL      (preserved)
;       !               errors if a line exceeds 127 chars
;-------------------------------------------------------------------------------
        call    :osGetChar              ; read a char from file
        ld*$.A  [ :char ]               ; retain returned character

        ?!      #DEBUG
                ;///////////////////////////////////////////////////////////////
                push.AF
                call    :osPrintChar    ; print each character as we receive it
                pop.AF                  ; (zero-flag must be preserved)
                ;///////////////////////////////////////////////////////////////
        ret?z                           ; return on end-of-file

        ; check for end-of-line:
        ;-----------------------------------------------------------------------
        cp      #CR                     ; /r is always ignored,
        jr?z    :getChr                 ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld.HL'  :ccol                   ; prepare to increment column number

        cp      #LF                     ; /n is newline
        jr?z    _row                    ; handle newline
        cp      #TAB                    ; /t is tab
        jr?z    _tab                    ; handle tab

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; lines in v80 source code are hard limited to 127 columns to ensure
        ; PC-users don't write code that exceeds real 8-bit hardware's limits,
        ; although 80 cols is strongly recommended as this is the practical
        ; width of many 8-bit system's displays
        ;
_col    inc*HL'                         ; line length is limited to 127 bytes
        jp?m    :errRangeLine           ; 128th char (sign bit) line too long!
        exx                             ; restore HL/DE
        ret

        ;-----------------------------------------------------------------------
        ; increment line-number:
        ;
_row    ld.DE'* [ :crow ]               ; 16-bit load,
        inc.DE'                         ;  and increment,
        ld*$.DE' [ :crow ]              ;  and write
        ld*HL'  $00                     ; reset column number

        exx                             ; restore HL/DE
        ret                             ; return z-flag set for newline/EOF

        ;-----------------------------------------------------------------------
        ; handle tab-character:
        ;
_tab    dec.A                           ; \t = 9, so change to 8 (width of tab)
        add*HL'                         ; add 8 to current column
        and     %11111000               ; clip to every 8th column
        jp?m    :errRangeLine           ; stop if line too long! (>=128 chars)
        ld*HL'A                         ; update column number
        ld.A    #SPC                    ; return a single space instead
        ld*$.A  [ :char ]               ; update retained value to match
        and.A                           ; ensure zero-flag is clear!

        exx                             ; restore HL/DE
        ret


:next
;===============================================================================
; parse the next word:
;
; a word is read from the source and, based on the first
; character, we jump to a routine to parse that type
;
; in:   A       parsing scope to use
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ld*$.A  [ :scope ]              ; set the parsing scope from param

        call    :getChr                 ; pull the next character from input
        cp      #SPC                    ; is non-visible ASCII code < $20?
        jp?c    :chrEOL                 ; handle CR|LF (EOL) or EOF

        ; TODO: can remove this instruction if we place :next before
        ;       the table and offset the table by 32 bytes, or expand the
        ;       table to include $00-$1F so the space comparison is not
        ;       paid for every word at the cost of 64 bytes
        ;
        sub     $20                     ; rebase ASCII code for table
        add.A                           ; x2 for table of addresses
        ld*$.A  [ _jp + 1 ]             ; set lo-byte of table-entry    ;+13=13
_jp     ld.HL*  [ :ascjp ]              ; read addr from table          ;+16=29
        jp*HL                           ; jump to result!               ;+ 4=33


:chrErr
;===============================================================================
        halt

:chrEOL
;===============================================================================
; could be newline (LF), or end-of-file
;-------------------------------------------------------------------------------
        ret

:chrSpc
;===============================================================================
        ret

:chrComment
;===============================================================================
        ret

:chrKeyword
;===============================================================================
        ret

:chrHex
;===============================================================================
; word is a hexadecimal number literal,
; or the program-counter symbol:
;-------------------------------------------------------------------------------
        ; parse the number first, decide what to do based on scope afterwards:
        ;
        ; note that if the word is a single `$`, the current
        ; program-counter value is returned with carry-flag set
        ;
        ; FIXME :parseHexNum must break at any non-number,
        ;       not just whitespace, e.g. operators
        ;
        call    :parseHexNum            ; parse number into BC
        ld.A*   [ :scope ]              ; (get current scope)
        jr?c    _pc                     ; is program-counter?

        ; a hex literal at the start of a line defines the program-counter
        ;
        and.A                           ; check if scope is zero (root)
        jr?z    _setpc                  ; if yes, set the program-counter
        
        halt
        ;jp?z   :exprPushOperand        ; append value to the expr bytecode

        ; the number is `$`; the current program-counter:
        ;-----------------------------------------------------------------------
_pc     and.A                           ; check if scope is zero (root)
        jr?z    _pcexpr                 ; defining program counter with expr?

        ; TODO: push to expression
        cp      #SCOPE_EXPR             ; is expression operand?
        jp      :next                   
        
        halt

        ;-----------------------------------------------------------------------
        ; TODO: define the program-counter using an expr:
        ;
_pcexpr halt

        ; set the program-counter:
        ;-----------------------------------------------------------------------
_setpc  ld.IXL.C                        ; change the virtual program-counter
        ld.IXH.B                        ;  to the number given

        ld.A    #SCOPE_LINE             ; change scope so that the PC
        jp      :next                   ;  cannot be defined again


:chrBin
;===============================================================================
        halt

:chrDec
;===============================================================================
        halt

:chrChr
;===============================================================================
        halt

:chrLocal
;===============================================================================
; word is a local label:
;-------------------------------------------------------------------------------
        ld.A    #CHR_LOCAL
        .b      $01                     ; Z80: skip 2 bytes; = LD.BC $....

:chrLabel
;===============================================================================
; word is a label:
;-------------------------------------------------------------------------------
        ld.A    #CHR_LABEL
        ld*$.A  [ _1st + 1 ]            ; first char determines label or local

        ; check scope:
        ;
        ; a label at the start of a line, or following the definition
        ; of the program-counter, defines a label
        ;
        ld.A*   [ :scope ]              ; (get current scope)
        cp      #SCOPE_LINE +1          ; is root or line scope?
        jr?c    _def                    ; if yes, define label

        ; TODO: label in expr, etc.
        ;
        halt                            ; unexpected label!

        ; define label:
        ;=======================================================================
_def    call    :getLabel               ; get label value or push as fwd-ref
        jp?nc   :errRedefLabel          ; cannot redefine labels!

        ; :getLabel has returned the addr of the label name length byte [BC]
        ; and the addr of the flag-byte of the label record [DE] so we can
        ; flip the flag and fill in the true value of the label
        ;
_1st    ld.A    $00                     ; check first char (patched above)
        cp      #CHR_LOCAL              ; was this a local label?
        jr?z    _0                      ; if yes, skip over last-defined
        ld*$.BC [ :local ]              ; set last defined label addr

_0      push.BC                         ; we'll  print the label name later
        ex.DE.HL                        ; (swap label addr to HL)
        ld*HL   1                       ; set flag byte to indicate valid value
        dec.HL                          ; decrement to label value, hi-byte
        ld.B.IXH                        ; put virtual program-counter, hi-byte
        ld*HL.B                         ; ...
        dec.HL                          ; decrement to label value, lo-byte
        ld.C.IXL                        ; out virtual program-counter, lo-byte
        ld*HL.C                         ; ...
        ex.DE.HL                        ; (return heap to HL)

        ; echo label value & name:
        ;-----------------------------------------------------------------------
        ; echo the label as v80 source, address first
        ; (sets program-counter) followed by the label name:
        ;
        call    :printHexNum            ; print value in BC with "$" sigil
        call    :echoSpc                ; print spc between addr & label name
        pop.DE                          ; restore label-name addr from earlier
        ld.A    #CHR_LABEL              ;  and print label name
        call    :printSymbolNameSigil   ;  + newline
        call    :osPrintNewline         ;  ...

        ; after defining a label, the scope changes to disallow defining
        ; another label or constant, or changing the program-counter
        ;
        ld.A    #SCOPE_BODY             ; scope will be changed
        jp      :next                   ; return to parsing


:chrConst
;===============================================================================
; word is a constant:
;-------------------------------------------------------------------------------
        ; check scope:
        ;
        ; a const at the start of a line defines a constant
        ;
        ld.A*   [ :scope ]              ; (get current scope)
        cp      #SCOPE_ROOT             ; is root scope?
        jr?z    _def                    ; if yes, define constant

        halt                            ; unexpected const!

        ; define constant:
        ;=======================================================================
_def    halt


:chrStr
;===============================================================================
        halt

:chrCond
;===============================================================================
        halt

:chrEqu
;===============================================================================
        halt

:chrLo
;===============================================================================
        halt

:chrHi
;===============================================================================
        halt

:chrAND
;===============================================================================
        halt

:chrOR
;===============================================================================
        halt

:chrNOT
;===============================================================================
        halt

:chrXOR
;===============================================================================
        halt

:chrIn
;===============================================================================
        halt

:chrOut
;===============================================================================
        halt

:chrAdd
;===============================================================================
        halt

:chrSub
;===============================================================================
        halt

:chrMul
;===============================================================================
        halt

:chrDiv
;===============================================================================
        halt

:chrMod
;===============================================================================
        halt

:chrCPU
;===============================================================================
        halt

;===============================================================================
.a      $0100

:ascjp  .w      :chrSpc                 ; $20 SPC space
        .w      :chrNOT                 ; $21  !  unary NOT operator
        .w      :chrStr                 ; $22  "  string marker
        .w      :chrConst               ; $23  #  constant
        .w      :chrHex                 ; $24  $  hex literal / PC
        .w      :chrBin                 ; $25  %  binary literal
        .w      :chrAND                 ; $26  &  unary AND operator
        .w      :chrChr                 ; $27  '  character literal
        .w      :chrIn                  ; $28  (  open parenthesis
        .w      :chrOut                 ; $29  )  close parenthesis
        .w      :chrMul                 ; $2A  *  multiply operator
        .w      :chrAdd                 ; $2B  +  add operator
        .w      :chrErr                 ; $2C  ,  ...
        .w      :chrSub                 ; $2D  -  subtract operator
        .w      :chrKeyword             ; $2E  .  keyword
        .w      :chrDiv                 ; $2F  /  divide operator
        .w      :chrDec                 ; $30  0  decimal literal
        .w      :chrDec                 ; $31  1  decimal literal
        .w      :chrDec                 ; $32  2  decimal literal
        .w      :chrDec                 ; $33  3  decimal literal
        .w      :chrDec                 ; $34  4  decimal literal
        .w      :chrDec                 ; $35  5  decimal literal
        .w      :chrDec                 ; $36  6  decimal literal
        .w      :chrDec                 ; $37  7  decimal literal
        .w      :chrDec                 ; $38  8  decimal literal
        .w      :chrDec                 ; $39  9  decimal literal
        .w      :chrLabel               ; $3A  :  label
        .w      :chrComment             ; $3B  ;  comment
        .w      :chrLo                  ; $3C  <  unary lo-byte operator
        .w      :chrErr                 ; $3D  =  ...
        .w      :chrHi                  ; $3E  >  unary hi-byte operator
        .w      :chrCond                ; $3F  ?  condition marker
        .w      :chrErr                 ; $40  @  ...
        .w      :chrCPU                 ; $41  A  CPU instruction mnemonic
        .w      :chrCPU                 ; $42  B  CPU instruction mnemonic
        .w      :chrCPU                 ; $43  C  CPU instruction mnemonic
        .w      :chrCPU                 ; $44  D  CPU instruction mnemonic
        .w      :chrCPU                 ; $45  E  CPU instruction mnemonic
        .w      :chrCPU                 ; $46  F  CPU instruction mnemonic
        .w      :chrCPU                 ; $47  G  CPU instruction mnemonic
        .w      :chrCPU                 ; $48  H  CPU instruction mnemonic
        .w      :chrCPU                 ; $49  I  CPU instruction mnemonic
        .w      :chrCPU                 ; $4A  J  CPU instruction mnemonic
        .w      :chrCPU                 ; $4B  K  CPU instruction mnemonic
        .w      :chrCPU                 ; $4C  L  CPU instruction mnemonic
        .w      :chrCPU                 ; $4D  M  CPU instruction mnemonic
        .w      :chrCPU                 ; $4E  N  CPU instruction mnemonic
        .w      :chrCPU                 ; $4F  O  CPU instruction mnemonic
        .w      :chrCPU                 ; $50  P  CPU instruction mnemonic
        .w      :chrCPU                 ; $51  Q  CPU instruction mnemonic
        .w      :chrCPU                 ; $52  R  CPU instruction mnemonic
        .w      :chrCPU                 ; $53  S  CPU instruction mnemonic
        .w      :chrCPU                 ; $54  T  CPU instruction mnemonic
        .w      :chrCPU                 ; $55  U  CPU instruction mnemonic
        .w      :chrCPU                 ; $56  V  CPU instruction mnemonic
        .w      :chrCPU                 ; $57  W  CPU instruction mnemonic
        .w      :chrCPU                 ; $58  X  CPU instruction mnemonic
        .w      :chrCPU                 ; $59  Y  CPU instruction mnemonic
        .w      :chrCPU                 ; $5A  Z  CPU instruction mnemonic
        .w      :chrIn                  ; $5B  [  open square brackets
        .w      :chrMod                 ; $5C  \  modulo operator
        .w      :chrOut                 ; $5D  ]  close square brackets
        .w      :chrXOR                 ; $5E  ^  XOR operator
        .w      :chrLocal               ; $5F  _  local label
        .w      :chrErr                 ; $60  `  ...
        .w      :chrCPU                 ; $61  a  CPU instruction mnemonic
        .w      :chrCPU                 ; $62  b  CPU instruction mnemonic
        .w      :chrCPU                 ; $63  c  CPU instruction mnemonic
        .w      :chrCPU                 ; $64  d  CPU instruction mnemonic
        .w      :chrCPU                 ; $65  e  CPU instruction mnemonic
        .w      :chrCPU                 ; $66  f  CPU instruction mnemonic
        .w      :chrCPU                 ; $67  g  CPU instruction mnemonic
        .w      :chrCPU                 ; $68  h  CPU instruction mnemonic
        .w      :chrCPU                 ; $69  i  CPU instruction mnemonic
        .w      :chrCPU                 ; $6A  j  CPU instruction mnemonic
        .w      :chrCPU                 ; $6B  k  CPU instruction mnemonic
        .w      :chrCPU                 ; $6C  l  CPU instruction mnemonic
        .w      :chrCPU                 ; $6D  m  CPU instruction mnemonic
        .w      :chrCPU                 ; $6E  n  CPU instruction mnemonic
        .w      :chrCPU                 ; $6F  o  CPU instruction mnemonic
        .w      :chrCPU                 ; $70  p  CPU instruction mnemonic
        .w      :chrCPU                 ; $71  q  CPU instruction mnemonic
        .w      :chrCPU                 ; $72  r  CPU instruction mnemonic
        .w      :chrCPU                 ; $73  s  CPU instruction mnemonic
        .w      :chrCPU                 ; $74  t  CPU instruction mnemonic
        .w      :chrCPU                 ; $75  u  CPU instruction mnemonic
        .w      :chrCPU                 ; $76  v  CPU instruction mnemonic
        .w      :chrCPU                 ; $77  w  CPU instruction mnemonic
        .w      :chrCPU                 ; $78  x  CPU instruction mnemonic
        .w      :chrCPU                 ; $79  y  CPU instruction mnemonic
        .w      :chrCPU                 ; $7A  z  CPU instruction mnemonic
        .w      :chrErr                 ; $7B  {  ...
        .w      :chrOR                  ; $7C  |  unary OR operator
        .w      :chrErr                 ; $7D  }  ...
        .w      :chrErr                 ; $7E  ~  ...
        .w      :chrErr                 ; $7F DEL ERROR

#size_of_asm2   $ - :asm2